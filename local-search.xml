<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>screen使用教程-无比简单</title>
    <link href="undefined2019/07/01/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%97%A0%E6%AF%94%E7%AE%80%E5%8D%95/"/>
    <url>2019/07/01/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%97%A0%E6%AF%94%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h2><pre><code class="javaScript">创建：screen -S fuck查看有多少会话：screen -ls恢复：screen -r fuck删除 screen -S fuck -X quit</code></pre><h3 id="screen-r-fuck-失败"><a href="#screen-r-fuck-失败" class="headerlink" title="screen -r fuck 失败"></a>screen -r fuck 失败</h3><pre><code>如果不能恢复：先screen -d fuck,再screen -r fuck</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx的邻居caddy</title>
    <link href="undefined2019/07/01/nginx%E7%9A%84%E9%82%BB%E5%B1%85caddy/"/>
    <url>2019/07/01/nginx%E7%9A%84%E9%82%BB%E5%B1%85caddy/</url>
    
    <content type="html"><![CDATA[<p>本文不讲安装,只讲最简单的配置<br>每次配置更新完要 sudo pkill -USR1 caddy 刷新</p><h2 id="将静态文件映射到二级域名"><a href="#将静态文件映射到二级域名" class="headerlink" title="将静态文件映射到二级域名"></a>将静态文件映射到二级域名</h2><pre><code>你想在外网访问的网站地址 {  tls 你的破https证书  gzip  root  你的网站本地地址  index 首页 不填默认index的东西}</code></pre><h2 id="反代理"><a href="#反代理" class="headerlink" title="反代理"></a>反代理</h2><pre><code>你想在外网访问的网站地址 {  tls 你的破https证书  proxy / localhost:你想访问的破端口}</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>可以把几个文件合并拼接起来<br>例如</p><h3 id="a-conf"><a href="#a-conf" class="headerlink" title="a.conf"></a>a.conf</h3><pre><code>你的破配置</code></pre><h3 id="b-conf"><a href="#b-conf" class="headerlink" title="b.conf"></a>b.conf</h3><pre><code>import a.conf</code></pre><p>相当于把<strong>a.conf</strong>里的代码拷贝到<strong>b.conf</strong>里.没啥特别的</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM是什么？</title>
    <link href="undefined2019/05/17/ORM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>2019/05/17/ORM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="引用-阮一峰博客"><a href="#引用-阮一峰博客" class="headerlink" title="引用-阮一峰博客"></a>引用-<a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html" target="_blank" rel="noopener">阮一峰博客</a></h1><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><h3 id="字面意思"><a href="#字面意思" class="headerlink" title="字面意思"></a>字面意思</h3><p>实际上就是个缩写，表示对象-关系映射的缩写</p><ul><li><code>O</code>-&gt;<strong>Object</strong></li><li><code>RM</code>-&gt;<strong>Relational</strong> (关系) <strong>Mapping(映射)</strong></li></ul><h3 id="代表什么思想"><a href="#代表什么思想" class="headerlink" title="代表什么思想"></a>代表什么思想</h3><p>实际上就是一种把数据库映射成对象的想法</p><ul><li>数据库的表（<code>table</code>） –&gt; 类（<code>class</code>）</li><li>记录（<code>record</code>，行数据）–&gt; 对象（<code>object</code>）</li><li>字段（<code>field</code>）–&gt; 对象的属性（<code>attribute</code>）</li></ul><p><strong>比如说查询语句 <code>SELECT id, first_name, last_name, phone, birth_date, sex FROM persons WHERE id = 10</code></strong></p><p>对应到代码就是</p><pre><code class="c#">res = db.执行数据库(sql);name = res[0][&quot;FIRST_NAME&quot;];</code></pre><p>那么<strong>ORM</strong>的写法就是</p><pre><code class="c#">p = Person.get(10);name = p.first_name;</code></pre><p>这样的好处就是可以不需要了解数据库底层，因为它不需要接触<code>SQL</code>语句</p><p>所以<code>ORM</code>有这样一些优点</p><ul><li><code>ORM</code>生态已经比较完备，有很多的工具支持</li><li>天生的<code>MVC</code>，<code>ORM</code>就是天生的<code>Model</code></li><li>可以不写<code>SQL</code>了。</li></ul><p>它的缺点来说：</p><ul><li>复杂查询很难做到，做到了性能也很差</li><li>学习成本比较高</li><li>由于不需要接触<code>SQL</code>所以无法定制一些特殊的<code>SQL</code></li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>目前公认最规范的是 Ruby 语言的 <a href="https://guides.rubyonrails.org/active_record_basics.html" target="_blank" rel="noopener">Active Record</a>。Active Record 对于对象和数据库表的映射，有一些命名限制。</p><p>（1）一个类对应一张表。类名是单数，且首字母大写；表名是复数，且全部是小写。比如，表 <code>books</code> 对应类 <code>Book</code>。</p><p>（2）如果名字是不规则复数，则类名依照英语习惯命名，比如，表 <code>mice</code> 对应类 <code>Mouse</code>，表 <code>people</code> 对应类 <code>Person</code>。</p><p>（3）如果名字包含多个单词，那么类名使用首字母全部大写的骆驼拼写法，而表名使用下划线分隔的小写单词。比如，表 <code>book_clubs</code> 对应类 <code>BookClub</code>，表 <code>line_items</code> 对应类 <code>LineItem</code>。</p><p>（4）每个表都必须有一个主键字段，通常是叫做 <code>id</code> 的整数字段。外键字段名约定为单数的表名 + 下划线 + id，比如 <code>item_id</code> 表示该字段对应 <code>items</code> 表的 <code>id</code> 字段。</p><h2 id="示例库-OpenRecord"><a href="#示例库-OpenRecord" class="headerlink" title="示例库 OpenRecord"></a>示例库 <a href="https://github.com/PhilWaldmann/openrecord" target="_blank" rel="noopener">OpenRecord</a></h2><p><code>OpenRecord</code> 是仿 <code>Active Record</code> 的，将其移植到了 <code>JavaScript</code>，而且实现得很轻量级，学习成本较低。我写了一个<a href="https://github.com/ruanyf/openrecord-demos" target="_blank" rel="noopener">示例库</a>，请将它克隆到本地。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>使用 ORM 的第一步，就是你必须告诉它，怎么连接数据库（<a href="https://github.com/ruanyf/openrecord-demos/blob/master/demos/demo01.js" target="_blank" rel="noopener">完整代码</a>看这里）。</p><blockquote><pre><code class="javascript">// demo01.jsconst Store = require(&#39;openrecord/store/sqlite3&#39;)const store = new Store({    type: &#39;sqlite3&#39;,    file: &#39;./db/sample.db&#39;,    autoLoad: true,})await store.connect()</code></pre></blockquote><p>连接成功以后，就可以操作数据库了。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>没啥好说的，就是<strong>ORM</strong>的框架会把表转成类对象</p><h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p>也没什么好说的，增删改查都从查询语句变成了调用方法</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>表与表之间的关系（relation），分成三种。</p><blockquote><ul><li><strong>一对一</strong>（one-to-one）：一种对象与另一种对象是一一对应关系，比如一个学生只能在一个班级。</li><li><strong>一对多</strong>（one-to-many）： 一种对象可以属于另一种对象的多个实例，比如一张唱片包含多首歌。</li><li><strong>多对多</strong>（many-to-many）：两种对象彼此都是 “一对多” 关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片。</li></ul></blockquote><p>了解到这就足够用了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可能是全x最好的vue教程</title>
    <link href="undefined2018/07/12/vue%E6%95%99%E7%A8%8B/"/>
    <url>2018/07/12/vue%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h1><h2 id="为什么不支持-IE8"><a href="#为什么不支持-IE8" class="headerlink" title="为什么不支持 IE8"></a>为什么不支持 IE8</h2><p>其实是依赖<strong>Object.defineProperty()</strong>，进行数据挟持的，而这个 api 在 IE8 下仅仅支持 Dom 对象不支持原生对象，所以 Vue2.x 是不支持 IE8 及以下的浏览器。</p><h2 id="Object-defineProperty-object-propertyname-descriptor"><a href="#Object-defineProperty-object-propertyname-descriptor" class="headerlink" title="Object.defineProperty(object, propertyname, descriptor )"></a>Object.defineProperty(object, propertyname, descriptor )</h2><p>此函数有 3 个参数，均是必传的参数。这个函数的特性其实很像 c#的属性，有 c#基础的理解起来应该很容易。</p><ul><li><p>object：需要设置的对象</p></li><li><p>propertyname：需要设置的属性名（对象的键名）</p></li><li><p>descriptor：描述符，一个对象，用于设置属性的特性。</p><pre><code class="javascript">{    value:undefined, // 表示此属性的值。    writable:false, // 决定此属性是否可写    configurable:true,        /*        决定此属性是否可配置，        如果为false则writable, configurable, enumerable这些属性的设置都将无效.        即使重新调用defineProperty函数也无效。        特别指出 试图修改configurable的值会抛出异常。        */    enumerable:false, // 是否可枚举    get:undefined, // 函数，当取值时执行    set:undefined, // 函数，当设置值时执行}</code></pre><pre><code class="javascript">// 此demo示范get和set的作用，其他的属性自行尝试。const setName = function(newValue) {  console.log(&#39;新的值&#39;, newValue);};const getName = function() {  console.log(&#39;取值啦&#39;);};var demo = {  name: &#39;初始值&#39;};Object.defineProperty(demo, &#39;name&#39;, {  set: setName,  get: getName});demo.name = &#39;初始值2&#39;;// -&gt; 新的值 初始值2let name = demo.name;// -&gt; 取值啦</code></pre></li></ul><h2 id="Vue-cli3-0-一些变动"><a href="#Vue-cli3-0-一些变动" class="headerlink" title="Vue-cli3.0 一些变动"></a>Vue-cli3.0 一些变动</h2><ul><li>集成 sass/scss 只需要 <code>yarn add sass-loader node-sass</code></li><li>设置 scss 全局函数要在<code>vue.config.js</code>里添加</li></ul><pre><code>module.exports = {  // ...  css: {    loaderOptions: {      sass: {        data: `          @import &quot;@/你的全局scss文件&quot;;        `      }    }  }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端架构-vue-初次学习</title>
    <link href="undefined2018/05/30/web%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    <url>2018/05/30/web%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h2 id="整体框架：vue2-x"><a href="#整体框架：vue2-x" class="headerlink" title="整体框架：vue2.x"></a>整体框架：vue2.x</h2><h3 id="为什么选择-Vue"><a href="#为什么选择-Vue" class="headerlink" title="为什么选择 Vue"></a>为什么选择 Vue</h3><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ul><li>具有热更新功能，代码变更保存即可看到效果，对提高调试与开发的效率有很大帮助。</li><li>社区资源丰富，大部分的问题均可查找得到合理的解决方案。</li><li>语法简洁。</li><li>Api 友好。</li><li>Github 维护热度高，大量高质量程序员都参与其中。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li>Bilibili、简书、饿了么、掘金、搜狐手机版、UC 奇趣百科等知名网站都在使用 Vue</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>不输给目前其他流行框架 如 ReactJs，AngularJS</li><li>原生渲染</li><li>自动按需加载组件，ReactJs 暂时不能做到自动按需加载。</li></ul><h4 id="自身优势"><a href="#自身优势" class="headerlink" title="自身优势"></a>自身优势</h4><ul><li>高度模块化。</li><li>维护简单。</li><li>数据双向绑定，跨组件强制单向数据流。</li></ul><h2 id="UI-库"><a href="#UI-库" class="headerlink" title="UI 库"></a>UI 库</h2><p>后期有需求会增加别的 ui 库</p><ul><li><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">ElementUi</a></li><li><a href="https://chenz24.github.io/vue-blu/#/" target="_blank" rel="noopener">Vue blu</a></li></ul><h2 id="网络请求框架"><a href="#网络请求框架" class="headerlink" title="网络请求框架"></a>网络请求框架</h2><ul><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a><pre><code>使用范例axios    .get(&#39;rul&#39;)    .then(response =&gt; (this.info = response))</code></pre></li></ul><h2 id="工具链："><a href="#工具链：" class="headerlink" title="工具链："></a>工具链：</h2><ul><li><a href="https://yarnpkg.com/lang/en/" target="_blank" rel="noopener">yarn</a>：快速、可靠、安全的依赖管理，npm 的升级版。</li><li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>：是 JavaScript 世界的包管理器，大部分的 JS 开发者会在这里发布他们的库。</li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack</a>：前端构建工具，用与打包压缩混淆前端代码。</li><li><a href="http://eslint.cn/" target="_blank" rel="noopener">Eslint</a>：静态代码检查器，用于规范开发编码习惯。</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ul><li>组件内部双向绑定</li><li>子组件与父组件单向绑定</li></ul><h2 id="设计模式：Mvvm"><a href="#设计模式：Mvvm" class="headerlink" title="设计模式：Mvvm"></a>设计模式：Mvvm</h2><ul><li>为了让页面与页面逻辑分离。</li><li>降低耦合度。</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/5692364-6ccaecf3481d7dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><ul><li>node_modules：存放 npm 下载的包，所有第三方的库都会存放在这里。</li><li>Page：用于存放页面<ul><li>View：具体的页面样式与 html 结构。<ul><li>Css：控制页面的样式。</li><li>Html：控制页面的 Dom 树。</li></ul></li><li>Model：每个页面所需要的数据结构。</li><li>ViewModel：页面的 VM，负责具体业务并且让 View 与 Model 交互。</li></ul></li><li>Components：用于存放单个组件。<ul><li>ControlComponents：控制类组件，具有可操作的能力，例如操纵 Dom，可以存储输入状态如日期选择器。</li><li>ViewComponents：展示类组件，不具有操作的能力，不存储非 UI 的状态，不直接修改外部环境。</li><li>ContainerComponents：容器类组件 如卡片。</li></ul></li><li>router<ul><li>设置页面的路由</li></ul></li></ul><h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><ul><li>扩展 js<br><img src="https://upload-images.jianshu.io/upload_images/5692364-ea55f8bca6e4a162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="公共js.png"></li></ul><h3 id="控制类组件"><a href="#控制类组件" class="headerlink" title="控制类组件"></a>控制类组件</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-0f1828413f3d6554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="控制类组件构建.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5692364-519efa270d13e96f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="控制类组件.png"></p><ul><li>展示类组件<br><img src="https://upload-images.jianshu.io/upload_images/5692364-1306b65112c7c634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="展示类组件结构.png"></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5692364-e73c2b538b813cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="展示类组件.png"></p><ul><li>容器类组件<br><img src="https://upload-images.jianshu.io/upload_images/5692364-b16163ce1f818544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="容器类组件.png"></li></ul><h2 id="页面构建结构"><a href="#页面构建结构" class="headerlink" title="页面构建结构"></a>页面构建结构</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-01b499bb6f636217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="页面结构.png"></p><h4 id="首页（例子）"><a href="#首页（例子）" class="headerlink" title="首页（例子）"></a>首页（例子）</h4><p><img src="https://upload-images.jianshu.io/upload_images/5692364-0ee0f6ea4cef58ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="首页结构.png"></p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>一个页面由多个组件组建而成，ViewModel 控制组件交互，并且负责具体业务。</p><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-7d83c04898cd2cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="页面结构.png"></p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><ul><li>组件不能含有具体业务逻辑。</li><li>展示类组件应只允许输入数据。</li><li>控制类组件要暴露回调函数给外部组件控制，并且隐藏不必要的细节。</li><li><code>View</code> 与 <code>Model</code> 的交互必须通过 <code>ViewModel</code></li><li>凡是可复用的函数或者组件都必须抽象封装出来。</li><li>不许对 api 请求 try catch，应该判断状态码做相应的事情。</li><li>尽量使用 <code>let</code> 和 <code>const</code> 声明变量名。</li><li>禁止使用 <code>eval</code> 函数</li><li>禁止使用 <code>NaN</code>，要用 <code>isNaN()</code></li><li>变量命名要尽量易懂，不容易懂的应加上注释</li><li>函数用小驼峰命名，</li><li>组件命名遵循：“my-component”，且使用小驼峰。</li><li><code>class</code> 命名大驼峰。</li><li>变量名 小驼峰。</li><li><code>HTML、CSS、Vue</code> 文件需要同名并且命名需要是名词。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读黑客与画家有感</title>
    <link href="undefined2018/05/13/%E8%AF%BB%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E6%9C%89%E6%84%9F/"/>
    <url>2018/05/13/%E8%AF%BB%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>前几天一口气读完了黑客与画家，留下点感悟。</p><h2 id="书呆子不受欢迎的原因"><a href="#书呆子不受欢迎的原因" class="headerlink" title="书呆子不受欢迎的原因"></a>书呆子不受欢迎的原因</h2><p>学校是个特殊的地方，它是人为设计出来的，一半像无菌室，一半像野蛮之地。它就像人生一样，无所不包，却又不是事情的真相。它只是一个短暂的过程，只要你向前看，就能超越它，即使你身在其中。</p><ul><li>受欢迎是要付出精力的，他们更愿意把精力放在变得更优秀上。</li><li>欺负书呆子的原因可能是为了自己不被孤立。</li><li>特别受欢迎的人很少去欺负特别不受欢迎的人。</li></ul><h2 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h2><h3 id="黑客真正想做的是设计优美的软件"><a href="#黑客真正想做的是设计优美的软件" class="headerlink" title="黑客真正想做的是设计优美的软件"></a>黑客真正想做的是设计优美的软件</h3><ul><li>大公司里设计软件的职责是技工，翻译产品经历的“构想”成代码</li><li>想战胜大公司的方法是将设计权交给黑客</li><li>编程跟绘画很像，不要一开始就追求完美的软件；起个草案，逐步修改</li></ul><h2 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h2><p>不能说的话，社会中总有些话好像是不能说出来的，政治不正确的话就是其中一类。</p><h3 id="找出不能说的话"><a href="#找出不能说的话" class="headerlink" title="找出不能说的话"></a>找出不能说的话</h3><ul><li>与历史对比，看看哪些以前可以说现在不能说，或者反之。</li><li>想想有什么话是你不敢在大众面前说的。</li><li>看看那些卫道者到底在捍卫什么。</li><li>观察禁忌是如何产生的，来龙去脉是什么。</li><li>那些所谓的异端邪说，被冠上有伤风化之类的帽子的话。</li></ul><h3 id="为什么要找不能说的话？"><a href="#为什么要找不能说的话？" class="headerlink" title="为什么要找不能说的话？"></a>为什么要找不能说的话？</h3><ul><li>好奇心，纯粹的好奇。</li><li>没有什么东西是不应该思考就有答案的。</li></ul><h3 id="发现了不能说的话之后怎么办？"><a href="#发现了不能说的话之后怎么办？" class="headerlink" title="发现了不能说的话之后怎么办？"></a>发现了不能说的话之后怎么办？</h3><p>闭嘴，别说。</p><h2 id="创造财富的最好的方法就是创业"><a href="#创造财富的最好的方法就是创业" class="headerlink" title="创造财富的最好的方法就是创业"></a>创造财富的最好的方法就是创业</h2><ul><li>可测量性：你的职位必须是可测量的，不然做再多也没有更多报酬。</li><li>可放大性：你的决定必须能够产生巨大效应。</li></ul><h2 id="防止垃圾邮件的一种方法"><a href="#防止垃圾邮件的一种方法" class="headerlink" title="防止垃圾邮件的一种方法"></a>防止垃圾邮件的一种方法</h2><ul><li>对单词做<a href="https://www.jianshu.com/p/5e8d7984e629" target="_blank" rel="noopener">贝叶斯判断</a></li></ul><h2 id="研究和设计的区别"><a href="#研究和设计的区别" class="headerlink" title="研究和设计的区别"></a>研究和设计的区别</h2><p>研究必须是新的，而设计必须是“好”的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机杂锦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack-简易</title>
    <link href="undefined2018/05/09/webpack%E6%95%99%E7%A8%8B/"/>
    <url>2018/05/09/webpack%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li>安装 node.js npm</li><li>安装 webpack npm install webpack -g</li><li>进入项目目录 是否有<code>package.json</code>没有就通过<code>npm init</code>创建</li><li>在项目目录下命令行执行<code>npm install webpack --save-dev</code></li><li>创建<code>webpack.config.js</code>文件,下面是例子</li></ul><pre><code>const path = require(&#39;path&#39;)module.exports = {  entry: &#39;./js/main.js&#39;, // 代码输入文件  // 下面的文件夹和文件不需要自己创建  output: {    path: path.resolve(__dirname, &#39;./dist&#39;), // 代码输入文件夹    filename: &#39;build.js&#39;  }}</code></pre><ul><li><p>在 package.json 文件</p><ul><li>在 scripts 下加<code>&quot;start&quot;: &quot;webpack&quot;</code></li></ul></li><li><p>命令行 npm start</p></li><li><p>其他的文件写法</p></li></ul><p><code>app.js</code></p><pre><code>const Say = require(&#39;./to.js&#39;)……Say()</code></pre><p><code>to.js</code></p><pre><code>var Say = function () {    console.log(&#39;hello&#39;)}module.exports = Say</code></pre><ul><li>导入 jq 等插件的方式<code>npm install jquery --save-dev</code></li></ul><pre><code>var $ = require(&#39;jquery&#39;)</code></pre><ul><li>运行<br>命令行敲 <code>webpack --mode production</code><br>如果想实时刷新<code>webpack --mode production --watch</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈依赖注入</title>
    <link href="undefined2018/05/09/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>2018/05/09/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖注入个人见解"><a href="#依赖注入个人见解" class="headerlink" title="依赖注入个人见解"></a>依赖注入个人见解</h1><p>当笔记用，勿喷。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>我不想因为我的依赖变化导致每次我都要改造自己</li><li>我不想再控制我的依赖了</li><li>我不关心我在依赖谁，我只想使用依赖的功能而已</li></ul><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>依赖注入跟控制反转是一起出现的，首先就要理解什么叫依赖注入，什么叫控制反转。</p><ul><li>依赖注入：将依赖用注入的方式送给你。</li><li>控制反转：本来依赖由你来控制，现在你不控制它了，随便丢给某人控制，这叫控制反转。</li></ul><p>举个例子：</p><ul><li>依赖注入：你家里有上千台手机，每天你都要用手机看直播，你只想看直播，并不关心什么手机，然后每天管家都会去挑选一个合适的手机塞给你，这个<code>管家塞给你</code>的过程就叫依赖注入。</li><li>控制反转：本来这个手机是由你来控制用什么手机的，现在你不关心它了，丢给管家处理，这个管理权的变化就叫控制反转。</li></ul><p>一个很精彩的例子<br><code>假设你自己是一个“口”字，你的需求是变成一个别的字，这时候如果传一个“人”，就变成了“囚”；如果传入“十”，就变成了“田”；如果传入“木”就变成了“困”</code></p><p>依赖抽象而不依赖具体</p><p>控制反转是一种思想，实现控制反转的技术手段就是依赖注入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机杂锦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现懒加载和瀑布流</title>
    <link href="undefined2018/01/10/%E7%80%91%E5%B8%83%E6%B5%81/"/>
    <url>2018/01/10/%E7%80%91%E5%B8%83%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="懒加载与瀑布流结合"><a href="#懒加载与瀑布流结合" class="headerlink" title="懒加载与瀑布流结合"></a>懒加载与瀑布流结合</h1><p><a href="https://lazy.dashao.me" target="_blank" rel="noopener">演示地址</a></p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><ul><li>使用了语义化的 html 使得代码更可读，利用了部分 html5 特性。</li><li>大量使用 es6 语法使得代码更简洁</li><li>支持响应式和媒体查询</li></ul><h2 id="GitHub-地址-大家多多支持～"><a href="#GitHub-地址-大家多多支持～" class="headerlink" title="GitHub 地址 大家多多支持～"></a><a href="https://github.com/chendss/WaterfallLazyLoading" target="_blank" rel="noopener">GitHub 地址</a> 大家多多支持～</h2><p><img src="http://upload-images.jianshu.io/upload_images/5692364-63bd3df17e2da54c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="loading.gif"></p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-08c776512cd93d40.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="lazy.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2048小游戏javascript实现</title>
    <link href="undefined2018/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8Fjavascript%E5%AE%9E%E7%8E%B0/"/>
    <url>2018/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8Fjavascript%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="原生-js-实现-2048-小游戏"><a href="#原生-js-实现-2048-小游戏" class="headerlink" title="原生 js 实现 2048 小游戏"></a>原生 js 实现 2048 小游戏</h1><p><a href="https://github.com/chendss/2048" target="_blank" rel="noopener">GitHub 地址</a> ，希望大家多多捧场觉得还可以就给个 star 吧～</p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><ul><li>利用了 css3 实现动画效果</li><li>使用了语义化的 html 使得代码更可读，利用了部分 html5 特性。</li><li>纯原生的 javascript 代码操控 DOM 控制元素组件</li><li>大量使用 es6 语法使得代码更简洁</li></ul><h2 id="试玩地址"><a href="#试玩地址" class="headerlink" title="试玩地址"></a>试玩地址</h2><p><a href="https://2048.dashao.me" target="_blank" rel="noopener">2048</a></p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/5692364-f61ba16480e4202b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="gif.gif"><br><img src="http://upload-images.jianshu.io/upload_images/5692364-dd1072566a35798c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="start.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-e2a41c6b1edea24b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="end.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>个人项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-native-update 热更新插件翻译</title>
    <link href="undefined2017/10/18/react-native-update%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%E7%BF%BB%E8%AF%91/"/>
    <url>2017/10/18/react-native-update%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>#原文地址：<a href="https://github.com/remobile/react-native-update" target="_blank" rel="noopener">https://github.com/remobile/react-native-update</a></p><h1 id="React-Native-更新-remobile"><a href="#React-Native-更新-remobile" class="headerlink" title="React Native 更新 (remobile)"></a>React Native 更新 (remobile)</h1><p>更新 js 版本和 app 版本</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="sh">npm install @remobile/react-native-update --save</code></pre><h3 id="安装-Android"><a href="#安装-Android" class="headerlink" title="安装 (Android)"></a>安装 (Android)</h3><pre><code class="gradle">...include &#39;:react-native-update&#39;project(&#39;:react-native-update&#39;).projectDir= new File(settingsDir, &#39;../node_modules/@remobile/react-native-update/android&#39;)</code></pre><ul><li>在 <code>android/app/build.gradle</code></li></ul><pre><code class="gradle">...dependencies {    ...    compile project(&#39;:react-native-update&#39;)}</code></pre><ul><li>注册模块 (在 MainActivity.java)</li></ul><pre><code class="java">......import com.remobile.update.RCTUpdateMgr;  // &lt;--- import......public class MainApplication extends Application implements ReactApplication {    private RCTUpdateMgr mUpdateMgr; // &lt;------ add here    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {        ......        @Override        protected String getJSBundleFile() {            return mUpdateMgr.getBundleUrl();   // &lt;------ change here        }        @Override        protected List&lt;ReactPackage&gt; getPackages() {            mUpdateMgr = new RCTUpdateMgr(MainActivity.activity);            return Arrays.&lt;ReactPackage&gt;asList(            ......            mUpdateMgr.getReactPackage(),       // &lt;------ add here            ......            );        }    };    ......}</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="UpdatePage-js"><a href="#UpdatePage-js" class="headerlink" title="UpdatePage.js"></a>UpdatePage.js</h4><p>#####定义全局变量</p><pre><code class="js">&#39;use strict&#39;;import React, { Component } from &#39;react&#39;;import {  View,  StyleSheet,  Platform,  Text,  Image,  TouchableHighlight} from &#39;react-native&#39;;import ReactNative form &#39;react-native&#39;import Update form &#39;@remobile/react-native-update&#39;varSTATUS_GET_VERSION = 0, // 获得版本号状态STATUS_HAS_VEW_VERSION = 1, // 有新版本状态STATUS_HAS_NOT_VEW_VERSION = 2, // 没有新版本号状态STATUS_DOWNLOAD_APK_PROGESS = 3, // 下载apk状态STATUS_DOWNLOAD_JS_PROGESS = 4, // 下载js状态STATUS_UNZIP_JS_PROGESS = 5, // 解压js状态STATUS_GET_VERSION_ERROR = 6, // 获得版本异常状态STATUS_DOWNKOAD_APK_ERROR = 7, // 下载apk异常状态STATUS_DOWNKOAD_JS_ERROR = 8, // 下载js异常状态STATUS_UNZIP_JS_ERROR = 9, // 解压js异常状态STATUS_FAILED_INSTALL_ERROR = 10,  //失败安装异常状态STATUS_UPDATE_END = 11; //更新结束状态varERROR_NULL = 0,ERROR_DOWNKOAD_APK = 1, // 异常下载apkERROR_DOWNKOAD_JS = 2, // 异常下载jsERROR_FAILED_INSTALL = 3, // 失败安装ERROR_UNZIP_JS = 4; // 解压jsvar PROGRESS_WIDTH = sr.tw*0.7;var {Button, ProgressBar} = COMPONENTS;</code></pre><p>#####进度 view</p><pre><code>var ProgressInfo = React.createClass({    render() {        const { progress } = this.props;        if (progress &lt; 1000) {            return (                &lt;View&gt;                    &lt;Text&gt;{this.props.title} [{progress}%]&lt;/Text&gt;                    &lt;ProgressBar                        fillStyle={{}}                        backgroundStyle={{backgroundColor: '#cccccc', borderRadius: 2}}                        style={{marginTop: 10, width:PROGRESS_WIDTH}}                        progress={progress/100.0}                        /&gt;                    &lt;View style={styles.progressText}&gt;                        &lt;Text&gt;0&lt;/Text&gt;                        &lt;Text&gt;100&lt;/Text&gt;                    &lt;/View&gt;                &lt;/View&gt;            );        } else {            let size = progress/1000/1024/1024;            return (                &lt;View style={{flex: 1, alignItems: 'center'}}&gt;                    &lt;Text&gt;{this.props.title} [{size.toFixed(2)} M]&lt;/Text&gt;                &lt;/View&gt;            );        }    }});</code></pre><p>#####页面显示 view ######函数</p><pre><code>module.exports = React.createClass({    getInitialState() {        const {options} = this.props;        return {            options,            status: !options ?            STATUS_GET_VERSION : options.newVersion ? STATUS_HAS_VEW_VERSION : STATUS_HAS_NOT_VEW_VERSION,            progress: 0,        };    },    componentWillMount() {        if (!this.state.options) {            Update.checkVersion({                versionUrl: app.route.ROUTE_VERSION_INFO_URL,                iosAppId: CONSTANTS.IOS_APPID,            }).then((options)=&gt;{                this.setState({options, status: !options ?                STATUS_GET_VERSION_ERROR : options.newVersion ?                STATUS_HAS_VEW_VERSION : STATUS_HAS_NOT_VEW_VERSION});            })        }    },    onError(errCode) {        if (errCode == ERROR_DOWNKOAD_APK) {            this.setState({status: STATUS_DOWNKOAD_APK_ERROR});        } else if (errCode == ERROR_DOWNKOAD_JS) {            this.setState({status: STATUS_DOWNKOAD_JS_ERROR});        } else if (errCode == ERROR_FAILED_INSTALL) {            this.setState({status: STATUS_FAILED_INSTALL_ERROR});        } else if (errCode == ERROR_UNZIP_JS) {            this.setState({status: STATUS_UNZIP_JS_ERROR});        }    },    doUpdate() {        const {jsVersionCode, trackViewUrl} = this.state.options;        if (jsVersionCode !== undefined) {            Update.updateJS({                jsVersionCode,                jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,                onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},                onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},                onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        } else {            Update.updateApp({                trackViewUrl,                androidApkUrl:app.route.ROUTE_APK_URL,                androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,                onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        }    },</code></pre><p>######页面的 render</p><pre><code>    render() {        var components = {};        const {          currentVersion,          newVersion,          description        } = this.state.options||{currentVersion:Update.getVersion()};        components[STATUS_GET_VERSION] = (            &lt;Text style={styles.textInfo}&gt;正在获取版本号&lt;/Text&gt;        );        components[STATUS_HAS_NOT_VEW_VERSION] = (            &lt;Text style={styles.textInfo}&gt;当前版本已经是最新版本&lt;/Text&gt;        );        components[STATUS_GET_VERSION_ERROR] = (            &lt;Text style={styles.textInfo}&gt;获取版本信息失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_DOWNKOAD_APK_ERROR] = (            &lt;Text style={styles.textInfo}&gt;下载apk文件失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_DOWNKOAD_JS_ERROR] = (            &lt;Text style={styles.textInfo}&gt;下载js bundle失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_UNZIP_JS_ERROR] = (            &lt;Text style={styles.textInfo}&gt;解压js bundle失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_FAILED_INSTALL_ERROR] = (            &lt;Text style={styles.textInfo}&gt;你放弃了安装&lt;/Text&gt;        );        components[STATUS_HAS_VEW_VERSION] = (            &lt;View style={styles.textInfoContainer}&gt;                &lt;Text style={styles.textInfo}&gt;发现新版本{newVersion}&lt;/Text&gt;                &lt;View style={styles.descriptionContainer}&gt;                    {                        description &amp;&amp; description.map((item, i)=&gt;{                            return (                                &lt;Text style={styles.textInfo}                                  key={i}&gt;{(i+1)+&#39;. &#39;+item}                                &lt;/Text&gt;                            )                        })                    }                &lt;/View&gt;                &lt;Button onPress={this.doUpdate}                    style={styles.button_layer}                    textStyle={styles.button_text}&gt;立即更新              &lt;/Button&gt;            &lt;/View&gt;        );        components[STATUS_DOWNLOAD_APK_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载APK&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_DOWNLOAD_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UNZIP_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在解压Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UPDATE_END] = (            &lt;Text&gt;正在重启...&lt;/Text&gt;        );        return (            ……        );    },});</code></pre><p>######样式</p><pre><code>var styles = StyleSheet.create({    ……});</code></pre><h4 id="UpdateInfoBox-js"><a href="#UpdateInfoBox-js" class="headerlink" title="UpdateInfoBox.js"></a>UpdateInfoBox.js</h4><p>#####全局变量</p><pre><code class="js">&#39;use strict&#39;;var React = require(&#39;react&#39;);var ReactNative = require(&#39;react-native&#39;);var { StyleSheet, View, Text, Image, TouchableOpacity } = ReactNative;var Update = require(&#39;@remobile/react-native-update&#39;);var STATUS_HAS_VEW_VERSION = 0,  STATUS_DOWNLOAD_APK_PROGESS = 1,  STATUS_DOWNLOAD_JS_PROGESS = 2,  STATUS_UNZIP_JS_PROGESS = 3,  STATUS_DOWNKOAD_APK_ERROR = 4,  STATUS_DOWNKOAD_JS_ERROR = 5,  STATUS_UNZIP_JS_ERROR = 6,  STATUS_FAILED_INSTALL_ERROR = 7,  STATUS_UPDATE_END = 8;var ERROR_NULL = 0,  ERROR_DOWNKOAD_APK = 1,  ERROR_DOWNKOAD_JS = 2,  ERROR_FAILED_INSTALL = 3,  ERROR_UNZIP_JS = 4;var PROGRESS_WIDTH = sr.tw * 0.7;var { Button, ProgressBar } = COMPONENTS;</code></pre><p>#####进度 view</p><pre><code>var ProgressInfo = React.createClass({    render() {        const { progress } = this.props;        if (progress &lt; 1000) {            return (                &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                    &lt;Text&gt;{this.props.title} [{progress}%]&lt;/Text&gt;                    &lt;ProgressBar                        fillStyle={{}}                        backgroundStyle={{backgroundColor: '#cccccc', borderRadius: 2}}                        style={{marginTop: 10, width:PROGRESS_WIDTH}}                        progress={progress/100.0}                        /&gt;                    &lt;View style={styles.progressText}&gt;                        &lt;Text&gt;0&lt;/Text&gt;                        &lt;Text&gt;100&lt;/Text&gt;                    &lt;/View&gt;                &lt;/View&gt;            );        } else {            let size = progress/1000/1024/1024;            return (                &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                    &lt;Text&gt;{this.props.title} [ {size.toFixed(2)} M ]&lt;/Text&gt;                &lt;/View&gt;            );        }    }});</code></pre><p>#####页面 view ######函数</p><pre><code>module.exports = React.createClass({    getInitialState() {        return {            status:STATUS_HAS_VEW_VERSION,            progress: 0,        };    },    onError(errCode) {        if (errCode == ERROR_DOWNKOAD_APK) {            this.setState({status: STATUS_DOWNKOAD_APK_ERROR});        } else if (errCode == ERROR_DOWNKOAD_JS) {            this.setState({status: STATUS_DOWNKOAD_JS_ERROR});        } else if (errCode == ERROR_FAILED_INSTALL) {            this.setState({status: STATUS_FAILED_INSTALL_ERROR});        } else if (errCode == ERROR_UNZIP_JS) {            this.setState({status: STATUS_UNZIP_JS_ERROR});        }    },    doUpdate() {        const {jsVersionCode, trackViewUrl} = this.props.options;        if (jsVersionCode !== undefined) {            Update.updateJS({                jsVersionCode,                jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,                onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},                onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},                onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        } else {            Update.updateApp({                trackViewUrl,                androidApkUrl:app.route.ROUTE_APK_URL,                androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,                onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        }    },</code></pre><p>######render</p><pre><code>    render() {        const components = {};        const {newVersion, description} = this.props.options;        components[STATUS_HAS_VEW_VERSION] = (            &lt;View style={styles.functionContainer}&gt;                &lt;Text style={styles.title}&gt;{`发现新版本(${newVersion})`}&lt;/Text&gt;                &lt;Text style={styles.redLine}&gt;                &lt;/Text&gt;                &lt;Text style={styles.content}&gt;                    {&quot;更新内容：&quot;}                &lt;/Text&gt;                {                    description.map((item, i)=&gt;{                        return (                            &lt;Text style={styles.contentItem} key={i}&gt;{&#39;- &#39;+item}&lt;/Text&gt;                        )                    })                }                &lt;View style={styles.buttonViewStyle}&gt;                    &lt;TouchableOpacity                        onPress={app.closeModal}                        style={styles.buttonStyleContainCannel}&gt;                        &lt;Text style={styles.buttonStyleCannel}&gt;以后再说&lt;/Text&gt;                    &lt;/TouchableOpacity&gt;                    &lt;TouchableOpacity                        onPress={this.doUpdate}                        style={styles.buttonStyleContain}&gt;                        &lt;Text style={styles.buttonStyle} &gt;立即更新&lt;/Text&gt;                    &lt;/TouchableOpacity&gt;                &lt;/View&gt;            &lt;/View&gt;        );        components[STATUS_DOWNKOAD_APK_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;下载apk文件失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_DOWNKOAD_JS_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;下载js bundle失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_UNZIP_JS_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;解压js bundle失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_FAILED_INSTALL_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;你放弃了安装&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_DOWNLOAD_APK_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载APK&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_DOWNLOAD_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UNZIP_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在解压Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UPDATE_END] = (            &lt;Text&gt;即将重启...&lt;/Text&gt;        );        return (            &lt;View style={styles.container}&gt;                {components[this.state.status]}            &lt;/View&gt;        );    },});</code></pre><p>######样式</p><pre><code>var styles = StyleSheet.create({   ……});</code></pre><h2 id="Update-的方法"><a href="#Update-的方法" class="headerlink" title="Update 的方法"></a>Update 的方法</h2><ul><li><code>Update.getVersion</code> - 获得当前版本<ul><li>返回值是 x.x.x</li></ul></li><li><code>Update.checkVersion</code> - 检查服务器版本</li><li><code>Update.updateApp</code> - 更新 apk 或 ios appstore</li><li><code>Update.updateJS</code> - 更新 js 捆绑文件</li></ul><h2 id="检查版本并且显示更新对话框"><a href="#检查版本并且显示更新对话框" class="headerlink" title="检查版本并且显示更新对话框"></a>检查版本并且显示更新对话框</h2><pre><code class="js">const Update = require(&#39;@remobile/react-native-update&#39;);const UpdateInfoBox = require(&#39;../modules/update/UpdateInfoBox&#39;);Update.checkVersion({  versionUrl: app.route.ROUTE_VERSION_INFO_URL,  iosAppId: CONSTANTS.IOS_APPID}).then(options =&gt; {  if (options &amp;&amp; options.newVersion) {    app.showModal(&lt;UpdateInfoBox options={options} /&gt;, {      backgroundColor: &#39;rgba(0, 0, 0, 0.6)&#39;    });  }});</code></pre><h2 id="检查版本和显示更新页面"><a href="#检查版本和显示更新页面" class="headerlink" title="检查版本和显示更新页面"></a>检查版本和显示更新页面</h2><pre><code class="js">const Update = require(&#39;@remobile/react-native-update&#39;);const UpdatePage = require(&#39;../modules/update/UpdatePage&#39;);Update.checkVersion({  versionUrl: app.route.ROUTE_VERSION_INFO_URL,  iosAppId: CONSTANTS.IOS_APPID}).then(options =&gt; {  app.navigator.push({    title: &#39;在线更新&#39;,    component: UpdatePage,    passProps: { options }  });});</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code>* versionUrl：服务器上的版本的url:    * format: { &quot;versionCode&quot;:1, &quot;versionName&quot;:&quot;1.0&quot;, &quot;jsVersionCode&quot;:2, &quot;description（描述）&quot;:&quot;hello&quot;}   这个结构体将传递给needUpdateApp和updateUpdateJS，如果你设置它们， 所以你可以自定义格式，但是versionCode和jsVersionCode必须保持一致</code></pre><pre><code>    * iosAppId:the appid on app Store## Update App Or JS```jsdoUpdate() {    const {jsVersionCode, trackViewUrl} = this.props.options;    if (jsVersionCode !== undefined) {        Update.updateJS({            jsVersionCode,            jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,            onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},            onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},            onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},            onError:(errCode)=&gt;{this.onError(errCode)},        });    } else {        Update.updateApp({            trackViewUrl,            androidApkUrl:app.route.ROUTE_APK_URL,            androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,            onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},            onError:(errCode)=&gt;{this.onError(errCode)},        });    }},</code></pre><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><pre><code>* jsbundleUrl:js捆绑网址    * 当只有js代码更改或图像资源更改，我希望您发布jsbundle，称为次要版本    * 包括www / index.android.bundle或www / index.ios.bundle    * 包括android上的图像目录，ios上的资源目录    * 在android上，image dir包含一些动态图像（这个版本添加的新图像）    * 发布小版本你应该修改jsVersionCode* androidApkUrl:apk的网址    * 只有native代码改变了，你需要在Android上发布apk或者在ios上发布ipa，叫做Marjor版本    * 发布Marjor版本，您应该增加versionCode并将jsVersionCode设置为0* androidApkDownloadDestPath：apk文件下载路径，例如/ sdcard / download，确保它存在* onDownloadAPKStart:function    * 当apk开始下载时回调* onDownloadAPKProgress:function    * 当apk正在下载时回调    * 将通过{total：xx，loaded：xx} 1参数* onDownloadAPKEnd:function    * 当apk下载结束时回调* onDownloadJSStart:function* onDownloadJSProgress:function    * 当apk正在下载时回调，    * 将通过{total：xx，loaded：xx} 1参数* onDownloadJSEnd:function* onUnzipJSStart:function* onUnzipJSProgress:function    * 解压时候回调,    * 将通过{total：xx，loaded：xx} 1参数* onUnzipJSEnd:function* onError:function    * 将通过errorCode    * var ERROR_NULL = 0,          ERROR_DOWNKOAD_APK = 1,          ERROR_DOWNKOAD_JS = 2,          ERROR_GET_VERSION = 3,          ERROR_UNZIP_JS = 4;</code></pre><h2 id="生成捆绑"><a href="#生成捆绑" class="headerlink" title="生成捆绑"></a>生成捆绑</h2><pre><code class="bash">#!/bin/bashdistpath=../../localServer/public/downloadfunction genIOSBundle() {    react-native bundle \        --platform ios \        --reset-cache \        --verbose \        --entry-file index.ios.js \        --bundle-output ./tools/www/index.ios.bundle \        --assets-dest ./tools/www/ \        --dev false}function genAndroidBundle() {    react-native bundle \        --platform android \        --reset-cache \        --verbose \        --entry-file index.android.js \        --bundle-output ./tools/www/index.android.bundle \        --assets-dest ./tools/www/ \        --dev false}function zipWWW() {    node -e &quot;!function(){function i(e,r){var o=n.readdirSync(e);o.forEach(function(o){var s=e+&#39;/&#39;+o;n.statSync(s).isDirectory()?i(s,r+&#39;/&#39;+o):c.folder(r).file(o,n.readFileSync(s))})}function e(e,r,o){r=r||&#39;&#39;,o=o||e+&#39;.zip&#39;,i(e,r);var s=c.generate({base64:!1,compression:&#39;DEFLATE&#39;});n.writeFile(o,s,&#39;binary&#39;,function(){console.log(&#39;success&#39;)})}var r=require(&#39;jszip&#39;),n=require(&#39;fs&#39;),c=new r,o=process.argv.splice(1);e.apply(null,o)}();&quot;  www _www www.zip}function genMd5List() {    cd ./tools    # git co head ${distpath}/${1}_md5.json    node -e &quot;var o=process.argv;require(&#39;./getMd5List&#39;)(o[1],o[2])&quot; ${1} ${distpath}}function zipFile() {    zipWWW    mv ./www.zip ${distpath}/js${1}.zip    rm -fr www    mv ./${1}_md5.json ${distpath}/${1}_md5.json    echo &quot;${distpath}&quot;}function buildAndroid() {    rm -fr www    mkdir www    cd ..    genAndroidBundle    genMd5List android    zipFile android}function buildIos() {    rm -fr www    mkdir www    cd ..    genIOSBundle    genMd5List ios    zipFile ios}function main() {    if [ &quot;$1&quot; = &quot;android&quot; ];then        buildAndroid    elif [ &quot;$1&quot; = &quot;ios&quot; ];then        buildIos    elif [ &quot;$1&quot; = &quot;all&quot; ];then        buildAndroid        buildIos    else        echo &quot;Usage: ./genbundle ios|android|all&quot;    fi}main $@</code></pre><ul><li>确保安装 jszip 在 npm 在全局(global)，我们使用它的 zip</li></ul><h3 id="服务器端-version-json"><a href="#服务器端-version-json" class="headerlink" title="服务器端 version.json"></a>服务器端 version.json</h3><pre><code class="json">{  &quot;iosPassed&quot;: true,  &quot;iosJsVersionCode&quot;: 0,  &quot;iosDescription&quot;: [&quot;修正bug&quot;, &quot;添加新功能&quot;],  &quot;androidPassed&quot;: {    &quot;baidu&quot;: false,    &quot;default&quot;: true  },  &quot;versionName&quot;: &quot;1.0&quot;,  &quot;versionCode&quot;: 1048576,  &quot;androidJsVersionCode&quot;: 0,  &quot;androidDescription&quot;: [&quot;修改bug&quot;, &quot;添加新功能&quot;]}</code></pre><h3 id="看详细使用"><a href="#看详细使用" class="headerlink" title="看详细使用"></a>看详细使用</h3><ul><li><a href="https://github.com/remobile/react-native-template" target="_blank" rel="noopener">https://github.com/remobile/react-native-template</a></li></ul><h4 id="工具在"><a href="#工具在" class="headerlink" title="工具在"></a>工具在</h4><p><a href="https://github.com/remobile/react-native-template/blob/master/project/tools" target="_blank" rel="noopener">useful tools</a></p><p>####例子在 react-native-template<br><a href="https://github.com/remobile/react-native-template/blob/master/project/App/modules/update" target="_blank" rel="noopener">Update</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一本漫画闯天涯</title>
    <link href="undefined2017/06/25/%E4%B8%80%E6%9C%AC%E6%BC%AB%E7%94%BB%E9%97%AF%E5%A4%A9%E6%B6%AF/"/>
    <url>2017/06/25/%E4%B8%80%E6%9C%AC%E6%BC%AB%E7%94%BB%E9%97%AF%E5%A4%A9%E6%B6%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>星仔本是酒吧一个小服务员，一次偶然的机会见到了黑社会火拼，黑老大给了他一张名片为以后的剧情铺垫。</p></blockquote><p>黑老大抓了一个对头的人严刑拷打，希望可以供出幕后主谋，威逼利诱下供出了自己的老大洪义，黑老大放他走。他走的时候遇见杀手，被杀。</p><p>黑老大约洪义谈判，洪义迟到。骂了一顿黑老大，黑老大手下不开心想干掉他，洪义从车里抓出一个人-黑老大的儿子，大摇大摆并且嘲笑了黑老大然后给黑老大儿子手臂开了一枪。黑老大非常生气。</p><p>星仔莫名其妙被洪义的人打了一顿，回到酒吧也被辞退了，回头一想去找黑老大，黑老大安排了一个工作给他。</p><p>星仔去到酒吧看到一个妹子在唱歌，很开心。进房后自我介绍后被叫买宵夜，很不开心，然后被阿俊（黑老大义子）叫出去聊天，两人交谈了一下。见到那个妹子被三个流氓欺负，星仔去救，失败，啊俊出场。三人结识。</p><p>星仔和洪义一起聚桑拿（坐隔壁），洪义让星仔拼命浇水，整个桑拿房无比闷热，星仔放了几个屁，洪义让其继续加水。星仔拿着浇水的盆咋想洪义的手下的头，星仔队友开枪打死洪义。</p><p>再次回到酒吧，星仔表演唱歌被笑，啊俊上……</p><p>三人到处玩耍，得知妹子的妹子叫安妮，安妮给她们两个人都送了一支笔，笔上分别有他们的字。埋下伏笔</p><p>黑老大派星仔和阿俊还有阿标（黑老大手下）去泰国跟全叔谈判要加量，全叔直接被拜猜的人干掉，三人被抓，阿俊和阿标被打得半死不活，星仔挺身而出救了他们自己做了人质，星仔和拜猜聊天，都很开心，（但如果阿俊他们不回来交易就会被杀），交易结束。</p><p>星仔回到香港抱怨没人来接，回到家里泡澡疑似有人闯进来，被盖住头立马跪下求饶，被阿俊和阿标嘲笑，然后星仔去阿标家里吃饭。</p><p>黑老大召集大家开了一个会议是关于继承人的事情，大家推举阿标坐他的位置，黑老大不爽，派人杀阿标。</p><p>阿标办了一个酒会庆祝他有儿子，结束后星仔扶阿标走，被阿标询问儿子应该叫什么，星仔取了一个名字给他“周润龙”，阿标不知道“润”怎么写，星仔用笔在阿标手上写了润字，笔遗漏在阿标车顶，阿标拒绝了星仔送回家，被黑老大杀手杀死。</p><p>另一个杀手准备杀星仔，被星仔逃跑，大家都怀疑是星仔杀阿标的，黑老大通缉星仔。</p><p>星仔打电话给阿俊，阿俊被跟踪。星仔跟阿俊谈判的时候杀手开了一枪，没有打死，星仔做诱饵，阿俊跑上山把杀手干掉。</p><p>阿俊跟人打斗的时候死了，星仔难过，跟安妮交代之后退隐。</p><p>黑老大跟儿子说：“现在你的绊脚石都杀了”，还讲了刘邦的故事，然后黑老大就被枪打死了，儿子说：我最大的绊脚石就是你</p><blockquote><p>全剧终。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春娇救志明3</title>
    <link href="undefined2017/06/22/%E6%98%A5%E5%A8%87%E6%95%91%E5%BF%97%E6%98%8E3/"/>
    <url>2017/06/22/%E6%98%A5%E5%A8%87%E6%95%91%E5%BF%97%E6%98%8E3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>春娇童年有一个关于“吃刚刚”的故事，这是她的心里阴影。</p></blockquote><p>志明喜欢买各种东西，常把男人必须有一个 xx 挂在嘴边。</p><p>志明去遛狗，一个误会让春娇首次怀疑志明，误会解除。</p><p>志明的干妈想跟他借种（纯借精），志明考虑很久拒绝，春娇开心，两人准备去台湾。</p><p>春娇的爸爸是很不责任喜欢逃避的人，跟志明混在一起，春娇害怕志明跟她爸一样。</p><p>志明见她爸，春娇问她爸女票：为什么是他，答：最危险时想起的人就是对的</p><p>春娇与志明去台湾，春娇故意没带套想要小孩，完事后疑似地震，志明抛弃春娇，春娇难过…跑路</p><p>春娇强行让自己体会危险，跑浴缸，拿朔料袋盖住头，无果。</p><p>两人经过极度挣扎，在春娇生日时，春娇唱歌，志明难过…</p><p>志明与春娇她爸和飞鹰演戏被拆穿，春娇说算了。</p><p>志明疯狂唱歌，表白：是你让我长大，是你拯救我，要不是你我还长不大变不了一个男人…以前我以为一个男人需要很多别的事证明，其实不用，只需要跟一个我喜欢的在乎的女人好好过日子就行。半跪求婚 ing</p><blockquote><p>带上戒指，完。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms 建立可以绑定属性的方法</title>
    <link href="undefined2017/06/19/XamarinForms%E5%BB%BA%E7%AB%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>2017/06/19/XamarinForms%E5%BB%BA%E7%AB%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文讲述如何实现控件的属性如何可以被 Binding</p><h1 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h1><pre><code>[RenderWith(typeof(_ActivityIndicatorRenderer))]    public class ActivityIndicator : View, IElementConfiguration&lt;ActivityIndicator&gt;    {        //这就是值类型绑定的实现        public static readonly BindableProperty IsRunningProperty = BindableProperty.Create        (&quot;IsRunning&quot;, typeof(bool), typeof(ActivityIndicator), default(bool));        public static readonly BindableProperty ColorProperty = BindableProperty.Create        (&quot;Color&quot;, typeof(Color), typeof(ActivityIndicator), Color.Default);        readonly Lazy&lt;PlatformConfigurationRegistry&lt;ActivityIndicator&gt;&gt; _platformConfigurationRegistry;        public ActivityIndicator()        {            _platformConfigurationRegistry = new Lazy&lt;PlatformConfigurationRegistry&lt;ActivityIndicator&gt;&gt;(() =&gt; new PlatformConfigurationRegistry&lt;ActivityIndicator&gt;(this));        }        public Color Color        {            get { return (Color)GetValue(ColorProperty); }            set { SetValue(ColorProperty, value); }        }        //与之对对应的属性        public bool IsRunning        {            get { return (bool)GetValue(IsRunningProperty); }            set { SetValue(IsRunningProperty, value); }        }        public IPlatformElementConfiguration&lt;T, ActivityIndicator&gt; On&lt;T&gt;() where T : IConfigPlatform        {            return _platformConfigurationRegistry.Value.On&lt;T&gt;();        }    }</code></pre><blockquote><p>Ps：这个官方例子是有问题的。</p></blockquote><h2 id="下面讲一下如何绑定事件，其实-Xamarin-Forms-绑定事件用的是-Command，方法也不难。"><a href="#下面讲一下如何绑定事件，其实-Xamarin-Forms-绑定事件用的是-Command，方法也不难。" class="headerlink" title="下面讲一下如何绑定事件，其实 Xamarin Forms 绑定事件用的是 Command，方法也不难。"></a>下面讲一下如何绑定事件，其实 Xamarin Forms 绑定事件用的是 Command，方法也不难。</h2><pre><code>public class MyEntry:Entry{    public ICommand MyCommand    {        get =&gt; (ICommand )GetValue(MyCommandProperty);        set =&gt; SetValue(MyCommandProperty, value);    }    /// &lt;summary&gt;    /// MyCommandProperty的Mvvm实现    /// &lt;/summary&gt;    public static readonly BindableProperty MyCommandProperty = Create    (        nameof(回调方法),        typeof(ICommand),        typeof(MyEntry)    ); //注意这里变量名的命名规则是MyCommand + Property，前者随便，后者固定语法    private void 回调方法()    {        MyCommand?.Execute(null);    }}//这样这个MyEntry的MyCommand就可以被Mvvm绑定了。</code></pre><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><pre><code>&lt;MyEntry MyCommand={ Binding ThisCommand &gt;&lt;/MyEntry&gt;</code></pre><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><pre><code>public class Model:某个mvvm框架的BasePage{    public Command ThisCommand    {        get        {            retrun new Command(()=&gt;            {                //做点什么            });        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻译Rolling your own Mvvm for Xamarin.Forms</title>
    <link href="undefined2017/06/09/%E7%BF%BB%E8%AF%91Rolling-your-own-Mvvm-for-Xamarin.Forms/"/>
    <url>2017/06/09/%E7%BF%BB%E8%AF%91Rolling-your-own-Mvvm-for-Xamarin.Forms/</url>
    
    <content type="html"><![CDATA[<p>#原文地址：<a href="http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/" target="_blank" rel="noopener">http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/</a></p><p>#实现自己的 Mvvm for Xamarin.Forms<br>更新：我已经采取了这个位置的最好的部分，并放入一个框架，这是一个超简单的 Mvvm 框架的 Xamarin.Forms，它放在了 github 和 nuget。<br>在这个博客中，我给出了一个如何在 Xamarin.Forms 中实现自己的 Mvvm 的例子。 这个 Mvvm 是基于约定的，在这种情况下，我使用了 Page / PageModel 命名，而不是 Model / ViewModel 命名，但是如果你喜欢，你可以将其改为 View / ViewModel。 这个博客写的内容基于 github 上可用的示例应用程序。</p><p>##本例中的约定。</p><ul><li>页面必须有一个相应的 PageModel，命名重要，所以 QuotePageModel 必须有一个 QuotePage</li><li>一个页面可以有一个没有参数的 Init 方法</li><li>页面可以有一个 PageModel 属性，它是视图模型</li><li>页面上的 BindingContext 将自动设置为 Model</li><li>一个模型可以有一个接收一个对象的 Init 方法</li><li>一个模型可以具有一个 ReverseInit 方法，它也可以使用一个对象，当一个模型被放在一个对象上时被调用</li></ul><p>###让我们看一个页面</p><pre><code>public class QuotePage : ContentPage{    //按下时自动弹出    public QuotePageModel PageModel { get; set; }    public QuotePage ()    {    }    //出现时自动执行    public void Init()    {        Title = &quot;Quote&quot;;    }}</code></pre><p>###和相应的 PageModel</p><pre><code>public class QuotePageModel : BasePageModel{    IDatabaseService _databaseService;    public Quote Quote { get; set; }    //数据库服务自动注入。    public QuotePageModel (IDatabaseService databaseService)    {        _databaseService = databaseService;    }    //当Model出现的时候执行    public void Init(object data)    {        Quote = data as Quote;        if (Quote == null)            Quote = new Quote ();    }    public Command Done    {        get {            return new Command (() =&gt; {                //This pops the current Page                PopPageModel();            });        }    }}</code></pre><p>##Navigating Models<br>您可以使用 PushPageModel 方法和 PopPageModel 方法从视图模型中推送和弹出页面。</p><p>例如。<code>PushPageModel&lt;QuotePageModel&gt;（quote）;</code></p><p>但在您可以做到这一点之前，您需要实现和注册一个 IRootNavigation 服务。 在我的情况下，我使用了一个 ContainerPage 并将其注册为 NavigationHandler</p><p>//注册根导航</p><pre><code>var containerPage = new RootContainerPage（）;TinyIoC.TinyIoCContainer.Current.Register &lt;IRootNavigation&gt;（containerPage）;</code></pre><pre><code>public class RootContainerPage : MasterDetailPage, IRootNavigation{    ContentPage _menuPage;    NavigationPage _contactNavPage, _quotesNavPage;    public RootContainerPage ()    {        _contactNavPage = new NavigationPage (BasePageModel.ResolvePageModel&lt;ContactsRootPageModel&gt; (null));        _quotesNavPage = new NavigationPage (BasePageModel.ResolvePageModel&lt;QuotesRootPageModel&gt; (null));        Detail = _contactNavPage;        _menuPage = new ContentPage ();        _menuPage.Title = &quot;Menu&quot;;        var listView = new ListView();        listView.ItemsSource = new string[] { &quot;Contacts&quot;, &quot;Quotes&quot; };        listView.ItemSelected += (sender, args) =&gt;        {            if ((string)args.SelectedItem == &quot;Contacts&quot;)                Detail = _contactNavPage;            if ((string)args.SelectedItem == &quot;Quotes&quot;)                Detail = _quotesNavPage;            IsPresented = false;        };        _menuPage.Content = listView;        Master = new NavigationPage(_menuPage) { Title = &quot;Menu&quot; };    }    public void PushPage (Page page, BasePageModel model)    {        ((NavigationPage)Detail).PushAsync (page);    }    public void PopPage ()    {        ((NavigationPage)Detail).PopAsync ();    }}</code></pre><p>##Implementing Property Changed<br>你会注意到我不需要实现属性更改事件，而是使用一个名为<a href="https://github.com/Fody/PropertyChanged" target="_blank" rel="noopener">Fody / PropertyChanged</a>的开源项目实现。 您可以从 nuget 安装。</p><p>##控制反转/ TinyIOC<br>ViewPage 构造函数的依赖将自动注入。 使用 TinyIOC 注册依赖项。</p><p>//注册数据库服务<br><code>TinyIoC.TinyIoCContainer.Current.Register &lt;IDatabaseService，DatabaseService&gt;();</code></p><p>##神奇的地方在哪里？<br>如果你想知道神奇的实现在哪里发生，那么看看<a href="https://github.com/rid00z/XamarinFormsQuoteApp/blob/master/XamarinFormsQuoteApp/PageModels/BasePageModel.cs" target="_blank" rel="noopener">示例应用程序中的 BasePageModel.cs。</a></p><p>##平台依赖关系<br>此应用程序利用 SQLite 的平台依赖关系。</p><p>##单元测试<br>如果我们遵循惯例，那么模型是松耦合的，容易测试。</p><p>您可以将模拟的依赖关系传递给模型并进行测试。 在这里看到一个例子：</p><pre><code>[TestFixture]public class ContactPageModelTests{    [Test]    public static void CreateNewContact()    {        var container = A.Fake&lt;IRootNavigation&gt; ();        TinyIoC.TinyIoCContainer.Current.Register&lt;IRootNavigation&gt; (container);        var db = new DatabaseService (new SQLiteFactory());        var vm = new ContactPageModel (db);        vm.Init (null);        //保存到数据库        vm.Contact.Name = &quot;Peter&quot;;        vm.Contact.Phone = &quot;9087&quot;;        vm.Done.Execute (null);        Assert.IsTrue (vm.Contact.ContactId &gt; 0);        //从数据库取出        var savedContact                = db.Conn.Table&lt;Contact&gt; ().Where ((c) =&gt; c.ContactId == vm.Contact.ContactId).FirstOrDefault ();        Assert.AreEqual (&quot;Peter&quot;, savedContact.Name);        Assert.AreEqual (&quot;9087&quot;, savedContact.Phone);        A.CallTo (() =&gt; container.PopPage ()).MustHaveHappened ();    }}</code></pre><p>请去看看 github 上的代码。</p><p><a href="https://github.com/rid00z/XamarinFormsQuoteApp" target="_blank" rel="noopener">https://github.com/rid00z/XamarinFormsQuoteApp</a></p><p>Thanks</p><p>Michael</p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Glimpse the Future of Xamarin Forms 3.0 翻译</title>
    <link href="undefined2017/06/09/Glimpse-the-Future-of-XamarinForms-3.0-%E7%BF%BB%E8%AF%91/"/>
    <url>2017/06/09/Glimpse-the-Future-of-XamarinForms-3.0-%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>#原文地址：<a href="https://blog.xamarin.com/glimpse-future-xamarin-forms-3-0/" target="_blank" rel="noopener">https://blog.xamarin.com/glimpse-future-xamarin-forms-3-0/</a></p><p>#Xamarin Forms 3.0<br>在 Microsoft Build 2017 中，我们分享了对 Xamarin.Forms 3.0 的愿景：在更多的平台上可以使用 Xamarin.Forms，并且以前更快。 今天，我想介绍一些令人兴奋的新功能，我们将添加到 Xamarin.Forms，我们知道你会爱上这个功能的！</p><p>##Xamarin.Forms 嵌入<br>您一直能够从 Xamarin.Forms 调用本机 API，但是现在我们允许您使用大多数本机应用程序的 Xamarin.Forms。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-16ea9eebb29ddb67.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="embedding-uwp-desktop.gif"></p><p>无论您是将 xamarin.Forms 全部进入，还是只想将其用于您最常使用的本机应用程序，我们将启用所有路径; 我们称之为 Xamarin.Forms 嵌入。 在 XAML 或 C＃中使用任何 ContentPage，并将其直接嵌入到 Xamarin.iOS，Xamarin.Android 或 UWP 应用程序中。</p><p>所有现有的 Xamarin.Forms UI 现在已经在 Xamarin.Forms 应用程序之外扩展了使用。</p><p>这是它的外观。 在非 Xamarin.Forms 应用程序中，使用该平台的预期参数初始化 Forms 并使用方便的方法就可以创建 ContentPage 的本机对象。 就这样，你的手指就掌握了原生的控制！</p><pre><code>// AndroidForms.Init(this, null);var androidFragment = new MyFormsPage().CreateFragment(this);// iOSForms.Init()var iosViewController = new MyFormsPage().CreateViewController();// UWPForms.Init(e);var uwpElement = new MyFormsPage().CreateFrameworkElement();</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/5692364-52aa87d296279e34.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="2017-05-15_13-57-14.gif"></p><p>Xamarin.Forms 的功能，如 DependencyService，MessagingCenter 和数据绑定系统，在这种情况下都可以使用。</p><p>##兼容更多平台</p><p>Xamarin.Forms 正在走向更多的平台！ 准备在 MacOS 使用 WPF，Linux 以及更多的 Windows 应用程序上运行。 今天我们已经开始使用 macOS，但是我们并没有停在那里，我们可以让您定位每个桌面平台！ 我们的团队正在为 GTK＃和 WPF 开发。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-c1b23c21387016cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>##性能提升和增强<br>我们将 Xamarin.Forms 放在显微镜下，以确定使您的应用加载速度更快，运行更快的关键目标，具体为：</p><ul><li>控制渲染器：我们继续我们适当称之为快速渲染器的工作。 这些重构的渲染器避免创建多余的中间对象和实现更好的性能。</li><li>布局压缩：启用时，我们会在编译时优化布局，以提高渲染速度并最大限度地减少内存使用。</li><li>绑定系统：我们正在引入一次绑定模式。</li><li>灵活性：流行的 Web 布局系统来到 Xamarin.Forms。 我们正在引入一个 FlexLayout 系统来构建自适应布局并实现一个 Visual State Manager。</li><li>Styling：我们正在抛光经常需要的 CSS 样式实现。 你可以像今天一样继续为您的应用程序设计样式，如果您是 CSS 的粉丝，那就太好了。</li></ul><p>##介绍 XAML 标准<br>正如 Microsoft Build 2017 所宣布的，我们正在与 XAML Standard 的 Windows 部门进行合作，这是 XAML 作为资产共享的一种方式。 Xamarin.Forms 将完全支持 XAML 标准，并带您到需要启动的每个平台。</p><p>支持 XAML Standard 的框架将能够共享基于 XAML 的常见 UI 定义。 我们的目标是在今年晚些时候推出第一个版本 XAML Standard 1.0。</p><p>##尝试今天加入交流<br>今天可以在这里开始我们为 Xamarin.Forms 3.0 Cooking 的所有好东西。</p><p>##下载 Xamarin.Forms 3.0 预览<br>我们已经将 Xamarin.Forms 的预览内容发布到新的 Feed，并共享了我们的演示代码。 得到它：</p><ul><li>向 NuGet Manager 添加新的源代码：https：//<a href="http://www.myget.org/F/xamarinforms-dev/api/v3/index.json" target="_blank" rel="noopener">www.myget.org/F/xamarinforms-dev/api/v3/index.json</a></li><li>检查预发行</li><li>选择并安装功能名称为“Embedding”的软件包。3.0.0.100-embeddingpreview</li><li>在 GitHub 上下载 Weather 演示应用程序代码。<a href="https://github.com/davidortinau/build2017-new-in-xamarin-forms" target="_blank" rel="noopener">https://github.com/davidortinau/build2017-new-in-xamarin-forms</a></li><li>准备好后，请浏览完整的 Xamarin.Forms 路线图，并加入 GitHub 上的 XAML Standard 对话。</li></ul><p>###准备好后，请浏览完整的 Xamarin.Forms 路线图，并加入 GitHub 上的 XAML Standard 交流。</p><ul><li><a href="https://aka.ms/xfroadmap" target="_blank" rel="noopener">Xamarin.Forms Roadmap</a>，并向我们提供有关这些公告的反馈。</li><li>在<a href="https://aka.ms/xamlstandard" target="_blank" rel="noopener">aka.ms/xamlstandard</a>.中加入 XAML 标准对话。</li><li>在<a href="https://blog.xamarin.com/preview-bringing-macos-to-xamarin-forms/" target="_blank" rel="noopener">blog.xamarin.com/preview-bringing-macos-to-xamarin-forms/</a>.上预览 XAMarin.Forms for macOS。</li></ul><p>####在 channel9.msdn.com/events/Build/2017/B8099 上观看我们完整的 Microsoft Build 2017 Xamarin.Forms 会话。</p><p><a href="https://sec.ch9.ms/ch9/e613/96a58de3-75e5-4d9e-9b15-e216a03fe613/B8099_high.mp4" target="_blank" rel="noopener">观看连接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms MvvM框架之FreshMvvM翻译一</title>
    <link href="undefined2017/06/09/XamarinForms-MvvM%E6%A1%86%E6%9E%B6%E4%B9%8BFreshMvvM%E7%BF%BB%E8%AF%91%E4%B8%80/"/>
    <url>2017/06/09/XamarinForms-MvvM%E6%A1%86%E6%9E%B6%E4%B9%8BFreshMvvM%E7%BF%BB%E8%AF%91%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="原文地址：https-github-com-rid00z-FreshMvvm"><a href="#原文地址：https-github-com-rid00z-FreshMvvm" class="headerlink" title="原文地址：https://github.com/rid00z/FreshMvvm"></a>原文地址：<a href="https://github.com/rid00z/FreshMvvm" target="_blank" rel="noopener">https://github.com/rid00z/FreshMvvm</a></h1><h1 id="FreshMvvm-for-Xamarin-Forms"><a href="#FreshMvvm-for-Xamarin-Forms" class="headerlink" title="FreshMvvm for Xamarin.Forms"></a>FreshMvvm for Xamarin.Forms</h1><p>FreshMvvm 是专门为 Xamarin.Forms 设计的轻量 Mvvm 框架。 它是简单和灵活的。</p><h1 id="与其他的选择相比怎么样？"><a href="#与其他的选择相比怎么样？" class="headerlink" title="与其他的选择相比怎么样？"></a>与其他的选择相比怎么样？</h1><ul><li>轻量，超简单</li><li>它专为 Xamarin.Forms 设计</li><li>设计易于学习和开发（当你还没有准备好 RxUI 时它是很好的）</li><li>使用比配置更好的设定。</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>PageModel 到 PageModel 导航</li><li>BindingContext 的自动构造</li><li>页面事件的自动构造（例如页面出现）</li><li>PageModel 上的基本方法（允许传值）（init，reverseinit）</li><li>内置 IOC 容器（依赖注入）</li><li>PageModel 构造函数注入</li><li>Basic 中提供的基本方法，如弹消息框</li><li>内置导航类型为 SimpleNavigation，Tabbed 和 MasterDetail</li></ul><h1 id="它的故事"><a href="#它的故事" class="headerlink" title="它的故事"></a>它的故事</h1><p>当 Xamarin.Forms 发布时，我（Michael Ridland）是 Xamarin 传统应用程序的一部分。 我想将项目移到 Xamarin.Forms 上，但是在该项目中我使用的是 MvvMCross。 当时 MvvmCross 不支持 Xamarin.Forms，所以我有几个选择</p><ul><li>（1）适应 MvvmCross</li><li>（2）找到一个替代的框架</li><li>（3）实现我自己的 MvvM。</li></ul><p>关于 MvvmCross 的最好的部分是它是双向数据绑定到原生的 iOS / Android 控件，但由于 Xamarin.Forms 已经拥有 Databinding 内置，这是没有用的，MvvMCross 太大了，我不需要这么大。<br>我也无法找到一个可以轻松移动的替代方案。所以我做了属于我自己简单并且灵活 MvvM 框架。</p><p><a href="http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/" target="_blank" rel="noopener">它是从这个帖子开始的</a>——<a href="2017/06/09/翻译Rolling-your-own-Mvvm-for-Xamarin.Forms/">翻译在这</a>，为 Xamarin.Forms 实现自己的 Mvvm。 我尽量为自己的 MvvM 框架做得简单。</p><p>从来没有想过来写一个框架，但在几次发布 Mvvm 解决方案之后，我发现很多人都想要它，并且似乎对此感兴趣。 另外考虑到我从 Xamarin.Forms 开始就在我所有的项目中使用了这个框架，我知道它的工作原理，所以我创建了 FreshMvvm，于是它诞生了。</p><h1 id="共同遵守的设定"><a href="#共同遵守的设定" class="headerlink" title="共同遵守的设定"></a>共同遵守的设定</h1><ul><li>一个页面必须有一个相应的 PageModel，类的命名十分重要，所以 QuotePageModel 必须有一个 QuotePage 页面。QuotePage 上的 BindingContext 将被自动设置为 Model</li><li>一个 PageModel 可以拥有一个接收一个对象的 Init 方法</li><li>一个 PageModel 可以有一个 ReverseInit 方法，它也可以使用一个对象，当一个模型被一个对象引用时被调用</li><li>PageModel 可以将依赖关系自动注入到构造函数中</li></ul><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p>FreshMvvm 中的主要导航形式是 PageModel 到 PageModel，这实际上意味着我们的观点不了解导航。</p><ul><li>所以要在 PageModels 之间导航使用：</li></ul><pre><code>await CoreMethods.PushPageModel&lt;QuotePageModel&gt;(); // 推送导航堆栈await CoreMethods.PushPageModel&lt;QuotePageModel&gt;(null, true); // 推送模态</code></pre><ul><li>FreshMvvm 中的导航引擎是通过一个简单的界面完成的，其中包含了 Push 和 Pop 的方法。 基本上这些方法可以以任何他们喜欢的方式控制应用程序的导航。</li></ul><pre><code>public interface IFreshNavigationService{Task PushPage(Page page, FreshBasePageModel model, bool modal = false);Task PopPage(bool modal = false);}</code></pre><ul><li>在 PushPage 和 PopPage 中，您可以执行任何您喜欢的导航，这可以从简单的导航到高级嵌套导航。</li></ul><p>##该框架包含一些内置的导航容器，用于不同类型的导航。</p><ul><li>###基本导航 - 内置</li></ul><pre><code>var page = FreshPageModelResolver.ResolvePageModel&lt;MainMenuPageModel&gt; ();var basicNavContainer = new FreshNavigationContainer (page);MainPage = basicNavContainer;</code></pre><ul><li>###主要细节 - 内置</li></ul><pre><code>var masterDetailNav = new FreshMasterDetailNavigationContainer ();masterDetailNav.Init (&quot;Menu&quot;);masterDetailNav.AddPage&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);masterDetailNav.AddPage&lt;QuoteListPageModel&gt; (&quot;Pages&quot;, null);MainPage = masterDetailNav;</code></pre><ul><li>###标签导航 - 内置</li></ul><pre><code>var tabbedNavigation = new FreshTabbedNavigationContainer ();tabbedNavigation.AddTab&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);tabbedNavigation.AddTab&lt;QuoteListPageModel&gt; (&quot;Pages&quot;, null);MainPage = tabbedNavigation;</code></pre><ul><li>###实施自定义导航</li></ul><p>可以通过实现 IFreshNavigationService.来设置任何类型的导航。在示例应用程序中有一个示例，名为 CustomImplementedNav.cs。</p><h2 id="示例应用程序"><a href="#示例应用程序" class="headerlink" title="示例应用程序"></a>示例应用程序</h2><ul><li>基本导航例子</li><li>标签式导航例子</li><li>MasterDetail 导航例子</li><li>使用 MasterDetail Popover 示例的 Tabbed 导航（这在 Sample App 中被称为 CustomImplementedNav）</li></ul><p>##控制反转（IOC）<br>所以你不需要使用你自己的 IOC 容器，FreshMvvm 自带了一个内置的 IOC 容器，它使用的是 TinyIOC，但使用不同的命名来避免冲突。要在容器中注册服务注册：</p><pre><code>FreshIOC.Container.Register&lt;IDatabaseService, DatabaseService&gt;();</code></pre><p>注入时使用：</p><pre><code>FreshIOC.Container.Resolve&lt;IDatabaseService&gt;();</code></pre><p>这也是驱动构建器注入的方式。</p><p>我们现在流畅支持 API 来设置对象在 IOC 容器内的生命周期。</p><pre><code>// 默认情况下，我们将具体类型注册为多例，并将接口注册为单例FreshIOC.Container.Register&lt;MyConcreteType&gt;(); // 多例FreshIOC.Container.Register&lt;IMyInterface, MyConcreteType&gt;(); // 单例// Fluent API允许我们改变这种行为FreshIOC.Container.Register&lt;MyConcreteType&gt;().AsSingleton(); // 单例FreshIOC.Container.Register&lt;IMyInterface, MyConcreteType&gt;().AsMultiInstance(); // 多例</code></pre><p>如下所示，IFreshIOC 接口方法返回 IRegisterOptions 接口。</p><pre><code>public interface IFreshIOC{    object Resolve(Type resolveType);    IRegisterOptions Register&lt;RegisterType&gt;(RegisterType instance) where RegisterType : class;    IRegisterOptions Register&lt;RegisterType&gt;(RegisterType instance, string name) where RegisterType : class;    ResolveType Resolve&lt;ResolveType&gt;() where ResolveType : class;    ResolveType Resolve&lt;ResolveType&gt;(string name) where ResolveType : class;    IRegisterOptions Register&lt;RegisterType, RegisterImplementation&gt; ()  where RegisterType : class  where RegisterImplementation : class, RegisterType;}</code></pre><p>从 register 方法返回的接口是 IRegisterOptions。</p><pre><code>public interface IRegisterOptions{    IRegisterOptions AsSingleton();    IRegisterOptions AsMultiInstance();    IRegisterOptions WithWeakReference();    IRegisterOptions WithStrongReference();    IRegisterOptions UsingConstructor&lt;RegisterType&gt;(Expression&lt;Func&lt;RegisterType&gt;&gt; constructor);}</code></pre><h2 id="PageModel-构造函数注入"><a href="#PageModel-构造函数注入" class="headerlink" title="PageModel - 构造函数注入"></a>PageModel - 构造函数注入</h2><p>当 PageModels 被推送到 IOC 容器中的 services 可以被推入构造函数。</p><pre><code>FreshIOC.Container.Register&lt;IDatabaseService, DatabaseService&gt;();</code></pre><h2 id="PageModel-重要方法"><a href="#PageModel-重要方法" class="headerlink" title="PageModel 重要方法"></a>PageModel 重要方法</h2><pre><code>/// &lt;summary&gt;/// 以前的页面模型，这是自动推送填充/// &lt;/summary&gt;public FreshBasePageModel PreviousPageModel { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 对当前页面的引用，即自动推送填充/// &lt;/summary&gt;public Page CurrentPage { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 核心方法是应用程序的基本内置方法，包括推送，弹出和弹消息框/// &lt;/summary&gt;public IPageModelCoreMethods CoreMethods { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 当一个页面调用Pop&#39;d这个方法时，它也允许返回数据。/// &lt;/summary&gt;/// &lt;param name=&quot;returndData&quot;&gt;从...返回的数据 &lt;/param&gt;public virtual void ReverseInit(object returndData) { }</code></pre><pre><code>/// &lt;summary&gt;/// 在加载PageModel时调用此方法，initData是之前从pagemodel发送来的数据/// &lt;/summary&gt;/// &lt;param name=&quot;initData&quot;&gt;从推送器发送到此PageModel的数据&lt;/param&gt;public virtual void Init(object initData) { }</code></pre><pre><code>/// &lt;summary&gt;/// View消失时调用此方法。/// &lt;/summary&gt;protected virtual void ViewIsDisappearing (object sender, EventArgs e){}</code></pre><pre><code>/// &lt;summary&gt;/// View出现时调用此方法/// &lt;/summary&gt;protected virtual void ViewIsAppearing (object sender, EventArgs e){}</code></pre><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>每个 PageModel 都有一个名为“CoreMethods”的属性，当一个 PageModel 被推送时，它被自动填充，它是大多数应用程序需要的基本功能，如弹消息框，推送，弹出等。</p><pre><code>public interface IPageModelCoreMethods{    Task DisplayAlert (string title, string message, string cancel);    Task&lt;string&gt; DisplayActionSheet (string title, string cancel, string destruction, params string[] buttons);    Task&lt;bool&gt; DisplayAlert (string title, string message, string accept, string cancel);    Task PushPageModel&lt;T&gt;(object data, bool modal = false) where T : FreshBasePageModel;    Task PopPageModel(bool modal = false);    Task PopPageModel(object data, bool modal = false);    Task PushPageModel&lt;T&gt;() where T : FreshBasePageModel;}</code></pre><h2 id="Page-的重要方法"><a href="#Page-的重要方法" class="headerlink" title="Page 的重要方法"></a>Page 的重要方法</h2><p>PageModel Init PropertyChanged</p><p>###示例 PageModel</p><pre><code>[ImplementPropertyChanged] // 使用Fody for Property更改通知public class QuoteListPageModel : FreshBasePageModel{    IDatabaseService _databaseService;    //这些通过构造函数注入IOC    public QuoteListPageModel (IDatabaseService databaseService)    {        _databaseService = databaseService;    }    public ObservableCollection&lt;Quote&gt; Quotes { get; set; }    public override void Init (object initData)    {        Quotes = new ObservableCollection&lt;Quote&gt; (_databaseService.GetQuotes ());    }    //框架支持标准View出现和消失事件    protected override void ViewIsAppearing (object sender, System.EventArgs e)    {        CoreMethods.DisplayAlert (&quot;Page is appearing&quot;, &quot;&quot;, &quot;Ok&quot;);        base.ViewIsAppearing (sender, e);    }    protected override void ViewIsDisappearing (object sender, System.EventArgs e)    {        base.ViewIsDisappearing (sender, e);    }    //跳转到另一个页面后，如果返回此页面调用    public override void ReverseInit (object value)    {        var newContact = value as Quote;        if (!Quotes.Contains (newContact))        {            Quotes.Add (newContact);        }    }    public Command AddQuote    {        get        {            return new Command (async () =&gt;            {                //Push A Page Model                await CoreMethods.PushPageModel&lt;QuotePageModel&gt; ();            });        }    }    Quote _selectedQuote;    public Quote SelectedQuote    {        get        {            return _selectedQuote;        }        set        {            _selectedQuote = value;            if (value != null)                QuoteSelected.Execute (value);        }    }    public Command&lt;Quote&gt; QuoteSelected    {        get        {            return new Command&lt;Quote&gt; (async (quote) =&gt;            {                await CoreMethods.PushPageModel&lt;QuotePageModel&gt; (quote);            });        }    }}</code></pre><h2 id="多个导航服务"><a href="#多个导航服务" class="headerlink" title="多个导航服务"></a>多个导航服务</h2><p>在 FreshMvvm 中可以进行任何类型的导航，通过实现自定义导航服务来完成自定义或高级场景。即使有这种能力，发现在 FreshMvvm 中做高级导航方案有点困难。在我回顾了 FreshMvvm 的所有支持问题之后，我发现人们的基本问题是他们希望能够多次使用我们内置的导航容器，其中两个主要例子是</p><ul><li>（1）具有导航堆栈的主要细节：在一个 master 和另一个 master 的细节</li><li>（2）使用新的推动导航容器模型的能力。</li></ul><p>为了支持这两种情况，我得出结论，FreshMvvm 需要具有命名 NavigationServices 的能力，以便我们可以支持多个 NavigationService。</p><p>##使用多个导航容器<br>在下面我们运行一个单一的主细节的两个导航堆栈。</p><pre><code>var masterDetailsMultiple = new MasterDetailPage (); //generic master detail page//我们使用ContactList设置第一个导航容器var contactListPage = FreshPageModelResolver.ResolvePageModel&lt;ContactListPageModel&gt; ();contactListPage.Title = &quot;Contact List&quot;;//我们设置名为MasterPageArea的第一个导航容器var masterPageArea = new FreshNavigationContainer (contactListPage, &quot;MasterPageArea&quot;);masterPageArea.Title = &quot;Menu&quot;;masterDetailsMultiple.Master = masterPageArea; //将第一个导航容器设置为Master//我们使用QuoteList设置第二个导航容器var quoteListPage = FreshPageModelResolver.ResolvePageModel&lt;QuoteListPageModel&gt; ();quoteListPage.Title = &quot;Quote List&quot;;//我们设置名为DetailPageArea的第二个导航容器var detailPageArea = new FreshNavigationContainer (quoteListPage, &quot;DetailPageArea&quot;);masterDetailsMultiple.Detail = detailPageArea; //将第二个导航容器设置为“Detail”MainPage = masterDetailsMultiple;</code></pre><h2 id="在新的导航堆栈使用-PushModally"><a href="#在新的导航堆栈使用-PushModally" class="headerlink" title="在新的导航堆栈使用 PushModally"></a>在新的导航堆栈使用 PushModally</h2><pre><code>//push a basic page Modallyvar page = FreshPageModelResolver.ResolvePageModel&lt;MainMenuPageModel&gt; ();var basicNavContainer = new FreshNavigationContainer (page, &quot;secondNavPage&quot;);await CoreMethods.PushNewNavigationServiceModal(basicNavContainer, new FreshBasePageModel[] { page.GetModel() });//推送标签页模型var tabbedNavigation = new FreshTabbedNavigationContainer (&quot;secondNavPage&quot;);tabbedNavigation.AddTab&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, &quot;contacts.png&quot;, null);tabbedNavigation.AddTab&lt;QuoteListPageModel&gt; (&quot;Quotes&quot;, &quot;document.png&quot;, null);await CoreMethods.PushNewNavigationServiceModal(tabbedNavigation);//推送主细节页面var masterDetailNav = new FreshMasterDetailNavigationContainer (&quot;secondNavPage&quot;);masterDetailNav.Init (&quot;Menu&quot;, &quot;Menu.png&quot;);masterDetailNav.AddPage&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);masterDetailNav.AddPage&lt;QuoteListPageModel&gt; (&quot;Quotes&quot;, null);await CoreMethods.PushNewNavigationServiceModal(masterDetailNav);</code></pre><p>##在 Xamarin.Forms MainPage 上切换 NavigationStacks</p><p>Xamarin.Forms 中有些情况可能需要运行多个导航堆栈。 一个很好的例子是当你有一个用于认证的导航堆栈和一个应用程序主区域的堆栈。</p><p>首先我们可以为导航容器设置一些名称。</p><pre><code>public class NavigationContainerNames{    public const string AuthenticationContainer = &quot;AuthenticationContainer&quot;;    public const string MainContainer = &quot;MainContainer&quot;;}</code></pre><p>然后我们可以创建我们的两个导航容器并分配到主页面。</p><pre><code>var loginPage = FreshMvvm.FreshPageModelResolver.ResolvePageModel&lt;LoginViewModel&gt;();var loginContainer = new FreshNavigationContainer(loginPage, NavigationContainerNames.AuthenticationContainer);var myPitchListViewContainer = new MainTabbedPage(NavigationContainerNames.MainContainer);MainPage = loginContainer;</code></pre><p>一旦我们设置好了，我们现在可以切换我们的导航容器。</p><pre><code>CoreMethods.SwitchOutRootNavigation(NavigationContainerNames.MainContainer);</code></pre><h2 id="自定义-IOC-容器"><a href="#自定义-IOC-容器" class="headerlink" title="自定义 IOC 容器"></a>自定义 IOC 容器</h2><p>FreshMvvm 1.0 的第二个主要要求是允许自定义 IOC 容器。 在您的应用程序已经具有要使用的容器的情况下。</p><p>使用自定义 IOC 容器非常简单，因为您只需要实现单个接口。</p><pre><code>public interface IFreshIOC{    object Resolve(Type resolveType);    void Register&lt;RegisterType&gt;(RegisterType instance) where RegisterType : class;    void Register&lt;RegisterType&gt;(RegisterType instance, string name) where RegisterType : class;    ResolveType Resolve&lt;ResolveType&gt;() where ResolveType : class;    ResolveType Resolve&lt;ResolveType&gt;(string name) where ResolveType : class;    void Register&lt;RegisterType, RegisterImplementation&gt; () where RegisterType : class where RegisterImplementation : class, RegisterType;</code></pre><p>然后在系统中设置 IOC 容器。</p><p><code>FreshIOC.OverrideContainer(myContainer);</code></p><h2 id="相关视频-快速入门指南"><a href="#相关视频-快速入门指南" class="headerlink" title="相关视频/快速入门指南"></a>相关视频/快速入门指南</h2><ul><li>FreshMvvm n = 0 - Mvvm 在 Xamarin.Forms 和为什么需要 FreshMvvm</li><li>FreshMvvm n = 1：你的第一个 FreshMvvm 应用程序</li><li>FreshMvvm n = 2 - IOC 和构造器注入</li><li>FreshMvvm n = 3：在 FreshMvvm 中导航</li><li>在 FreshMvvm 中为 Xamarin.Forms 实现自定义导航</li><li>TDD 在 Xamarin Studio - Live Coding FreshMvvm</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms Api请求开源框架Refit翻译</title>
    <link href="undefined2017/06/08/XamarinForms-Api%E8%AF%B7%E6%B1%82%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6Refit%E7%BF%BB%E8%AF%91/"/>
    <url>2017/06/08/XamarinForms-Api%E8%AF%B7%E6%B1%82%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6Refit%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="原文地址：https-github-com-paulcbetts-refit"><a href="#原文地址：https-github-com-paulcbetts-refit" class="headerlink" title="原文地址：https://github.com/paulcbetts/refit"></a>原文地址：<a href="https://github.com/paulcbetts/refit" target="_blank" rel="noopener">https://github.com/paulcbetts/refit</a></h2><p>用于.NET Core，Xamarin 和.NET 的自动类型安全的 REST 库，Refit 是一个受 Square Square Retrofit 库影响的库，但它比 REST API 更容易：</p><pre><code>public interface IGitHubApi{    [Get(&quot;/users/{user}&quot;)]    Task&lt;User&gt; GetUser(string user);}</code></pre><p>RestService 类生成一个使用 HttpClient 进行调用的 IGitHubApi 实现：</p><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;);var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);</code></pre><h1 id="兼容的平台"><a href="#兼容的平台" class="headerlink" title="兼容的平台"></a>兼容的平台</h1><h4 id="Refit-目前支持以下平台和任何-NET-Standard-1-3Taget"><a href="#Refit-目前支持以下平台和任何-NET-Standard-1-3Taget" class="headerlink" title="Refit 目前支持以下平台和任何.NET Standard 1.3Taget"></a>Refit 目前支持以下平台和任何.NET Standard 1.3Taget</h4><ul><li>Xamarin.Android</li><li>Xamarin.Mac</li><li>Xamarin.iOS 64-bit (Unified API)</li><li>Desktop .NET 4.5</li><li>Windows Store 8.1+</li><li>Windows Phone 8.1 Universal Apps</li><li>.NET Core</li></ul><h1 id="以下平台不支持"><a href="#以下平台不支持" class="headerlink" title="以下平台不支持"></a>以下平台不支持</h1><ul><li>Xamarin.iOS 32-bit</li></ul><h1 id="关于-NET-Core"><a href="#关于-NET-Core" class="headerlink" title="关于.NET Core"></a>关于.NET Core</h1><p>对于.NET Core 支持，您必须使用 csproj 类型的项目托管您的 Refit 接口。 这是因为 xproj 无法执行不包含在项目文件中的编译时代码生成。 如果您使用 xproj 作为网站，类库或应用程序，您仍然可以通过创建一个 netstandard csproj 然后使用从 xproj 到 csproj 的项目到项目的引用来使用 Refit。 一旦出现“VS 15”和最终的.NET Core 工具，此解决方法就不需要了。</p><h1 id="API-属性"><a href="#API-属性" class="headerlink" title="API 属性"></a>API 属性</h1><ul><li><p>每个方法都必须有一个 HTTP 属性，提供请求方法和相对 URL。 有五个内置注释：Get，Post，Put，Delete 和 Head。 资源的相对 URL 在注释中指定。<br><code>[Get(&quot;/users/list&quot;)]</code></p></li><li><p>你可以在 URL 中指定查询参数：<br><code>[Get(&quot;/users/list?sort=desc&quot;)]</code></p></li><li><p>可以使用方法上的替换块和参数动态更新请求 URL。 替换块是由{}包围的字母数字字符串。如果您的参数名称与 URL 路径中的名称不匹配，请使用 AliasAs 属性。</p></li></ul><pre><code>[Get(&quot;/group/{id}/users&quot;)]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs(&quot;id&quot;)] int groupId)</code></pre><ul><li>未指定为 URL 替换的参数将自动用作查询参数。 这与 Retrofit 不同，其中必须明确指定所有参数。参数名称和 URL 参数之间的比较不区分大小写，因此如果您在路径/ group/{groupid} /show 中命名参数”groupId”，它将正常工作。</li></ul><pre><code>[Get(&quot;/group/{id}/users&quot;)]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs(&quot;id&quot;)] int groupId, [AliasAs(&quot;sort&quot;)] string sortOrder);GroupList(4, &quot;desc&quot;);&gt;&gt;&gt; &quot;/group/4/users?sort=desc&quot;</code></pre><ul><li>PS：这里就是说如果你在 GroupList 的签名里面使用<code>[AliasAs(&quot;sort&quot;)] 变量类型 变量名</code>的方式，即使原本的路径里面没有“sort”的属性，也会自动加上去。</li></ul><p>#Body 内容</p><h2 id="通过使用-Body-属性，方法中的一个参数可以作为-Body"><a href="#通过使用-Body-属性，方法中的一个参数可以作为-Body" class="headerlink" title="通过使用 Body 属性，方法中的一个参数可以作为 Body"></a>通过使用 Body 属性，方法中的一个参数可以作为 Body</h2><pre><code>[Post(&quot;/users/new&quot;)]Task CreateUser([Body] User user);</code></pre><h2 id="根据参数的类型，提供-Body-数据有四种可能："><a href="#根据参数的类型，提供-Body-数据有四种可能：" class="headerlink" title="根据参数的类型，提供 Body 数据有四种可能："></a>根据参数的类型，提供 Body 数据有四种可能：</h2><ul><li>如果类型为 Stream，则内容将通过 StreamContent 流式传输。</li><li>如果类型是字符串，则该字符串将直接用作内容</li><li>如果参数具有[Body（BodySerializationMethod.UrlEncoded）]属性，内容将被 URL 编码（见下面的 Form Posts 部分）</li><li>对于所有其他类型，对象将被序列化为 JSON。</li></ul><p>#JSON 内容</p><ul><li>JSON 请求和响应使用 Json.NET 进行序列化/反序列化。 默认情况下，Refit 将使用可以通过设置 Newtonsoft.Json.JsonConvert.DefaultSettings 定义序列化器的设置：</li></ul><pre><code>JsonConvert.DefaultSettings = () =&gt; new JsonSerializerSettings() {        ContractResolver = new CamelCasePropertyNamesContractResolver(),        Converters = {new StringEnumConverter()} };//## Serialized as: {&quot;day&quot;:&quot;Saturday&quot;}await PostSomeStuff(new { Day = DayOfWeek.Saturday });</code></pre><ul><li>因为这些是全局设置，它们会影响整个应用程序。 将请求的设置隔离到特定的 AP 也许是有益的。 当创建一个 Refit 生成的实时界面时，您可以选择传递一个 RefitSettings，这将允许您指定你想要的 serializer 设置。 这允许您为不同的 API 具有不同的序列化器设置。</li></ul><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;,new RefitSettings{        JsonSerializerSettings = new JsonSerializerSettings {            ContractResolver = new SnakeCasePropertyNamesContractResolver()} } );var otherApi = RestService.For&lt;IOtherApi&gt;(&quot;https://api.example.com&quot;,new RefitSettings{        JsonSerializerSettings = new JsonSerializerSettings {         ContractResolver = new CamelCasePropertyNamesContractResolver()} } );</code></pre><ul><li>属性序列化/反序列化可以使用 Json.NET 的 JsonProperty 属性进行定制：</li></ul><pre><code>public class Foo{    // 像[AliasAs（“b”）]的使用将以form posts发布（见下文）    [JsonProperty(PropertyName=&quot;b&quot;)]    public string Bar { get; set; }}</code></pre><p>#Form posts</p><ul><li>对于采用表单帖子（即序列化为应用程序/ x-www-form-urlencoded）的 API，使用 BodySerializationMethod.UrlEncoded 初始化 Body 属性。参数可以是一个 IDictionary</li></ul><pre><code>public interface IMeasurementProtocolApi{    [Post(&quot;/collect&quot;)]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Dictionary&lt;string, object&gt; data);}var data = new Dictionary&lt;string, object&gt; {    {&quot;v&quot;, 1},    {&quot;tid&quot;, &quot;UA-1234-5&quot;},    {&quot;cid&quot;, new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;)},    {&quot;t&quot;, &quot;event&quot;},};// 序列化为: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(data);</code></pre><ul><li>或者您可以传递任何对象，所有公共可读属性将作为请求中的表单字段序列化。 该方法允许您使用[AliasAs（“whatever”）]来别名属性名称，如果 API 具有隐藏字段名称，则可以帮助您：</li></ul><pre><code>public interface IMeasurementProtocolApi{    [Post(&quot;/collect&quot;)]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Measurement measurement);}public class Measurement{    // 属性可以是只读的，不需要[AliasAs]    public int v { get { return 1; }    [AliasAs(&quot;tid&quot;)]    public string WebPropertyId { get; set; }    [AliasAs(&quot;cid&quot;)]    public Guid ClientId { get;set; }    [AliasAs(&quot;t&quot;)]    public string Type { get; set; }    public object IgnoreMe { private get; set; }}var measurement = new Measurement {    WebPropertyId = &quot;UA-1234-5&quot;,    ClientId = new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;),    Type = &quot;event&quot;};//序列化为: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(measurement);</code></pre><h1 id="设置请求标头"><a href="#设置请求标头" class="headerlink" title="设置请求标头"></a>设置请求标头</h1><ul><li><h2 id="静态标题"><a href="#静态标题" class="headerlink" title="静态标题"></a>静态标题</h2>您可以为应用 Headers 属性的方法设置一个或多个静态请求标头：</li></ul><pre><code>[Headers(&quot;User-Agent: Awesome Octocat App&quot;)][Get(&quot;/users/{user}&quot;)]Task&lt;User&gt; GetUser(string user);</code></pre><p>也可以通过将 Headers 属性应用于接口，将静态标头添加到 API 中的每个请求中：</p><pre><code>[Headers(&quot;User-Agent: Awesome Octocat App&quot;)]public interface IGitHubApi{    [Get(&quot;/users/{user}&quot;)]    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    Task CreateUser([Body] User user);}</code></pre><ul><li><h2 id="动态标题"><a href="#动态标题" class="headerlink" title="动态标题"></a>动态标题</h2>如果头文件的内容需要在运行时设置，则可以通过将 Header 属性应用到参数来为请求添加具有动态值的头文件：</li></ul><pre><code>[Get(&quot;/users/{user}&quot;)]Task&lt;User&gt; GetUser(string user, [Header(&quot;Authorization&quot;)] string authorization);// 将标题“Authorization：token OAUTH-TOKEN”添加到请求中var user = await GetUser(&quot;octocat&quot;, &quot;token OAUTH-TOKEN&quot;);</code></pre><ul><li><h2 id="授权（动态标题缩减）"><a href="#授权（动态标题缩减）" class="headerlink" title="授权（动态标题缩减）"></a>授权（动态标题缩减）</h2>使用标头的最常见原因是授权。 今天，大多数 API 使用一些口味的 oAuth，访问令牌到期并刷新取得更长寿命的令牌。封装这些令牌用法的一种方法是，可以插入一个自定义的 HttpClientHandler。举个例子：</li></ul><pre><code>class AuthenticatedHttpClientHandler : HttpClientHandler{    private readonly Func&lt;Task&lt;string&gt;&gt; getToken;    public AuthenticatedHttpClientHandler(Func&lt;Task&lt;string&gt;&gt; getToken)    {        if (getToken == null) throw new ArgumentNullException(&quot;getToken&quot;);        this.getToken = getToken;    }    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)    {        // See if the request has an authorize header        var auth = request.Headers.Authorization;        if (auth != null)        {            var token = await getToken().ConfigureAwait(false);            request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);        }        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);    }}</code></pre><p>虽然 HttpClient 包含几乎相同的方法签名，但使用方式不同。 HttpClient.SendAsync 不被调用。 必须修改 HttpClientHandler。这个类是这样使用的（例如使用 ADAL 库来管理 Xamarin.Auth 或任何其他库的自动令牌刷新：</p><pre><code>class LoginViewModel{    AuthenticationContext context = new AuthenticationContext(...);    private async Task&lt;string&gt; GetToken()    {        // 如果需要，AquireTokenAsync调用将提示用户界面        // 否则默认使用刷新令牌返回一个有效的访问令牌        var token = await context.AcquireTokenAsync(&quot;http://my.service.uri/app&quot;, &quot;clientId&quot;, new Uri(&quot;callback://complete&quot;));        return token;    }    public async void LoginAndCallApi()    {        var api = RestService.For&lt;IMyRestService&gt;(new HttpClient(new AuthenticatedHttpClientHandler(GetToken)) { BaseAddress = new Uri(&quot;https://the.end.point/&quot;) });        var location = await api.GetLocationOfRebelBase();    }}interface IMyRestService{    [Get(&quot;/getPublicInfo&quot;)]    Task&lt;Foobar&gt; SomePublicMethod();    [Get(&quot;/secretStuff&quot;)]    [Headers(&quot;Authorization: Bearer&quot;)]    Task&lt;Location&gt; GetLocationOfRebelBase();}</code></pre><p>在上面的例子中，任何时候调用需要身份验证的方法，AuthenticatedHttpClientHandler 将尝试获取一个新的访问令牌。 由应用程序提供一个，检查现有访问令牌的到期时间，并在需要时获取新的访问令牌。</p><ul><li><h1 id="重新定义标题"><a href="#重新定义标题" class="headerlink" title="重新定义标题"></a>重新定义标题</h1>不同于 Retrofit，其中标题不会相互覆盖，并且都添加到请求中，而不管定义同一个标题的次数如何，Refit 对 ASP.NET MVC 采用与动作过滤器相似的方法采用类似的方法 - 重新定义标题将替换 它按以下顺序排列：</li><li>接口上的标题属性（最低优先级）</li><li>标题属性在方法</li><li>方法参数的标题属性（最高优先级）</li></ul><pre><code>[Headers(&quot;X-Emoji: :rocket:&quot;)]public interface IGitHubApi{    [Get(&quot;/users/list&quot;)]    Task&lt;List&gt; GetUsers();    [Get(&quot;/users/{user}&quot;)]    [Headers(&quot;X-Emoji: :smile_cat:&quot;)]    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    [Headers(&quot;X-Emoji: :metal:&quot;)]    Task CreateUser([Body] User user, [Header(&quot;X-Emoji&quot;)] string emoji);}// X-Emoji: :rocket:var users = await GetUsers();// X-Emoji: :smile_cat:var user = await GetUser(&quot;octocat&quot;);// X-Emoji: :trollface:await CreateUser(user, &quot;:trollface:&quot;);</code></pre><ul><li>#删除标题<br>在界面或方法上定义的标题可以通过重新定义没有值的静态标题（即不使用：<value>）或为动态标题传递 null 来删除。 空字符串将被包括为空标题。</value></li></ul><pre><code>[Headers(&quot;X-Emoji: :rocket:&quot;)]public interface IGitHubApi{    [Get(&quot;/users/list&quot;)]    [Headers(&quot;X-Emoji&quot;)] // 删除X-Emoji标题    Task&lt;List&gt; GetUsers();    [Get(&quot;/users/{user}&quot;)]    [Headers(&quot;X-Emoji:&quot;)] // 将X-Emoji标题重新定义为空    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    Task CreateUser([Body] User user, [Header(&quot;X-Emoji&quot;)] string emoji);}// 没有X-Emoji标题var users = await GetUsers();// X-Emoji:var user = await GetUser(&quot;octocat&quot;);// 没有X-Emoji标题await CreateUser(user, null);// X-Emoji:await CreateUser(user, &quot;&quot;);</code></pre><ul><li><h1 id="断点上传"><a href="#断点上传" class="headerlink" title="断点上传"></a>断点上传</h1>使用 Multipart 属性装饰的方法将使用多部分内容类型提交。 此时，multipart 方法支持以下参数类型：</li><li>字符串（参数名称将用作名称和字符串值作为值）</li><li>字节数组</li><li>流</li><li>FileInfo<br>参数名称将用作多部分数据中字段的名称。 这可以被 AliasAs 属性覆盖。要指定字节数组（byte []），Stream 和 FileInfo 参数的文件名和内容类型，需要使用包装类。 ByteArrayPart，StreamPart 和 FileInfoPart。</li></ul><pre><code>public interface ISomeApi{    [Multipart]    [Post(&quot;/users/{id}/photo&quot;)]    Task UploadPhoto(int id, [AliasAs(&quot;myPhoto&quot;)] StreamPart stream);}</code></pre><p>要将 Stream 传递给此方法，请构建如下所示的 StreamPart 对象：<br><code>someApiInstance.UploadPhoto(id, new StreamPart(myPhotoStream, &quot;photo.jpg&quot;, &quot;image/jpeg&quot;));</code><br>注意：此部分以前描述的 AttachmentName 属性已被弃用，不推荐使用它。</p><h1 id="检索回应"><a href="#检索回应" class="headerlink" title="检索回应"></a>检索回应</h1><p>请注意，在 Refit 中，与 Retrofit 不同，没有同步网络请求的选项 - 所有请求都必须通过任务或通过 IObservable 进行异步。 不像 Retrofit，只能通过回调参数创建异步，因为我们生活在 async/await 未来。</p><pre><code>[Post(&quot;/users/new&quot;)]Task CreateUser([Body] User user);// 如果网络呼叫失败，则会发生这种情况await CreateUser(someUser);</code></pre><p>如果 type 参数是’HttpResponseMessage’或’string’，则原始响应消息或作为字符串的内容将分别返回。</p><pre><code>// Returns the content as a string (i.e. the JSON data)[Get(&quot;/users/{user}&quot;)]Task&lt;string&gt; GetUser(string user);//返回原始响应，作为可用于Reactive Extensions的IObservable[Get(&quot;/users/{user}&quot;)]IObservable&lt;HttpResponseMessage&gt; GetUser(string user);</code></pre><h1 id="使用通用接口"><a href="#使用通用接口" class="headerlink" title="使用通用接口"></a>使用通用接口</h1><p>当使用像 ASP.NET Web API 这样的东西，它是一个相当普遍的模式，拥有一整套 CRUD REST 服务。 Refit 现在允许您使用通用类型定义单个 API 接口：</p><pre><code>public interface IReallyExcitingCrudApi&lt;T, in TKey&gt; where T : class{    [Post(&quot;&quot;)]    Task&lt;T&gt; Create([Body] T paylod);    [Get(&quot;&quot;)]    Task&lt;List&lt;T&gt;&gt; ReadAll();    [Get(&quot;/{key}&quot;)]    Task&lt;T&gt; ReadOne(TKey key);    [Put(&quot;/{key}&quot;)]    Task Update(TKey key, [Body]T payload);    [Delete(&quot;/{key}&quot;)]    Task Delete(TKey key);}</code></pre><ul><li><h2 id="可以这样使用："><a href="#可以这样使用：" class="headerlink" title="可以这样使用："></a>可以这样使用：</h2></li></ul><pre><code>// 这里的“/ users”部分是很重要的，如果您希望它可以使用多种类型（除非每种类型都有不同的域）var api = RestService.For&lt;IReallyExcitingCrudApi&lt;User, string&gt;&gt;(&quot;http://api.example.com/users&quot;);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rg.Popup-Xamarin Forms使用教程</title>
    <link href="undefined2017/06/06/Rg.Popup-XamarinForms%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>2017/06/06/Rg.Popup-XamarinForms%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这是一个增强 popup 的插件，这里只讲用法，不讲原理。<br>第一步：装 Nuget 包，在 Pcl 项目中搜索”Rg.Plugins.Popup”作者是：Kirill Lyubimov，其他项目不需要装。(<a href="http://www.jianshu.com/p/a71d10660b3a" target="_blank" rel="noopener">装 Nuget 教程</a>）<br>第二步：创建 popup 页面（就是弹出显示的那个页面）<br>第三步：使用 PopupNavigation 类的几个导航方法。</p><p>好，知道了基本步骤之后就开始教程。<br>第一步应该都知道怎么操作，不多讲了。</p><p>重点讲第二步：<br>第二步内容比较多，我们一个一个来操作。 </p><ul><li>新建一个项目叫 Demo（跨平台项目） </li><li>创建一个 Popup 的 Page 新建项：——类型选：Forms Blank Content Page Xaml ，取名为 DemoPopupPage 吧。 </li><li>在 DemoPopupPage.Xaml 页面里面必须这样写</li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;pages:PopupPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;             xmlns:pages=&quot;clr-namespace:Rg.Plugins.Popup.Pages;assembly=Rg.Plugins.Popup&quot;             xmlns:animations=&quot;clr-namespace:Rg.Plugins.Popup.Animations;assembly=Rg.Plugins.Popup&quot;             x:Class=&quot;Demo.DemoPopupPage&quot;&gt; &lt;!--代码块1--&gt;&lt;/pages:PopupPage&gt;</code></pre><p>下面是“代码块 1”：</p><pre><code>  &lt;pages:PopupPage.Animation&gt;    &lt;animations:ScaleAnimation      PositionIn=&quot;Top&quot;      PositionOut=&quot;Center&quot;      ScaleIn=&quot;1&quot;      ScaleOut=&quot;0.7&quot;      DurationIn=&quot;700&quot;      EasingIn=&quot;BounceOut&quot;/&gt;  &lt;/pages:PopupPage.Animation&gt;&lt;!--布局--&gt;</code></pre><h2 id="对上面的代码稍作解释："><a href="#对上面的代码稍作解释：" class="headerlink" title="对上面的代码稍作解释："></a>对上面的代码稍作解释：</h2><p>animations:ScaleAnimation 表示使用缩放动画<br>对于 PositionIn/PositionOut 属性</p><pre><code>表示Popup从页面的哪个方位进入/弹出。它有：Center,Left,Right,Top,Bottom四个可以选，它的类型是MoveAnimationOptions，它是一个枚举。</code></pre><p>关于 PositionIn/PositionOut</p><pre><code>表示Popup出现/消失动画的持续时间</code></pre><p>关于 ScaleIn/ScaleOut</p><pre><code>表示出现/消失动画执行完毕后渲染Popup的时间</code></pre><p>关于 EasingIn</p><pre><code>表示动画的特性。一共有* Linear;   线性变换。* SinOut;   平滑减速，就是慢慢变慢* SinIn;    平稳加速，缓缓变快* SinInOut; 加速进出，Popup出现和消失都会加速* CubicIn;  慢慢开始加速，加速度不定的加速。* CubicOut; 开始快速减速。，加速度不定的减速。* CubicInOut加速减速。 一般选择。* BounceOut;弹跳3次，静止在目的地* BounceIn; 弹跳2次，然后静止在目的地* SpringIn;不知道怎么解释，自己测试吧* SpringOut;跟BounceIn有些类似，但是更有柔软性</code></pre><p>Ps：这些属性在不同的动画类型展示出来的效果是不一样的。这些属性更像形容词，套到这里的缩放动画就是：线性变化的缩放动画</p><p>Ok，其他动画也大同小异。然后到<!--布局-->这里<br>这里没有什么太大的问题。<br>要注意 2 个点，第一层布局必须是 StackLayout,Grid 这类布局，然后第二层布局一定是 Frame（为了不把背景全部盖住），再下一级的布局跟正常的布局是一样的没有区别。<br>示例代码：</p><pre><code>    &lt;StackLayout VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot;&gt;        &lt;Frame BackgroundColor=&quot;Silver&quot;&gt;            &lt;StackLayout Spacing=&quot;20&quot;&gt;                &lt;ListView x:Name=&quot;ListView&quot;&gt;                    &lt;ListView.ItemTemplate&gt;                        &lt;DataTemplate&gt;                            &lt;ViewCell&gt;                                &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;                                    &lt;Label Text=&quot;{Binding Briefing}&quot;&gt;&lt;/Label&gt;                                    &lt;Label Text=&quot;{Binding Color}&quot;&gt;&lt;/Label&gt;                                    &lt;Label Text=&quot;{Binding Composition}&quot;&gt;&lt;/Label&gt;                                &lt;/StackLayout&gt;                            &lt;/ViewCell&gt;                        &lt;/DataTemplate&gt;                    &lt;/ListView.ItemTemplate&gt;                &lt;/ListView&gt;                &lt;Label Text=&quot;??&quot;&gt;&lt;/Label&gt;            &lt;/StackLayout&gt;        &lt;/Frame&gt;    &lt;/StackLayout&gt;</code></pre><p>Ps:StackLayout 的 VerticalOptions=”Center” HorizontalOptions=”Center”表示这个 Popup 会在屏幕中间，修改可以出现在其他的地方。</p><p>自定义动画：</p><blockquote><p>有空再更</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms-如何横置组件</title>
    <link href="undefined2017/06/05/XamarinForms-%E5%A6%82%E4%BD%95%E6%A8%AA%E7%BD%AE%E7%BB%84%E4%BB%B6/"/>
    <url>2017/06/05/XamarinForms-%E5%A6%82%E4%BD%95%E6%A8%AA%E7%BD%AE%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>原理其实很简单，就是通过 <code>ListView</code> 的 <code>Rotation</code> 属性旋转即可。 ##如果你想做图片轮播话建议用 <code>scroview</code>，如果 <code>page</code> 里面有一个竖向的 <code>listview</code> 也有一个横向的，会导致两者冲突，用 <code>scroview</code> 才对。代码换成 <code>scroview</code> 即可完美解决</p><h1 id="例子如下："><a href="#例子如下：" class="headerlink" title="例子如下："></a>例子如下：</h1><h2 id="MainPage-Xaml"><a href="#MainPage-Xaml" class="headerlink" title="MainPage.Xaml"></a>MainPage.Xaml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;             xmlns:local=&quot;clr-namespace:TapListView&quot;             x:Class=&quot;TapListView.MainPage&quot;&gt;    &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;        &lt;Button x:Name=&quot;Button1&quot; Text=&quot;左滑&quot; HorizontalOptions=&quot;FillAndExpand&quot; Opacity=&quot;0.5&quot;&gt;&lt;/Button&gt;        &lt;StackLayout HorizontalOptions=&quot;FillAndExpand&quot;&gt;            &lt;ListView x:Name=&quot;ListView&quot; Rotation=&quot;90&quot; HasUnevenRows=&quot;True&quot;&gt;                &lt;ListView.ItemTemplate&gt;                    &lt;DataTemplate&gt;                        &lt;ViewCell&gt;                            &lt;Image Source=&quot;{Binding .}&quot; Rotation=&quot;270&quot;                                   VerticalOptions=&quot;FillAndExpand&quot;                                   HorizontalOptions=&quot;FillAndExpand&quot;&gt;                            &lt;/Image&gt;                        &lt;/ViewCell&gt;                    &lt;/DataTemplate&gt;                &lt;/ListView.ItemTemplate&gt;            &lt;/ListView&gt;        &lt;/StackLayout&gt;        &lt;Button x:Name=&quot;Button2&quot; Text=&quot;右滑&quot; Opacity=&quot;0.5&quot;                HorizontalOptions=&quot;FillAndExpand&quot;&gt;&lt;/Button&gt;    &lt;/StackLayout&gt;&lt;/ContentPage&gt;</code></pre><h2 id="MainPage-cs（这代码跟横置-ListView-没有关系）"><a href="#MainPage-cs（这代码跟横置-ListView-没有关系）" class="headerlink" title="MainPage.cs（这代码跟横置 ListView 没有关系）"></a>MainPage.cs（这代码跟横置 ListView 没有关系）</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using Xamarin.Forms;namespace TapListView{    public partial class MainPage : ContentPage    {        public List&lt;ImageSource&gt; ImageSources { get; set; } = new List&lt;ImageSource&gt;();        public MainPage()        {            InitializeComponent();            SetSource();            ListView.ItemsSource = ImageSources;        }        private void SetSource()        {            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/4317b8660f13b0826380d5ef0c4bc963_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/7621a57ace831fa0c8616fff6497edf3_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/f5ff39f3f5304a45e8b8b4952fdca368_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/1595ab2bad62fe267b55c1f450445136_magazine_web_m.jpg&quot;)));        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇葩说-第四季金句</title>
    <link href="undefined2017/05/04/%E5%A5%87%E8%91%A9%E8%AF%B4-01/"/>
    <url>2017/05/04/%E5%A5%87%E8%91%A9%E8%AF%B4-01/</url>
    
    <content type="html"><![CDATA[<p>抬头看着太阳说，你该下山了。 – 欧阳超</p><p>世上是没有事有意义的，意义都是人赋予的，而坚持本身就是无比闪亮的意义 – 陈铭</p><p>你不觉得，现实本身是由梦想来支撑的吗？– 张泉灵</p><p>好朋友就像另一个自己，我们要听好朋友的声音是听一个我们无法跟自己内心 直接对话可是我们想要听到另外一个自己的声音，你作为一个好朋友，不提供这个声音让那个人听见，却误以为他只要照他自己的意思走下去就够了，那他在世界上孤身一人家好了，要好朋友干什么？所以好朋友像人生的一个滤勺，它把我们的杂质都滤掉了，让我们更纯净。 – 蔡康永</p><p>什么叫梦想，一种叫我实现了梦想，一种是梦想因我而实现。– 宋佳</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>