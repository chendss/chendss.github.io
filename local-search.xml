<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于webpack4手把手教你构建单页面（非主流框架）</title>
    <link href="undefined2019/10/26/webpack4-%E9%9D%9E%E6%A1%86%E6%9E%B6%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
    <url>2019/10/26/webpack4-%E9%9D%9E%E6%A1%86%E6%9E%B6%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>最近准备个礼物送给女朋友，之前送的东西都是可爱型，这次换点不一样的。准备写一个回忆杀</p><h1 id="项目架构思路"><a href="#项目架构思路" class="headerlink" title="项目架构思路"></a>项目架构思路</h1><ul><li>初始化项目</li><li>整体项目结构划分</li><li>技术选型</li><li>配置<em>webpack</em></li><li>业务代码编写</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><ul><li><p>建立空文件夹，执行 <code>yarn</code></p></li><li><p>执行<code>npm init</code> 一路回车就可以了，都是一些后期可以改的配置无需在意，这个时候生成的<em>package.json</em>文件应该是</p><pre><code class="json">{  &quot;name&quot;: &quot;your name&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;, // #tag  &quot;dependencies&quot;: {  },  &quot;devDependencies&quot;: {},  &quot;scripts&quot;: {},  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;}</code></pre></li></ul><ul><li><p>安装 <em>webpack</em> ,执行 // 为什么要分开3条命令，因为这样安装失败容易定位问题</p><ul><li><code>yarn add webpack -d</code> </li><li><code>yarn add webpack-cli -d</code> </li><li><code>yarn add webpack-dev-server -d</code></li></ul></li><li><p>新建<em>.gitignore</em>文件（<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208" target="_blank" rel="noopener">解释这个文件的用处</a>），写入代码 为了不让这个破包的东西加入git监听</p><pre><code class="shell">node_modules/</code></pre></li></ul><p>到这项目的基本要素已经有了，可以看到项目的目录变成了<img src="https://ae01.alicdn.com/kf/Udb7de13570734babab448ead668dec1ad.png" srcset="/img/loading.gif" alt></p><h2 id="整体项目结构划分"><a href="#整体项目结构划分" class="headerlink" title="整体项目结构划分"></a>整体项目结构划分</h2><p>遵循模块分离的思想，关于webpack配置的应该单独放在一个文件夹 <strong>webpack</strong></p><p>业务逻辑一个文件夹  <strong>src</strong></p><p>配置文件也应该独占一个文件夹 <strong>config</strong></p><p>得到如图<img src="https://ae01.alicdn.com/kf/U4bdb0433c94f40c5b828777090d2db872.png" srcset="/img/loading.gif" alt></p><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端测试技术研究报告</title>
    <link href="undefined2019/10/22/react%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>2019/10/22/react%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前端测试技术研究报告"><a href="#前端测试技术研究报告" class="headerlink" title="前端测试技术研究报告"></a>前端测试技术研究报告</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端开发中的测试在前端的开发过程中一直不是必须包含的步骤。但是随着每个项目的<strong>复杂化</strong>、代码的<strong>高复用性</strong>要求、组件之间的<strong>高内聚低耦合</strong>的要求越来越高，我们需要使用一些其他手段来保证<strong>代码质量</strong>并且缩短<strong>回馈周期</strong>，而进行<strong>整体测试</strong>就是其中一种手段，也就是本文要探讨的范畴。</p><h2 id="前端测试包含的内容"><a href="#前端测试包含的内容" class="headerlink" title="前端测试包含的内容"></a>前端测试包含的内容</h2><ul><li>单元测试</li><li>UI 自动化测试</li></ul><h2 id="前端测试的意义"><a href="#前端测试的意义" class="headerlink" title="前端测试的意义"></a>前端测试的意义</h2><h4 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h4><ul><li><strong>快速</strong>反馈功能是否良好，验证想法</li><li>保证代码重构的<strong>安全性</strong>，即修改代码后可快速发现对整体是否有差的影响</li><li><strong>节约</strong>手动测试的时间，避免重复劳动</li><li>保证代码<strong>质量</strong></li><li>某种程度促使编写更<strong>低耦合</strong>的代码以便测试</li><li>容易<strong>隔离</strong>和<strong>定位</strong>错误，有利于调试工作</li></ul><h4 id="UI-自动化测试的意义"><a href="#UI-自动化测试的意义" class="headerlink" title="UI 自动化测试的意义"></a>UI 自动化测试的意义</h4><ul><li>批量输出当前场景的实际浏览器截图以便校验</li><li>快速定位实际效果与设计稿的<strong>偏差</strong></li><li>快速判断当前实现是否符合业务场景</li></ul><h2 id="一、单元测试"><a href="#一、单元测试" class="headerlink" title="一、单元测试"></a>一、单元测试</h2><h3 id="1-1、单元测试是什么"><a href="#1-1、单元测试是什么" class="headerlink" title="1.1、单元测试是什么"></a>1.1、单元测试是什么</h3><p>是指对项目中的最小可测试单元进行检查和验证。</p><p>对于前端来说，比如某一个函数的<strong>功能</strong>是否正常、组件的<strong>表现</strong>是否正常，简单来说就是对人为规定的最小可测试模块进行工程化测试。软件的独立单元将在与程序的其他部分相隔离互不影响的情况下进行测试。</p><h3 id="1-2、前端需要单元测试的部分"><a href="#1-2、前端需要单元测试的部分" class="headerlink" title="1.2、前端需要单元测试的部分"></a>1.2、前端需要单元测试的部分</h3><p>对于前端来说可分拆的最小部分为<strong>函数</strong>，最小可视化内容为<strong>组件</strong>，所以前端的测试内容可以分为<strong>函数</strong>、<strong>组件</strong></p><h4 id="1-2-1、函数测试"><a href="#1-2-1、函数测试" class="headerlink" title="1.2.1、函数测试"></a>1.2.1、函数测试</h4><p>对于 react 而言，函数一般在整体项目里的覆盖率并不高在 10%左右。</p><ul><li>对于有返回值的函数：对函数进行输入值模拟且判断，输出值校验。</li><li>对于没有返回值的函数：寻找函数中可观察到特性（例如某个对象的状态被改变）进行校验。</li></ul><h4 id="1-2-2、组件测试"><a href="#1-2-2、组件测试" class="headerlink" title="1.2.2、组件测试"></a>1.2.2、组件测试</h4><p>对于 react 而言，组件在整体项目里占比非常高，可以达到 80-90%。</p><ul><li>组件是否正常渲染</li><li>组件特定节点值是否正确</li><li>组件特定节点属性值是否正确。</li></ul><h3 id="1-3、编写测试用例的原则"><a href="#1-3、编写测试用例的原则" class="headerlink" title="1.3、编写测试用例的原则"></a>1.3、编写测试用例的原则</h3><ul><li>只考虑测试，不考虑内部实现</li><li>数据尽量模拟真实</li><li>充分考虑数据的边界条件</li><li>对重点、核心代码，重点测试</li></ul><h3 id="1-3、react-测试工具链的选择"><a href="#1-3、react-测试工具链的选择" class="headerlink" title="1.3、react 测试工具链的选择"></a>1.3、react 测试工具链的选择</h3><h4 id="1-3-1、测试工具库"><a href="#1-3-1、测试工具库" class="headerlink" title="1.3.1、测试工具库"></a>1.3.1、测试工具库</h4><h6 id="1-3-1-1、官方测试工具库-react-dom-test-utils"><a href="#1-3-1-1、官方测试工具库-react-dom-test-utils" class="headerlink" title="1.3.1.1、官方测试工具库 react-dom/test-utils"></a>1.3.1.1、官方测试工具库 <strong>react-dom/test-utils</strong></h6><p>react 本身只能用这套工具库测试，但是由于它太不方便了，并且上手难度也相对较高，于是 Airbnb 公司开发另外一套测试工具库来替代它。换言之这套测试工具库的在当前并不是特别适合开展探讨，所以就不对它展开探讨。</p><h6 id="1-3-1-2、第三方测试工具库-Enzyme"><a href="#1-3-1-2、第三方测试工具库-Enzyme" class="headerlink" title="1.3.1.2、第三方测试工具库 Enzyme"></a>1.3.1.2、第三方测试工具库 <strong><a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https://github.com/airbnb/enzyme" target="_blank" rel="noopener">Enzyme</a></strong></h6><p>Enzyme 是由 Airbnb 开源的一个 React 的 JavaScript 测试工具，它具有如下特点</p><ul><li>API 和 jQuery 操作 DOM 一样灵活易用</li><li>使用的是 cheerio 库来解析虚拟 DOM</li><li><strong>兼容</strong>大多数断言库和测试框架</li><li><strong>便利</strong>的工具函数库封装，可以处理浅渲染，静态渲染标记以及 DOM 渲染</li></ul><h4 id="1-3-2、测试框架"><a href="#1-3-2、测试框架" class="headerlink" title="1.3.2、测试框架"></a>1.3.2、测试框架</h4><p>当前市面上的测试框架各有各的优势和缺点，不分伯仲，本次测试框架的探讨并不是<strong>最主要</strong>的部分，所以选用一个配置最为简单，最为灵活的测试框架-<strong>Mocha</strong></p><h4 id="1-3-3、小结"><a href="#1-3-3、小结" class="headerlink" title="1.3.3、小结"></a>1.3.3、小结</h4><p>选用更为简单易用的<strong>Enzyme</strong> 作为测试工具库，选用简单灵活的<strong>Mocha</strong>作为测试框架，进行以下的单元测试。</p><h3 id="1-4、单元测试包含的主要部分"><a href="#1-4、单元测试包含的主要部分" class="headerlink" title="1.4、单元测试包含的主要部分"></a>1.4、单元测试包含的主要部分</h3><h4 id="1-4-1、断言"><a href="#1-4-1、断言" class="headerlink" title="1.4.1、断言"></a>1.4.1、断言</h4><p>当断言失败时则表示测试不通过</p><ul><li>同等性断言：相等则通过</li><li>比较性断言：大小关系符合预期则通过</li><li>类型性断言：类型符合预期则通过</li><li>条件性测试：某种条件为<code>true</code>则通过</li></ul><h4 id="1-4-2、测试用例"><a href="#1-4-2、测试用例" class="headerlink" title="1.4.2、测试用例"></a>1.4.2、测试用例</h4><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个功能是否达到预期，多表现为一个函数。</p><h3 id="1-5、基于-Enzyme-的-react-单元测试实际体验"><a href="#1-5、基于-Enzyme-的-react-单元测试实际体验" class="headerlink" title="1.5、基于 Enzyme 的 react 单元测试实际体验"></a>1.5、基于 Enzyme 的 react 单元测试实际体验</h3><h4 id="1-5-1、功能简介"><a href="#1-5-1、功能简介" class="headerlink" title="1.5.1、功能简介"></a>1.5.1、功能简介</h4><ul><li>浅层渲染（<strong>shallow</strong>）- 将一个组件渲染成虚拟 DOM 对象，但是只渲染第一层，不渲染所有子组件，这种渲染方式速度<strong>特别快</strong>，因为不需要真正加载进 DOM</li><li>渲染成静态的 HTML 字符串（<strong>render</strong>）- 将组件渲染成 HTML 字符串，与浅层渲染很像，不一样是<strong>render</strong>返回的是一个<strong>Cheerio</strong>实例对象</li><li>加载为真实<strong>dom</strong>节点（<strong>mount</strong>）- 将 React 组件加载为真实 DOM 节点</li></ul><h4 id="1-5-2、函数测试"><a href="#1-5-2、函数测试" class="headerlink" title="1.5.2、函数测试"></a>1.5.2、函数测试</h4><h6 id="1-5-2-1、具有返回值的函数测试"><a href="#1-5-2-1、具有返回值的函数测试" class="headerlink" title="1.5.2.1、具有返回值的函数测试"></a>1.5.2.1、具有返回值的函数测试</h6><p>这里挑选两个函数进行测试，一个简单一个稍微复杂些</p><ul><li>加法函数<strong>add</strong> - 传入两个数字，返回它们的和。下面是核心的测试代码</li></ul><pre><code class="javascript">describe(&#39;加法函数测试&#39;, () =&gt; {  it(&#39;1+1应该等于2&#39;, () =&gt; {    expect(add(1, 1)).to.be.equal(2);  });});</code></pre><p>可以看到结果为测试通过</p><img src="https://ae01.alicdn.com/kf/Ua30d64524b074f65aba7e9e1161472701.png" srcset="/img/loading.gif" class="bm"><ul><li>冒泡排序函数测试 - <strong>sort</strong>，传入一个数字数组，返回一个按从小到大排序的数字，下面是测试的核心代码</li></ul><pre><code class="javascript">describe(&#39;冒泡排序测试&#39;, () =&gt; {  it(&#39;[1,5,6,8,9,0,-1]应该排序为[-1,0,1,5,6,8,9]&#39;, () =&gt; {    let sortValue = sort([1, 5, 6, 8, 9, 0, -1]).join(&#39;&#39;);    let expectValue = [-1, 0, 1, 5, 6, 8, 9].join(&#39;&#39;);    expect(sortValue).to.be.equal(expectValue);  });});</code></pre><img src="https://ae01.alicdn.com/kf/Ud84a108fd6534859b46b1da6704b8f4dK.png" srcset="/img/loading.gif"><p>显然断言失败了，提示我们输出的值跟期望值不一致，通过修改 bug 再次运行测试</p><img src="https://ae01.alicdn.com/kf/U8afe8bc3329546f98b5b8967dafb41e8r.png" srcset="/img/loading.gif"><p>这次断言成功了</p><h6 id="1-5-2-2、没有返回值的函数测试"><a href="#1-5-2-2、没有返回值的函数测试" class="headerlink" title="1.5.2.2、没有返回值的函数测试"></a>1.5.2.2、没有返回值的函数测试</h6><p>前面 1.5.2.1 采取一个一个函数进行测试，现在进行多个函数并行测试</p><p>场景为：定义一个 Store 类，具有 loading 和 tableData 两个变量，向外暴露 4 个函数，代码如下。</p><pre><code class="javascript">import { sort } from &#39;./math&#39;; // 冒泡排序函数class Store {  constructor() {    this.loading = true;    this.tableData = [1, 2, 3, 4, 0, 11, 43, 24, 67, 7];  }}const store = new Store();export const getLoading = function() {  return store.loading;};export const getData = function() {  return store.tableData;};export const close = function() {  store.loading = false;};export const sortTableData = function() {  store.tableData = sort(store.tableData);};</code></pre><p>将对 4 个暴露出来的函数进行测试，其中<code>getLoading</code>、<code>getData</code>具有返回值。</p><p>而<code>close</code>、<code>sortTableData</code>不具有返回值，显然要判断这两个函数是否正确，就必须在测试代码调用<code>getLoading</code>或者<code>getData</code>用以观察<code>close</code>、<code>sortTableData</code>是否正确执行，所以要先对<code>getLoading</code>、<code>getData</code>进行测试。核心测试代码如下：</p><pre><code class="javascript">describe(&#39;有返回-获得store loading状态&#39;, () =&gt; {  it(&#39;应该返回ture&#39;, () =&gt; {    let value = getLoading();    expect(value).to.be.equal(true);  });});describe(&#39;有返回-获得store tableData值&#39;, () =&gt; {  it(&#39;应该返回 1234114324677&#39;, () =&gt; {    let value = getData().join(&#39;&#39;);    let expectValue = [1, 2, 3, 4, 0, 11, 43, 24, 67, 7].join(&#39;&#39;);    expect(value).to.be.equal(expectValue);  });});describe(&#39;无返回-修改loading值状态&#39;, () =&gt; {  it(&#39;应该成功修改store的loading状态为false&#39;, () =&gt; {    close();    let expectValue = false;    expect(getLoading()).to.be.equal(expectValue);  });});describe(&#39;无返回-修改tableData排序&#39;, () =&gt; {  it(&#39;应该成功修改tableData为[0, 1, 2, 3, 4, 7, 11, 24, 43,67]&#39;, () =&gt; {    sortTableData();    let value = getData().join(&#39;&#39;);    let expectValue = [0, 1, 2, 3, 4, 7, 11, 24, 43, 67];    expect(value).to.be.equal(expectValue.join(&#39;&#39;));  });});</code></pre><img src="https://ae01.alicdn.com/kf/Ue398637e07554cfca1213360edf3a2bcI.png" srcset="/img/loading.gif"><p>从结果看出，并行测试具有顺序的概念，确保了前两个函数的正确性，后两个函数才可以正确测试，并且测试的速度是非常快的，并不会收到多个测试用例的影响而导致不可接受的变慢。</p><h6 id="1-5-2-3-小结"><a href="#1-5-2-3-小结" class="headerlink" title="1.5.2.3 小结"></a>1.5.2.3 小结</h6><p>无论是具有返回值还是没有返回值的函数进行测试都<strong>相对简单</strong>，测试代码的编写也并<strong>不复杂</strong>，但是却可以带来<strong>一劳永逸</strong>的效果，每次运行都可以对所有的函数进行测试。而在没有进行单元测试，就得对每一个函数单独手动测试，可能耗费大量时间，所以单论函数测试来说，进行单元测试是有<strong>极大</strong>的好处的。</p><h4 id="1-5-3、组件测试"><a href="#1-5-3、组件测试" class="headerlink" title="1.5.3、组件测试"></a>1.5.3、组件测试</h4><p>一个简单的 todo-list 组件，标题为<strong>todo-list</strong>具有以下功能</p><ul><li><p>添加一条 todo</p></li><li><p>删除一条 todo</p></li><li><p>输入 todo 文字功能</p></li></ul><p>整体如图所示 <img src="https://ae01.alicdn.com/kf/U6b0f7c12b4164a63a6ddbaf0ed231e4bb.png" srcset="/img/loading.gif"></p><p>将为此组件编写以下几个测试点</p><ul><li>1、标题是否为<strong>todo-list</strong></li><li>2、添加 todo 按钮文本是否为<strong>添加一条 todo</strong></li><li>3、判断输入框的提示是否为<strong>请输入</strong></li><li>4、删除 todo 按钮文本是否为<strong>删除</strong></li><li>5、初始化数据为<strong>第一条</strong>、<strong>第二条</strong>、<strong>第三条</strong></li><li>6、todo 输入功能是否正确</li><li>7、添加 todo 功能是否正确</li><li>8、删除 todo 功能是否正确</li></ul><h6 id="1-5-3-1、组件基础测试-浅层渲染（shallow）"><a href="#1-5-3-1、组件基础测试-浅层渲染（shallow）" class="headerlink" title="1.5.3.1、组件基础测试-浅层渲染（shallow）"></a>1.5.3.1、组件基础测试-浅层渲染（<strong>shallow</strong>）</h6><p>浅层渲染由于不与 dom 交互，并且不涉及到子组件，所以 1、2、3、4 测试点适合使用<strong>浅层渲染</strong>来测试</p><ul><li>App.jsx 的核心代码如下：</li></ul><pre><code class="jsx">&lt;div  style={{    display: 'flex',    flexDirection: 'column',    alignItems: 'center',    justifyContent: 'center'  }}&gt;  &lt;h1&gt;todo-list&lt;/h1&gt;  &lt;TodoList /&gt;  &lt;AddTodo /&gt;&lt;/div&gt;</code></pre><p>AddTodo.jsx 核心代码如下</p><pre><code class="jsx">&lt;div className=&quot;add-todo&quot;&gt;  &lt;input    className=&quot;add-input&quot;    type=&quot;text&quot;    placeholder=&quot;请输入&quot;    ref=&quot;todoTitle&quot;  /&gt;  &lt;button className=&quot;add-button&quot; onClick={this.addTodo.bind(this)}&gt;    添加一条todo  &lt;/button&gt;&lt;/div&gt;</code></pre><p>TodoItem.jsx 核心代码如下</p><pre><code class="jsx">&lt;li&gt;  &lt;span    className={`todo-text ${todoDone}`}    onClick={this.toggleDone.bind(this)}  &gt;    {todo.name}  &lt;/span&gt;  &lt;button className=&quot;delete&quot; onClick={this.deleteTodo.bind(this)}&gt;    {&#39; &#39;}    删除{&#39; &#39;}  &lt;/button&gt;&lt;/li&gt;</code></pre><p>于是根据以上组件的编写形式，测试用例代码如下</p><pre><code class="javascript">describe(&#39;判断标题是否正确&#39;, () =&gt; {  it(&#39;标题应该为 todo-list&#39;, () =&gt; {    let app = shallow(&lt;App /&gt;);    expect(app.find(&#39;h1&#39;).text()).to.equal(&#39;todo-list&#39;);  });});describe(&#39;添加todo按钮文本是否为 添加一条todo&#39;, () =&gt; {  it(&#39;按钮文本应该为 添加一条todo&#39;, () =&gt; {    let addTodo = shallow(&lt;AddTodo /&gt;);    expect(addTodo.find(&#39;.add-button&#39;).text()).to.equal(&#39;添加一条todo&#39;);  });});describe(&#39;判断输入框的提示是否为 请输入&#39;, () =&gt; {  it(&#39;提示文本应该为 请输入&#39;, () =&gt; {    let addTodo = shallow(&lt;AddTodo /&gt;);    let input = addTodo.find(&#39;input&#39;);    let placeholder = input.node.props.placeholder;    expect(placeholder).to.equal(&#39;请输入&#39;);  });});describe(&#39;删除todo按钮文本是否为 删除&#39;, () =&gt; {  it(&#39;按钮文本应该为 删除&#39;, () =&gt; {    let todoItem = shallow(&lt;TodoItem todo=&quot;测试&quot; done={false} /&gt;);    expect(      todoItem        .find(&#39;.delete&#39;)        .text()        .trim()    ).to.equal(&#39;删除&#39;);  });});</code></pre><p>测试结果如下</p><img src="https://ae01.alicdn.com/kf/Uf224558ae059484ebd4121f9ae964a041.png" srcset="/img/loading.gif"><h6 id="1-5-3-2、组件-render，渲染纯-HTML"><a href="#1-5-3-2、组件-render，渲染纯-HTML" class="headerlink" title="1.5.3.2、组件 render，渲染纯 HTML"></a>1.5.3.2、组件 render，渲染纯 HTML</h6><p>此方法会把组件渲染成一个 HTML 字符串，跟浅渲染很像，不同的是内部使用的是<a href="https://github.com/cheeriojs/cheerio#api" target="_blank" rel="noopener">Cheerio </a>库，接下来将使用这个方法进行测试点 5，核心测试代码如下：</p><pre><code class="javascript">describe(&#39;初始化数据为-&quot;第一条&quot;、&quot;第二条&quot;、&quot;第三条&quot;&#39;, function() {  it(&#39;应该没有一条数据的状态是完成的&#39;, function() {    let app = render(&lt;App /&gt;);    expect(app.find(&#39;.todo-done&#39;).length).to.equal(0);  });  it(&#39;应该有3条数据，并且分别为“第一条”，“第二条”，“第三条”&#39;, function() {    let value = [&#39;第一条&#39;, &#39;第二条&#39;, &#39;第三条&#39;].join(&#39;&#39;);    let app = render(&lt;App /&gt;);    let todoItems = app.find(&#39;.todo-item .todo-text&#39;);    let expectValue = todoItems.length === 3 &amp;&amp; value === todoItems.text();    expect(expectValue).to.equal(true);  });});</code></pre><p>测试结果如图</p><img src="https://ae01.alicdn.com/kf/Ufa4a59b00e6c4abba4bdcb26b4c6e940O.png" srcset="/img/loading.gif"><h6 id="1-5-3-3、组件深度渲染（mount）"><a href="#1-5-3-3、组件深度渲染（mount）" class="headerlink" title="1.5.3.3、组件深度渲染（mount）"></a>1.5.3.3、组件深度渲染（<strong>mount</strong>）</h6><p>对于按钮点击这类需要触发的测试，靠浅渲染和静态渲染（render）是无法进行测试，需要用到<strong>mount</strong>渲染才能进行测试，所以测试点 6、7、8 适合使用深度渲染来测，核心测试代码如下：</p><pre><code class="javascript">describe(&#39;测试添加功能是否正确&#39;, () =&gt; {  it(&#39;添加-todo-list的数组应该增加一个&#39;, () =&gt; {    let app = mount(&lt;App /&gt;);    let todoLength = app.find(&#39;li&#39;).length;    let addInput = app.find(&#39;.add-input&#39;).get(0);    addInput.value = &#39;测试&#39;;    app.find(&#39;.add-button&#39;).simulate(&#39;click&#39;);    expect(app.find(&#39;li&#39;).length).to.equal(todoLength + 1);  });  it(&#39;添加一条数据的内容应该等于输入框输入的内容&#39;, () =&gt; {    let app = mount(&lt;App /&gt;);    let value = &#39;增加一条todo&#39;;    let input = app.find(&#39;.add-input&#39;).get(0);    input.value = value;    app.find(&#39;.add-button&#39;).simulate(&#39;click&#39;); // 模拟点击    let todos = app.find(&#39;.todo-text&#39;);    let lastItem = todos.last();    expect(lastItem.text()).to.equal(value);  });});describe(&#39;测试删除按能是否正确&#39;, () =&gt; {  it(&#39;删除-todo-list的数组应该变少一个&#39;, () =&gt; {    let app = mount(&lt;App /&gt;);    let todoLength = app.find(&#39;li&#39;).length;    app      .find(&#39;button.delete&#39;)      .at(0)      .simulate(&#39;click&#39;);    expect(app.find(&#39;li&#39;).length).to.equal(todoLength - 1);  });});</code></pre><p>测试结果如下：</p><img src="https://ae01.alicdn.com/kf/U7d143a20ad224c0fab2b183d4f5746d9F.png" srcset="/img/loading.gif"><h6 id="1-5-3-4、-小结"><a href="#1-5-3-4、-小结" class="headerlink" title="1.5.3.4、 小结"></a>1.5.3.4、 小结</h6><p>根据上面的实际体验，由于框架和工具库提供的丰富 api 以致我们编写测试代码可以非常简单地实现需求，其代码量和复杂度也并不高。</p><h4 id="1-5-4、测试性能"><a href="#1-5-4、测试性能" class="headerlink" title="1.5.4、测试性能"></a>1.5.4、测试性能</h4><ul><li><p>当存在 1 个测试用例时，耗时为</p><img src="https://ae01.alicdn.com/kf/Ua6b83a9b02464b15846bb67fbfb32df9h.png" srcset="/img/loading.gif"></li><li><p>当存在 4 个测试用例时，耗时为</p><img src="https://ae01.alicdn.com/kf/U201a27b05ff042b8bb9c0dad39aacdb2S.png" srcset="/img/loading.gif"></li><li><p>把上面所实现的测试用例全部执行，耗时为</p><img src="https://ae01.alicdn.com/kf/U292ed6f4f71a464cac6b3ee819efd468i.png" srcset="/img/loading.gif"></li></ul><p>可以看出，测试用例的个数对测试速度的影响是不明显的，这里的时间变长主要是因为<strong>mount</strong>渲染的方式会导致 dom 加载，当撤去<strong>mount</strong>渲染的测试之后，耗时仅在<code>45ms</code></p><h4 id="1-5-5、小结"><a href="#1-5-5、小结" class="headerlink" title="1.5.5、小结"></a>1.5.5、小结</h4><h3 id="1-6、单元测试总结"><a href="#1-6、单元测试总结" class="headerlink" title="1.6、单元测试总结"></a>1.6、单元测试总结</h3><h4 id="1-6-1、进行单元测试的优势"><a href="#1-6-1、进行单元测试的优势" class="headerlink" title="1.6.1、进行单元测试的优势"></a>1.6.1、进行单元测试的优势</h4><ul><li>保证代码单元的质量</li><li>缩短后期开发人员<strong>自测时间</strong></li><li>提高项目的<strong>稳定性</strong>和<strong>健壮性</strong></li><li>不需要等到整个项目<strong>编写完成</strong>才测试，写一个单元就可以进行单元测试</li><li>快速反馈<strong>函数</strong>，<strong>组件</strong>，<strong>UI</strong>的正确性，并且判断是否符合业务需求</li></ul><h4 id="1-6-2、进行单元测试的弊端"><a href="#1-6-2、进行单元测试的弊端" class="headerlink" title="1.6.2、进行单元测试的弊端"></a>1.6.2、进行单元测试的弊端</h4><ul><li>因为单元测试的核心是<strong>独立</strong>，所以这也是它的不足，无法测试整体之间相互依赖的关系</li><li>前期需要投入更多<strong>时间</strong>来编写单元测试</li><li>编写单元测试的代码时需要更为<strong>小心谨慎</strong>，因为单元测试本身也可能存在 bug</li><li><strong>UI</strong>测试的复杂度会随着项目本身的复杂度变得越来越难以测试</li><li>为其一个单元编写的测试用例不止一个，这将增加开发<strong>时间</strong></li><li>往往测试代码会比项目代码<strong>更多</strong></li></ul><h4 id="1-6-3、单元测试结论"><a href="#1-6-3、单元测试结论" class="headerlink" title="1.6.3、单元测试结论"></a>1.6.3、单元测试结论</h4><p>根据以上测试和实际编写测试代码，可以得出两点</p><ul><li><p>在项目复杂相对<strong>比较低</strong>的时候，组件测试和函数测试均可以进行<strong>100%</strong>覆盖测试，这样带来的好处是极大保证了代码的<strong>可靠性</strong>和<strong>质量</strong>。</p></li><li><p>在项目复杂度比较<strong>高</strong>的情况下，函数测试进行<strong>100%</strong>覆盖测试，而组件测试在<strong>复杂度高</strong>的情况下测试代码将会<strong>迅速膨胀</strong>这个时候就<strong>不适合</strong>进行 100%覆盖测试了，可以挑选<strong>重要程度高</strong>的组件进行测试。</p></li></ul><p>综合以上两点，单元测试均是给项目提供了一道很好的屏障，保障代码<strong>可靠性</strong>、<strong>健壮性</strong>、<strong>低耦合性</strong>，对整体的项目是利大于弊的。</p><h2 id="二、UI-自动化测试"><a href="#二、UI-自动化测试" class="headerlink" title="二、UI 自动化测试"></a>二、UI 自动化测试</h2><p>UI 自动化测试的思路大致是将页面运行在无界浏览器（虚拟浏览器/无头浏览器），通过常规的 dom 操作模拟真实行为，生成当前场景的截图并且输出，然后进行人工校验。</p><h3 id="2-1、UI-自动化测试工具"><a href="#2-1、UI-自动化测试工具" class="headerlink" title="2.1、UI 自动化测试工具"></a>2.1、UI 自动化测试工具</h3><p>各个语言都有自己的虚拟浏览器实现，比较适合前端开发人员使用的就是<code>puppeteer</code>+<code>node</code>这套开发工具链来实现。</p><h3 id="2-2、测试载体介绍"><a href="#2-2、测试载体介绍" class="headerlink" title="2.2、测试载体介绍"></a>2.2、测试载体介绍</h3><p>项目原型是一个商城的 H5 端，层级关系如下</p><ul><li>登录页</li><li>首页</li><li>商品列表页 底部有两个导航按钮分别为 <strong>商品列表</strong>、<strong>订单列表</strong></li><li>商品详情页</li><li>确认订单页</li><li>订单列表页 底部有两个导航按钮分别为 <strong>商品列表</strong>、<strong>订单列表</strong></li></ul><h3 id="2-3、实际载体测试"><a href="#2-3、实际载体测试" class="headerlink" title="2.3、实际载体测试"></a>2.3、实际载体测试</h3><h4 id="2-3-1、测试点选取"><a href="#2-3-1、测试点选取" class="headerlink" title="2.3.1、测试点选取"></a>2.3.1、测试点选取</h4><ul><li>登录页<ul><li>不输入用户名点击登录</li><li>不输入密码点击登录</li><li>输入用户名和密码点击登录</li></ul></li><li>首页<ul><li>点击商品列表按钮</li><li>点击订单列表按钮</li></ul></li><li>商品列表页<ul><li>滚动列表</li><li>点击商品</li><li>点击底部商品列表按钮</li><li>点击底部订单列表按钮</li></ul></li><li>商品详情页<ul><li>点击确认订单</li></ul></li><li>确认订单页<ul><li>不输入收货人点击确认下单</li><li>输入收货人点击确认下单</li></ul></li><li>订单列表页<ul><li>点击商品列表按钮</li><li>点击订单列表按钮</li></ul></li></ul><h4 id="2-3-2、如何实现"><a href="#2-3-2、如何实现" class="headerlink" title="2.3.2、如何实现"></a>2.3.2、如何实现</h4><p>由于篇幅问题，以下展示部分代码，代码描述的是测试登录流程测试</p><pre><code class="javascript">async clickLogin ({ className, imgName }) {  const page = this.page  await page.reload()  let classList = [    &#39;.user .am-input-control input&#39;,    &#39;.pwd .am-input-control input&#39;,  ]  for (let cls of classList) {    if (cls.includes(className) || className == null) {      await page.focus(cls)      await page.keyboard.type(&#39;yun-xi&#39;)    }  }  await page.click(&#39;.login-btn&#39;)  await UiTest.screenImg(page, imgName, &#39;login&#39;)}async describeLogin () {  let classList = [    { className: &#39;user&#39;, imgName: &#39;不输入密码&#39; },    { className: &#39;pwd&#39;, imgName: &#39;不输入用户名&#39; },    { className: &#39;&#39;, imgName: &#39;输入用户名和密码&#39; },  ]  for (let cls of classList) {    await this.clickLogin(cls)  }}</code></pre><p>其他的流程也是类似实现方案。</p><h4 id="2-3-3、测试结果"><a href="#2-3-3、测试结果" class="headerlink" title="2.3.3、测试结果"></a>2.3.3、测试结果</h4><p>测试完成后会生成一系列图片，根据流程不同存在不同文件夹，如图所示</p><img src="https://ae01.alicdn.com/kf/U511ec549adc04cb780d401f3474602d6r.png" srcset="/img/loading.gif"><p>每个文件夹中包含其流程测试点的图片展示</p><img src="https://ae01.alicdn.com/kf/U30ccb2b656c6478a807a404091b10ae2x.png" srcset="/img/loading.gif"><p>具体的效果如图，截取登录流程-当用户不输入密码的情况下页面的反应</p><img src="https://ae01.alicdn.com/kf/U2a84f76c08f64a8ba2911586b65d5a45R.png" srcset="/img/loading.gif" width="300px"><h3 id="2-4、UI-自动测试总结"><a href="#2-4、UI-自动测试总结" class="headerlink" title="2.4、UI 自动测试总结"></a>2.4、UI 自动测试总结</h3><h4 id="2-4-1、进行-UI-自动测试的优势"><a href="#2-4-1、进行-UI-自动测试的优势" class="headerlink" title="2.4.1、进行 UI 自动测试的优势"></a>2.4.1、进行 UI 自动测试的优势</h4><ul><li>UI 可以很快速地校验并且反馈，<strong>缩短</strong>开发与 UI 之间的<strong>沟通时间</strong></li><li>开发人员对整体的流程把握<strong>更清晰</strong></li><li>测试流程<strong>一次编写多次运行</strong>，省去实际页面操作的<strong>时间</strong></li><li>在编写测试代码时可以发现一些开发时没有发现的问题，相当于是<strong>系统自测</strong></li><li>使用 mock 测试时，测试速度<strong>非常快</strong>远超人为测试，提高测试<strong>效率</strong></li></ul><h4 id="2-4-2、进行-UI-自动测试的缺点"><a href="#2-4-2、进行-UI-自动测试的缺点" class="headerlink" title="2.4.2、进行 UI 自动测试的缺点"></a>2.4.2、进行 UI 自动测试的缺点</h4><ul><li>当页面交互非常多的时候，编写测试用例的代码就会迅速膨胀（本测试载体的测试代码约 180 行）</li><li>连同接口一起测试的时候测试时间并不是很快，因为必须等待接口数据</li></ul><h4 id="2-4-3、关于-UI-自动测试的总结"><a href="#2-4-3、关于-UI-自动测试的总结" class="headerlink" title="2.4.3、关于 UI 自动测试的总结"></a>2.4.3、关于 UI 自动测试的总结</h4><p>根据以上实际测试和编写测试代码，可以得出 UI 自动化测试是利大于弊的，进行 UI 自动测试的时候实际上是对整体流程的深入理解，减少大部分的简单错误，同时也加快 UI 与开发之间的反馈时间（缩短了大量的人为操作页面时间）。</p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>根据以上所有实际使用与编写，单元测试在复杂项目下可以酌情<strong>减少</strong>组件测试的覆盖率，在<strong>复杂度低</strong>的项目里，进行 100%覆盖编写是<strong>极其有利</strong>的。UI 自动化测试在<strong>复杂度较低</strong>的项目下进行 100%覆盖是可以<strong>极大</strong>提高交稿质量和开发效率的，在项目<strong>复杂度比较高</strong>的情况下，可以挑选<strong>重要</strong>的页面进行测试。总而言之，根据测试结果本文认为进行单元测试和 UI 自动化测试都是<strong>利大于弊</strong>的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多端同构技术研究报告</title>
    <link href="undefined2019/10/21/%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%9E%84%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/"/>
    <url>2019/10/21/%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%9E%84%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="多端同构技术研究报告"><a href="#多端同构技术研究报告" class="headerlink" title="多端同构技术研究报告"></a>多端同构技术研究报告</h1><h2 id="一、技术背景"><a href="#一、技术背景" class="headerlink" title="一、技术背景"></a>一、技术背景</h2><p>最近几年来，整个前端领域发展的速度是史无前例的，效率型的前端框架也逐渐出现在世人面前，每个团队选择的技术解决方案都不尽相同，由于为互联网的特性及中国自身的独特性，各个产品对于多端的投放的需求是一致的。而像小程序这种跨端业务场景和现有的开发方式也不一样，为了满足业务的需求技术人员在日常开发中会因为投放平台的不一样而进行<strong>多套</strong>代码的维护，效率较<strong>低</strong>且成本也<strong>高</strong>。由此，为了更好地处理这种场景，跨端框架应景而生。</p><h2 id="二、项目背景"><a href="#二、项目背景" class="headerlink" title="二、项目背景"></a>二、项目背景</h2><p>现如今市面上端的形态百花齐放，H5、微信小程序、支付宝小程序等各种端大行其道，而这些端目前还处于“各自为政”的状态。</p><p>如果在不同的端都要求有所表现的时候，针对不同的端去编写多套代码，那么将导致面对同一个应用时开发、测试的工作量从 1 单位变成 N 单位，这样显然是极其耗费人力物力成本的。</p><p>面对这样的窘境，这时候如果可以只编写一套代码就能够适配到多端的能力对节约成本、项目推进、开发维护就极为重要了。换言之，我们需要一个编写一套代码即可在多端直接运行的框架，也这是本文研究的出发点。</p><h2 id="三、技术方案比较"><a href="#三、技术方案比较" class="headerlink" title="三、技术方案比较"></a>三、技术方案比较</h2><p>关于多端框架，市面上目前有很多，主要对知名度较为大、较为流行的框架来研究。分别是<code>chameleon</code>、<code>uni-app</code>、<code>Taro</code></p><h4 id="3-1、chameleon"><a href="#3-1、chameleon" class="headerlink" title="3.1、chameleon"></a>3.1、chameleon</h4><ul><li>chameleon 是有<strong>滴滴</strong>开源的一套多端同构技术方案。</li><li>github 的 start 数仅有<strong>5000+</strong>，由此可见，热度偏低。</li><li>技术栈采用类<strong>vue</strong>写法，支持 es6。</li><li>支持 css 预编译（sass、less、stylues）。</li><li>支持范围 移动端、H5、微信小程序、百度小程序、支付宝小程序。</li><li>官方的 demo 中，滚动列表的流畅度并不令人满意，所以该框架的<strong>性能偏弱</strong>。</li><li>官网并未提及成功案例。</li><li>从官方 isseus 来看，isseus 关闭速度并不理想，如图<img src="https://ae01.alicdn.com/kf/H00f14b430d5a48e0a49a7e7ba84f3b0cs.png" srcset="/img/loading.gif" alt="image-20190625164249296"></li></ul><h4 id="3-2、uni-app"><a href="#3-2、uni-app" class="headerlink" title="3.2、uni-app"></a>3.2、uni-app</h4><ul><li>uni-app 是 dcloud 推出的多端同构技术方案，核心代码不开源。</li><li>github 的 start 数 8000+，热度一般。</li><li>技术栈采用类<strong>vue</strong>写法，支持 es6。</li><li>支持 css 预编译（sass、less、stylues）。</li><li>支持范围 微信、百度、支付宝、今日头条等小程序，H5，以及 iOS 和 Android 的 App。</li><li>支持多端条件编译，可以为特定平台编写特定代码。</li><li>有专门的论坛，还有视频教程，QQ 群微信群都活跃。</li></ul><h4 id="3-3、Taro"><a href="#3-3、Taro" class="headerlink" title="3.3、Taro"></a>3.3、Taro</h4><ul><li>Taro 是由京东凹凸实验室团队推出的多端同构技术方案，开源。</li><li>github 的 start 数有近<strong>20000</strong>，由此可见，热度非常高。</li><li>技术栈采用<strong>React</strong>写法，支持 es6、es7、es8。</li><li>支持 css 预编译（sass、less、postcss）。</li><li>支持范围 微信、百度、支付宝、今日头条等小程序，H5，以及 iOS 和 Android 的 App。</li><li>支持多端条件编译，可以为特定平台编写特定代码、加载特定资源。</li><li>支持 Taro 代码与小程序代码混写，在极端情况下可以使用原生代码处理问题。</li><li>大量线上成功案例<ul><li>微信小程序：京东购物、京品百货、拼多多卷商等等</li><li>H5：猫眼电影、作业部落、时尚衣橱等等</li><li>支付宝小程序：时光简纸、爱享到</li><li>百度小程序：京东好物街、CSDN、启信宝等等</li></ul></li><li>文档详尽、api 多端公用性高。</li></ul><h4 id="3-4、小结"><a href="#3-4、小结" class="headerlink" title="3.4、小结"></a>3.4、小结</h4><p>基于上面对各个技术方案的分析与了解，综合从 github 维护热度、社区交流活跃性、开发团队背景、端的覆盖范围、生态环境来看，<strong>Taro</strong>是更为合适的技术方案。</p><h2 id="四、实际测试"><a href="#四、实际测试" class="headerlink" title="四、实际测试"></a>四、实际测试</h2><p>本次测试机型为 iphone5se 和小米 8</p><h5 id="测试-demo-介绍"><a href="#测试-demo-介绍" class="headerlink" title="测试 demo 介绍"></a>测试 demo 介绍</h5><p>本 demo 是仿照知乎发现页的一个长列表，具有功能为：点赞、展开折叠；样式方面：css3 动画 loading 动画、展开折叠的过度动画。如图所示</p><img src="https://ae01.alicdn.com/kf/Hddb74b11c39d47dcb839550d59aaf0c4V.png" srcset="/img/loading.gif" class="bm" width="300px"><h5 id="基础测试-包含样式测试、功能测试"><a href="#基础测试-包含样式测试、功能测试" class="headerlink" title="基础测试(包含样式测试、功能测试)"></a>基础测试(包含样式测试、功能测试)</h5><ul><li>苹果 5se-<strong>ios</strong><ul><li>微信小程序 <strong>样式</strong>:loaing 动画正常、展开折叠过度正常; <strong>功能方面</strong>:点赞正常、样式正常<ul><li><img src="https://ae01.alicdn.com/kf/Hec6bd9451f004941b56344547ebd8498D.gif" srcset="/img/loading.gif" class="bm" width="300px"></li></ul></li><li>支付宝小程序如图 <strong>样式</strong>:loaing 动画正常、展开折叠过度正常; <strong>功能方面</strong>:点赞正常、样式正常<ul><li><img src="https://ae01.alicdn.com/kf/Hf2629fdc8fee40c696d38492c4a8f28ad.gif" srcset="/img/loading.gif" class="bm" width="300px"></li></ul></li><li>h5 如图 <strong>样式</strong>:loaing 动画正常、展开折叠过度正常; <strong>功能方面</strong>:点赞正常、样式正常<ul><li><img src="https://ae01.alicdn.com/kf/Hf9e28e8132e946a38730ed90598b44a3g.gif" srcset="/img/loading.gif" class="bm" width="300px"></li></ul></li></ul></li><li>小米 8-<strong>安卓</strong><ul><li>微信小程序 <strong>样式</strong>:loaing 动画正常、展开折叠过度正常; <strong>功能方面</strong>:点赞正常、样式正常<ul><li><img src="https://ae01.alicdn.com/kf/H24b944e0dce043e68cf9c0ced9e2ff95t.gif" srcset="/img/loading.gif" class="bm" width="300px"></li></ul></li><li>支付宝小程序(由于本人手机问题无法测试)</li><li>H5 <strong>样式</strong>:loaing 动画正常、展开折叠过度正常; <strong>功能方面</strong>:点赞正常、样式正常<ul><li><img src="https://ae01.alicdn.com/kf/H172685b26d6e49e19e10fc7883b01c0bB.gif" srcset="/img/loading.gif" class="bm" width="300px"></li></ul></li></ul></li></ul><h5 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h5><p>采取长列表测试,不做任何优化的情况下观察多端的响应速度,</p><p>测试环境 h5 均使用系统自带浏览器进行测试;微信和支付宝小程序均使用各自平台下最新客户端.</p><p>测试对象为<strong>含有 100 条数据的长列表</strong>以及<strong>含有 500 条数据的长列表</strong>.</p><ul><li><p>苹果 5se-<strong>ios</strong>,左图为 100 条数据列表,右图为 500 条数据列表</p><ul><li><p>微信小程序</p><ul><li><img src="https://ae01.alicdn.com/kf/H3a663804689d4d0999d883e219cfb629p.gif" srcset="/img/loading.gif" width="250px"><img src="https://ae01.alicdn.com/kf/He2fcee0b3b874859b560ce3aa6b31f1b8.gif" srcset="/img/loading.gif" width="250px"></li></ul></li><li><p>支付宝小程序</p><ul><li><img src="https://ae01.alicdn.com/kf/H923b8fb9c7234fb591a2b8964610300dZ.gif" srcset="/img/loading.gif" width="300px"><img src="https://ae01.alicdn.com/kf/H181f87d30bb344c79bcec73dc63e96d5G.gif" srcset="/img/loading.gif" width="300px"></li></ul></li><li><p>h5</p><ul><li><img src="https://ae01.alicdn.com/kf/He1897565a96643a789a9734924d4e5d1Y.gif" srcset="/img/loading.gif" width="300px"><img src="https://ae01.alicdn.com/kf/Ha0afe436f07d42e6bea25633039c4934J.gif" srcset="/img/loading.gif" width="300px"></li></ul></li></ul></li><li><p>小米 8-<strong>安卓</strong></p><ul><li>微信小程序<ul><li><img src="https://images.weserv.nl/?url=https://img01.sogoucdn.com/app/a/100520146/8f9cf2e28600e42f0cb1a7cd3163b41f" srcset="/img/loading.gif" width="300px"><img src="https://ae01.alicdn.com/kf/H2f0c2d2098b945a78a6344eb73137deew.gif" srcset="/img/loading.gif" width="300px"></li></ul></li><li>支付宝小程序(由于手机问题,无法测试)</li><li>h5<ul><li><img src="https://ae01.alicdn.com/kf/H1b46f314d77b4e41acbef98c3e7eb7290.gif" srcset="/img/loading.gif" width="300px"><img src="https://images.weserv.nl/?url=https://img03.sogoucdn.com/app/a/100520146/1abf071380ba76bc5e8f8be8d9fe39f3" srcset="/img/loading.gif" width="300px"></li></ul></li></ul></li><li><p>测试小结</p><ul><li>当数据量为 100 条的时候,<strong>苹果 5se</strong>和<strong>小米 8</strong>三端的响应速度有在合理范围内</li><li>当数据量为 500 条的时候,支付宝、微信小程序的响应速度也在合理范围内,而 h5 端就开始了较为明显的卡顿,手指按下到响应有较为明显的延迟.</li><li>从测试结果看,同样的代码在不同端下的性能是有差异的<ul><li>在<strong>苹果 5se</strong>下 性能从高到低的顺序为 微信小程序&gt;支付宝小程序&gt;h5</li><li>在<strong>小米 8</strong>下性能高低的顺序为 h5&gt;微信小程序</li></ul></li></ul></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>优点<ul><li>性能优异</li><li>社区活跃</li><li>文档详尽</li><li>语法优雅</li><li>多端效果理想</li><li>上手成本低</li><li>编译速度快</li><li>可多端同时调试</li><li>工单响应速度快,平均 24 小时内就会有回复<img class="bm" src="https://ae01.alicdn.com/kf/H7dd32e5c32e44472b4c8d2c7a7a51052k.png" width="500px"></li><li>更新频率快,可以有效跟上小程序的更新<img class="bm" src="https://ae01.alicdn.com/kf/Hf2315b5370944b21970264c897e71594R.png" width="500px"></li><li>技术栈为<strong>React</strong>，市面上认可的热门框架</li></ul></li><li>缺点<ul><li>不能使用 Array.map 之外的方法操作 JSX 数组</li><li>不支持级联 css 选择器</li><li>不能使用 css 的<strong>*</strong>号选择器</li><li>同一套 css 代码在某些属性不指定的情况下,各端表现不一致,例如 width、height 不指定的话,在不同的端会有偏差.</li></ul></li></ul><p>基于以上优缺点以及测试结果,<strong>Taro</strong>是一个可以解决同业务不同端的多端同构技术方案,从性能、社区、研发团队、技术栈来看都是一个相对成熟的方案.</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>screen使用教程-无比简单</title>
    <link href="undefined2019/07/01/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%97%A0%E6%AF%94%E7%AE%80%E5%8D%95/"/>
    <url>2019/07/01/screen%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E6%97%A0%E6%AF%94%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h2><pre><code class="javaScript">创建：screen -S fuck查看有多少会话：screen -ls恢复：screen -r fuck删除 screen -S fuck -X quit</code></pre><h3 id="screen-r-fuck-失败"><a href="#screen-r-fuck-失败" class="headerlink" title="screen -r fuck 失败"></a>screen -r fuck 失败</h3><pre><code>如果不能恢复：先screen -d fuck,再screen -r fuck</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx的邻居caddy</title>
    <link href="undefined2019/07/01/nginx%E7%9A%84%E9%82%BB%E5%B1%85caddy/"/>
    <url>2019/07/01/nginx%E7%9A%84%E9%82%BB%E5%B1%85caddy/</url>
    
    <content type="html"><![CDATA[<p>本文不讲安装,只讲最简单的配置<br>每次配置更新完要 sudo pkill -USR1 caddy 刷新</p><h2 id="将静态文件映射到二级域名"><a href="#将静态文件映射到二级域名" class="headerlink" title="将静态文件映射到二级域名"></a>将静态文件映射到二级域名</h2><pre><code>你想在外网访问的网站地址 {  tls 你的破https证书  gzip  root  你的网站本地地址  index 首页 不填默认index的东西}</code></pre><h2 id="反代理"><a href="#反代理" class="headerlink" title="反代理"></a>反代理</h2><pre><code>你想在外网访问的网站地址 {  tls 你的破https证书  proxy / localhost:你想访问的破端口}</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>可以把几个文件合并拼接起来<br>例如</p><h3 id="a-conf"><a href="#a-conf" class="headerlink" title="a.conf"></a>a.conf</h3><pre><code>你的破配置</code></pre><h3 id="b-conf"><a href="#b-conf" class="headerlink" title="b.conf"></a>b.conf</h3><pre><code>import a.conf</code></pre><p>相当于把<strong>a.conf</strong>里的代码拷贝到<strong>b.conf</strong>里.没啥特别的</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM是什么？</title>
    <link href="undefined2019/05/17/ORM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>2019/05/17/ORM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="引用-阮一峰博客"><a href="#引用-阮一峰博客" class="headerlink" title="引用-阮一峰博客"></a>引用-<a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html" target="_blank" rel="noopener">阮一峰博客</a></h1><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><h3 id="字面意思"><a href="#字面意思" class="headerlink" title="字面意思"></a>字面意思</h3><p>实际上就是个缩写，表示对象-关系映射的缩写</p><ul><li><code>O</code>-&gt;<strong>Object</strong></li><li><code>RM</code>-&gt;<strong>Relational</strong> (关系) <strong>Mapping(映射)</strong></li></ul><h3 id="代表什么思想"><a href="#代表什么思想" class="headerlink" title="代表什么思想"></a>代表什么思想</h3><p>实际上就是一种把数据库映射成对象的想法</p><ul><li>数据库的表（<code>table</code>） –&gt; 类（<code>class</code>）</li><li>记录（<code>record</code>，行数据）–&gt; 对象（<code>object</code>）</li><li>字段（<code>field</code>）–&gt; 对象的属性（<code>attribute</code>）</li></ul><p><strong>比如说查询语句 <code>SELECT id, first_name, last_name, phone, birth_date, sex FROM persons WHERE id = 10</code></strong></p><p>对应到代码就是</p><pre><code class="c#">res = db.执行数据库(sql);name = res[0][&quot;FIRST_NAME&quot;];</code></pre><p>那么<strong>ORM</strong>的写法就是</p><pre><code class="c#">p = Person.get(10);name = p.first_name;</code></pre><p>这样的好处就是可以不需要了解数据库底层，因为它不需要接触<code>SQL</code>语句</p><p>所以<code>ORM</code>有这样一些优点</p><ul><li><code>ORM</code>生态已经比较完备，有很多的工具支持</li><li>天生的<code>MVC</code>，<code>ORM</code>就是天生的<code>Model</code></li><li>可以不写<code>SQL</code>了。</li></ul><p>它的缺点来说：</p><ul><li>复杂查询很难做到，做到了性能也很差</li><li>学习成本比较高</li><li>由于不需要接触<code>SQL</code>所以无法定制一些特殊的<code>SQL</code></li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>目前公认最规范的是 Ruby 语言的 <a href="https://guides.rubyonrails.org/active_record_basics.html" target="_blank" rel="noopener">Active Record</a>。Active Record 对于对象和数据库表的映射，有一些命名限制。</p><p>（1）一个类对应一张表。类名是单数，且首字母大写；表名是复数，且全部是小写。比如，表 <code>books</code> 对应类 <code>Book</code>。</p><p>（2）如果名字是不规则复数，则类名依照英语习惯命名，比如，表 <code>mice</code> 对应类 <code>Mouse</code>，表 <code>people</code> 对应类 <code>Person</code>。</p><p>（3）如果名字包含多个单词，那么类名使用首字母全部大写的骆驼拼写法，而表名使用下划线分隔的小写单词。比如，表 <code>book_clubs</code> 对应类 <code>BookClub</code>，表 <code>line_items</code> 对应类 <code>LineItem</code>。</p><p>（4）每个表都必须有一个主键字段，通常是叫做 <code>id</code> 的整数字段。外键字段名约定为单数的表名 + 下划线 + id，比如 <code>item_id</code> 表示该字段对应 <code>items</code> 表的 <code>id</code> 字段。</p><h2 id="示例库-OpenRecord"><a href="#示例库-OpenRecord" class="headerlink" title="示例库 OpenRecord"></a>示例库 <a href="https://github.com/PhilWaldmann/openrecord" target="_blank" rel="noopener">OpenRecord</a></h2><p><code>OpenRecord</code> 是仿 <code>Active Record</code> 的，将其移植到了 <code>JavaScript</code>，而且实现得很轻量级，学习成本较低。我写了一个<a href="https://github.com/ruanyf/openrecord-demos" target="_blank" rel="noopener">示例库</a>，请将它克隆到本地。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>使用 ORM 的第一步，就是你必须告诉它，怎么连接数据库（<a href="https://github.com/ruanyf/openrecord-demos/blob/master/demos/demo01.js" target="_blank" rel="noopener">完整代码</a>看这里）。</p><blockquote><pre><code class="javascript">// demo01.jsconst Store = require(&#39;openrecord/store/sqlite3&#39;)const store = new Store({    type: &#39;sqlite3&#39;,    file: &#39;./db/sample.db&#39;,    autoLoad: true,})await store.connect()</code></pre></blockquote><p>连接成功以后，就可以操作数据库了。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>没啥好说的，就是<strong>ORM</strong>的框架会把表转成类对象</p><h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p>也没什么好说的，增删改查都从查询语句变成了调用方法</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>表与表之间的关系（relation），分成三种。</p><blockquote><ul><li><strong>一对一</strong>（one-to-one）：一种对象与另一种对象是一一对应关系，比如一个学生只能在一个班级。</li><li><strong>一对多</strong>（one-to-many）： 一种对象可以属于另一种对象的多个实例，比如一张唱片包含多首歌。</li><li><strong>多对多</strong>（many-to-many）：两种对象彼此都是 “一对多” 关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片。</li></ul></blockquote><p>了解到这就足够用了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可能是全x最好的vue教程</title>
    <link href="undefined2018/07/12/vue%E6%95%99%E7%A8%8B/"/>
    <url>2018/07/12/vue%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h1><h2 id="为什么不支持-IE8"><a href="#为什么不支持-IE8" class="headerlink" title="为什么不支持 IE8"></a>为什么不支持 IE8</h2><p>其实是依赖<strong>Object.defineProperty()</strong>，进行数据挟持的，而这个 api 在 IE8 下仅仅支持 Dom 对象不支持原生对象，所以 Vue2.x 是不支持 IE8 及以下的浏览器。</p><h2 id="Object-defineProperty-object-propertyname-descriptor"><a href="#Object-defineProperty-object-propertyname-descriptor" class="headerlink" title="Object.defineProperty(object, propertyname, descriptor )"></a>Object.defineProperty(object, propertyname, descriptor )</h2><p>此函数有 3 个参数，均是必传的参数。这个函数的特性其实很像 c#的属性，有 c#基础的理解起来应该很容易。</p><ul><li><p>object：需要设置的对象</p></li><li><p>propertyname：需要设置的属性名（对象的键名）</p></li><li><p>descriptor：描述符，一个对象，用于设置属性的特性。</p><pre><code class="javascript">{    value:undefined, // 表示此属性的值。    writable:false, // 决定此属性是否可写    configurable:true,        /*        决定此属性是否可配置，        如果为false则writable, configurable, enumerable这些属性的设置都将无效.        即使重新调用defineProperty函数也无效。        特别指出 试图修改configurable的值会抛出异常。        */    enumerable:false, // 是否可枚举    get:undefined, // 函数，当取值时执行    set:undefined, // 函数，当设置值时执行}</code></pre><pre><code class="javascript">// 此demo示范get和set的作用，其他的属性自行尝试。const setName = function(newValue) {  console.log(&#39;新的值&#39;, newValue);};const getName = function() {  console.log(&#39;取值啦&#39;);};var demo = {  name: &#39;初始值&#39;};Object.defineProperty(demo, &#39;name&#39;, {  set: setName,  get: getName});demo.name = &#39;初始值2&#39;;// -&gt; 新的值 初始值2let name = demo.name;// -&gt; 取值啦</code></pre></li></ul><h2 id="Vue-cli3-0-一些变动"><a href="#Vue-cli3-0-一些变动" class="headerlink" title="Vue-cli3.0 一些变动"></a>Vue-cli3.0 一些变动</h2><ul><li>集成 sass/scss 只需要 <code>yarn add sass-loader node-sass</code></li><li>设置 scss 全局函数要在<code>vue.config.js</code>里添加</li></ul><pre><code>module.exports = {  // ...  css: {    loaderOptions: {      sass: {        data: `          @import &quot;@/你的全局scss文件&quot;;        `      }    }  }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端架构-vue-初次学习</title>
    <link href="undefined2018/05/30/web%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    <url>2018/05/30/web%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h2 id="整体框架：vue2-x"><a href="#整体框架：vue2-x" class="headerlink" title="整体框架：vue2.x"></a>整体框架：vue2.x</h2><h3 id="为什么选择-Vue"><a href="#为什么选择-Vue" class="headerlink" title="为什么选择 Vue"></a>为什么选择 Vue</h3><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ul><li>具有热更新功能，代码变更保存即可看到效果，对提高调试与开发的效率有很大帮助。</li><li>社区资源丰富，大部分的问题均可查找得到合理的解决方案。</li><li>语法简洁。</li><li>Api 友好。</li><li>Github 维护热度高，大量高质量程序员都参与其中。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li>Bilibili、简书、饿了么、掘金、搜狐手机版、UC 奇趣百科等知名网站都在使用 Vue</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>不输给目前其他流行框架 如 ReactJs，AngularJS</li><li>原生渲染</li><li>自动按需加载组件，ReactJs 暂时不能做到自动按需加载。</li></ul><h4 id="自身优势"><a href="#自身优势" class="headerlink" title="自身优势"></a>自身优势</h4><ul><li>高度模块化。</li><li>维护简单。</li><li>数据双向绑定，跨组件强制单向数据流。</li></ul><h2 id="UI-库"><a href="#UI-库" class="headerlink" title="UI 库"></a>UI 库</h2><p>后期有需求会增加别的 ui 库</p><ul><li><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">ElementUi</a></li><li><a href="https://chenz24.github.io/vue-blu/#/" target="_blank" rel="noopener">Vue blu</a></li></ul><h2 id="网络请求框架"><a href="#网络请求框架" class="headerlink" title="网络请求框架"></a>网络请求框架</h2><ul><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a><pre><code>使用范例axios    .get(&#39;rul&#39;)    .then(response =&gt; (this.info = response))</code></pre></li></ul><h2 id="工具链："><a href="#工具链：" class="headerlink" title="工具链："></a>工具链：</h2><ul><li><a href="https://yarnpkg.com/lang/en/" target="_blank" rel="noopener">yarn</a>：快速、可靠、安全的依赖管理，npm 的升级版。</li><li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>：是 JavaScript 世界的包管理器，大部分的 JS 开发者会在这里发布他们的库。</li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack</a>：前端构建工具，用与打包压缩混淆前端代码。</li><li><a href="http://eslint.cn/" target="_blank" rel="noopener">Eslint</a>：静态代码检查器，用于规范开发编码习惯。</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ul><li>组件内部双向绑定</li><li>子组件与父组件单向绑定</li></ul><h2 id="设计模式：Mvvm"><a href="#设计模式：Mvvm" class="headerlink" title="设计模式：Mvvm"></a>设计模式：Mvvm</h2><ul><li>为了让页面与页面逻辑分离。</li><li>降低耦合度。</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/5692364-6ccaecf3481d7dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><ul><li>node_modules：存放 npm 下载的包，所有第三方的库都会存放在这里。</li><li>Page：用于存放页面<ul><li>View：具体的页面样式与 html 结构。<ul><li>Css：控制页面的样式。</li><li>Html：控制页面的 Dom 树。</li></ul></li><li>Model：每个页面所需要的数据结构。</li><li>ViewModel：页面的 VM，负责具体业务并且让 View 与 Model 交互。</li></ul></li><li>Components：用于存放单个组件。<ul><li>ControlComponents：控制类组件，具有可操作的能力，例如操纵 Dom，可以存储输入状态如日期选择器。</li><li>ViewComponents：展示类组件，不具有操作的能力，不存储非 UI 的状态，不直接修改外部环境。</li><li>ContainerComponents：容器类组件 如卡片。</li></ul></li><li>router<ul><li>设置页面的路由</li></ul></li></ul><h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><ul><li>扩展 js<br><img src="https://upload-images.jianshu.io/upload_images/5692364-ea55f8bca6e4a162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="公共js.png"></li></ul><h3 id="控制类组件"><a href="#控制类组件" class="headerlink" title="控制类组件"></a>控制类组件</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-0f1828413f3d6554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="控制类组件构建.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5692364-519efa270d13e96f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="控制类组件.png"></p><ul><li>展示类组件<br><img src="https://upload-images.jianshu.io/upload_images/5692364-1306b65112c7c634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="展示类组件结构.png"></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5692364-e73c2b538b813cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="展示类组件.png"></p><ul><li>容器类组件<br><img src="https://upload-images.jianshu.io/upload_images/5692364-b16163ce1f818544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="容器类组件.png"></li></ul><h2 id="页面构建结构"><a href="#页面构建结构" class="headerlink" title="页面构建结构"></a>页面构建结构</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-01b499bb6f636217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="页面结构.png"></p><h4 id="首页（例子）"><a href="#首页（例子）" class="headerlink" title="首页（例子）"></a>首页（例子）</h4><p><img src="https://upload-images.jianshu.io/upload_images/5692364-0ee0f6ea4cef58ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="首页结构.png"></p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>一个页面由多个组件组建而成，ViewModel 控制组件交互，并且负责具体业务。</p><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5692364-7d83c04898cd2cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="页面结构.png"></p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><ul><li>组件不能含有具体业务逻辑。</li><li>展示类组件应只允许输入数据。</li><li>控制类组件要暴露回调函数给外部组件控制，并且隐藏不必要的细节。</li><li><code>View</code> 与 <code>Model</code> 的交互必须通过 <code>ViewModel</code></li><li>凡是可复用的函数或者组件都必须抽象封装出来。</li><li>不许对 api 请求 try catch，应该判断状态码做相应的事情。</li><li>尽量使用 <code>let</code> 和 <code>const</code> 声明变量名。</li><li>禁止使用 <code>eval</code> 函数</li><li>禁止使用 <code>NaN</code>，要用 <code>isNaN()</code></li><li>变量命名要尽量易懂，不容易懂的应加上注释</li><li>函数用小驼峰命名，</li><li>组件命名遵循：“my-component”，且使用小驼峰。</li><li><code>class</code> 命名大驼峰。</li><li>变量名 小驼峰。</li><li><code>HTML、CSS、Vue</code> 文件需要同名并且命名需要是名词。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读黑客与画家有感</title>
    <link href="undefined2018/05/13/%E8%AF%BB%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E6%9C%89%E6%84%9F/"/>
    <url>2018/05/13/%E8%AF%BB%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>前几天一口气读完了黑客与画家，留下点感悟。</p><h2 id="书呆子不受欢迎的原因"><a href="#书呆子不受欢迎的原因" class="headerlink" title="书呆子不受欢迎的原因"></a>书呆子不受欢迎的原因</h2><p>学校是个特殊的地方，它是人为设计出来的，一半像无菌室，一半像野蛮之地。它就像人生一样，无所不包，却又不是事情的真相。它只是一个短暂的过程，只要你向前看，就能超越它，即使你身在其中。</p><ul><li>受欢迎是要付出精力的，他们更愿意把精力放在变得更优秀上。</li><li>欺负书呆子的原因可能是为了自己不被孤立。</li><li>特别受欢迎的人很少去欺负特别不受欢迎的人。</li></ul><h2 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h2><h3 id="黑客真正想做的是设计优美的软件"><a href="#黑客真正想做的是设计优美的软件" class="headerlink" title="黑客真正想做的是设计优美的软件"></a>黑客真正想做的是设计优美的软件</h3><ul><li>大公司里设计软件的职责是技工，翻译产品经历的“构想”成代码</li><li>想战胜大公司的方法是将设计权交给黑客</li><li>编程跟绘画很像，不要一开始就追求完美的软件；起个草案，逐步修改</li></ul><h2 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h2><p>不能说的话，社会中总有些话好像是不能说出来的，政治不正确的话就是其中一类。</p><h3 id="找出不能说的话"><a href="#找出不能说的话" class="headerlink" title="找出不能说的话"></a>找出不能说的话</h3><ul><li>与历史对比，看看哪些以前可以说现在不能说，或者反之。</li><li>想想有什么话是你不敢在大众面前说的。</li><li>看看那些卫道者到底在捍卫什么。</li><li>观察禁忌是如何产生的，来龙去脉是什么。</li><li>那些所谓的异端邪说，被冠上有伤风化之类的帽子的话。</li></ul><h3 id="为什么要找不能说的话？"><a href="#为什么要找不能说的话？" class="headerlink" title="为什么要找不能说的话？"></a>为什么要找不能说的话？</h3><ul><li>好奇心，纯粹的好奇。</li><li>没有什么东西是不应该思考就有答案的。</li></ul><h3 id="发现了不能说的话之后怎么办？"><a href="#发现了不能说的话之后怎么办？" class="headerlink" title="发现了不能说的话之后怎么办？"></a>发现了不能说的话之后怎么办？</h3><p>闭嘴，别说。</p><h2 id="创造财富的最好的方法就是创业"><a href="#创造财富的最好的方法就是创业" class="headerlink" title="创造财富的最好的方法就是创业"></a>创造财富的最好的方法就是创业</h2><ul><li>可测量性：你的职位必须是可测量的，不然做再多也没有更多报酬。</li><li>可放大性：你的决定必须能够产生巨大效应。</li></ul><h2 id="防止垃圾邮件的一种方法"><a href="#防止垃圾邮件的一种方法" class="headerlink" title="防止垃圾邮件的一种方法"></a>防止垃圾邮件的一种方法</h2><ul><li>对单词做<a href="https://www.jianshu.com/p/5e8d7984e629" target="_blank" rel="noopener">贝叶斯判断</a></li></ul><h2 id="研究和设计的区别"><a href="#研究和设计的区别" class="headerlink" title="研究和设计的区别"></a>研究和设计的区别</h2><p>研究必须是新的，而设计必须是“好”的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机杂锦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack-简易</title>
    <link href="undefined2018/05/09/webpack%E6%95%99%E7%A8%8B/"/>
    <url>2018/05/09/webpack%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ul><li>安装 node.js npm</li><li>安装 webpack npm install webpack -g</li><li>进入项目目录 是否有<code>package.json</code>没有就通过<code>npm init</code>创建</li><li>在项目目录下命令行执行<code>npm install webpack --save-dev</code></li><li>创建<code>webpack.config.js</code>文件,下面是例子</li></ul><pre><code>const path = require(&#39;path&#39;)module.exports = {  entry: &#39;./js/main.js&#39;, // 代码输入文件  // 下面的文件夹和文件不需要自己创建  output: {    path: path.resolve(__dirname, &#39;./dist&#39;), // 代码输入文件夹    filename: &#39;build.js&#39;  }}</code></pre><ul><li><p>在 package.json 文件</p><ul><li>在 scripts 下加<code>&quot;start&quot;: &quot;webpack&quot;</code></li></ul></li><li><p>命令行 npm start</p></li><li><p>其他的文件写法</p></li></ul><p><code>app.js</code></p><pre><code>const Say = require(&#39;./to.js&#39;)……Say()</code></pre><p><code>to.js</code></p><pre><code>var Say = function () {    console.log(&#39;hello&#39;)}module.exports = Say</code></pre><ul><li>导入 jq 等插件的方式<code>npm install jquery --save-dev</code></li></ul><pre><code>var $ = require(&#39;jquery&#39;)</code></pre><ul><li>运行<br>命令行敲 <code>webpack --mode production</code><br>如果想实时刷新<code>webpack --mode production --watch</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈依赖注入</title>
    <link href="undefined2018/05/09/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>2018/05/09/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖注入个人见解"><a href="#依赖注入个人见解" class="headerlink" title="依赖注入个人见解"></a>依赖注入个人见解</h1><p>当笔记用，勿喷。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>我不想因为我的依赖变化导致每次我都要改造自己</li><li>我不想再控制我的依赖了</li><li>我不关心我在依赖谁，我只想使用依赖的功能而已</li></ul><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>依赖注入跟控制反转是一起出现的，首先就要理解什么叫依赖注入，什么叫控制反转。</p><ul><li>依赖注入：将依赖用注入的方式送给你。</li><li>控制反转：本来依赖由你来控制，现在你不控制它了，随便丢给某人控制，这叫控制反转。</li></ul><p>举个例子：</p><ul><li>依赖注入：你家里有上千台手机，每天你都要用手机看直播，你只想看直播，并不关心什么手机，然后每天管家都会去挑选一个合适的手机塞给你，这个<code>管家塞给你</code>的过程就叫依赖注入。</li><li>控制反转：本来这个手机是由你来控制用什么手机的，现在你不关心它了，丢给管家处理，这个管理权的变化就叫控制反转。</li></ul><p>一个很精彩的例子<br><code>假设你自己是一个“口”字，你的需求是变成一个别的字，这时候如果传一个“人”，就变成了“囚”；如果传入“十”，就变成了“田”；如果传入“木”就变成了“困”</code></p><p>依赖抽象而不依赖具体</p><p>控制反转是一种思想，实现控制反转的技术手段就是依赖注入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机杂锦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现懒加载和瀑布流</title>
    <link href="undefined2018/01/10/%E7%80%91%E5%B8%83%E6%B5%81/"/>
    <url>2018/01/10/%E7%80%91%E5%B8%83%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="懒加载与瀑布流结合"><a href="#懒加载与瀑布流结合" class="headerlink" title="懒加载与瀑布流结合"></a>懒加载与瀑布流结合</h1><p><a href="https://lazy.dashao.me" target="_blank" rel="noopener">演示地址</a></p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><ul><li>使用了语义化的 html 使得代码更可读，利用了部分 html5 特性。</li><li>大量使用 es6 语法使得代码更简洁</li><li>支持响应式和媒体查询</li></ul><h2 id="GitHub-地址-大家多多支持～"><a href="#GitHub-地址-大家多多支持～" class="headerlink" title="GitHub 地址 大家多多支持～"></a><a href="https://github.com/chendss/WaterfallLazyLoading" target="_blank" rel="noopener">GitHub 地址</a> 大家多多支持～</h2><p><img src="http://upload-images.jianshu.io/upload_images/5692364-63bd3df17e2da54c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="loading.gif"></p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-08c776512cd93d40.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="lazy.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>个人项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2048小游戏javascript实现</title>
    <link href="undefined2018/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8Fjavascript%E5%AE%9E%E7%8E%B0/"/>
    <url>2018/01/02/2048%E5%B0%8F%E6%B8%B8%E6%88%8Fjavascript%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="原生-js-实现-2048-小游戏"><a href="#原生-js-实现-2048-小游戏" class="headerlink" title="原生 js 实现 2048 小游戏"></a>原生 js 实现 2048 小游戏</h1><p><a href="https://github.com/chendss/2048" target="_blank" rel="noopener">GitHub 地址</a> ，希望大家多多捧场觉得还可以就给个 star 吧～</p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><ul><li>利用了 css3 实现动画效果</li><li>使用了语义化的 html 使得代码更可读，利用了部分 html5 特性。</li><li>纯原生的 javascript 代码操控 DOM 控制元素组件</li><li>大量使用 es6 语法使得代码更简洁</li></ul><h2 id="试玩地址"><a href="#试玩地址" class="headerlink" title="试玩地址"></a>试玩地址</h2><p><a href="https://2048.dashao.me" target="_blank" rel="noopener">2048</a></p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/5692364-f61ba16480e4202b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="gif.gif"><br><img src="http://upload-images.jianshu.io/upload_images/5692364-dd1072566a35798c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="start.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-e2a41c6b1edea24b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="end.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>个人项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-native-update 热更新插件翻译</title>
    <link href="undefined2017/10/18/react-native-update%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%E7%BF%BB%E8%AF%91/"/>
    <url>2017/10/18/react-native-update%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="原文地址：https-github-com-remobile-react-native-update"><a href="#原文地址：https-github-com-remobile-react-native-update" class="headerlink" title="原文地址：https://github.com/remobile/react-native-update"></a>原文地址：<a href="https://github.com/remobile/react-native-update" target="_blank" rel="noopener">https://github.com/remobile/react-native-update</a></h1><h1 id="React-Native-更新-remobile"><a href="#React-Native-更新-remobile" class="headerlink" title="React Native 更新 (remobile)"></a>React Native 更新 (remobile)</h1><p>更新 js 版本和 app 版本</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="sh">npm install @remobile/react-native-update --save</code></pre><h3 id="安装-Android"><a href="#安装-Android" class="headerlink" title="安装 (Android)"></a>安装 (Android)</h3><pre><code class="gradle">...include &#39;:react-native-update&#39;project(&#39;:react-native-update&#39;).projectDir= new File(settingsDir, &#39;../node_modules/@remobile/react-native-update/android&#39;)</code></pre><ul><li>在 <code>android/app/build.gradle</code></li></ul><pre><code class="gradle">...dependencies {    ...    compile project(&#39;:react-native-update&#39;)}</code></pre><ul><li>注册模块 (在 MainActivity.java)</li></ul><pre><code class="java">......import com.remobile.update.RCTUpdateMgr;  // &lt;--- import......public class MainApplication extends Application implements ReactApplication {    private RCTUpdateMgr mUpdateMgr; // &lt;------ add here    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {        ......        @Override        protected String getJSBundleFile() {            return mUpdateMgr.getBundleUrl();   // &lt;------ change here        }        @Override        protected List&lt;ReactPackage&gt; getPackages() {            mUpdateMgr = new RCTUpdateMgr(MainActivity.activity);            return Arrays.&lt;ReactPackage&gt;asList(            ......            mUpdateMgr.getReactPackage(),       // &lt;------ add here            ......            );        }    };    ......}</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="UpdatePage-js"><a href="#UpdatePage-js" class="headerlink" title="UpdatePage.js"></a>UpdatePage.js</h4><h5 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h5><pre><code class="js">&#39;use strict&#39;;import React, { Component } from &#39;react&#39;;import {  View,  StyleSheet,  Platform,  Text,  Image,  TouchableHighlight} from &#39;react-native&#39;;import ReactNative form &#39;react-native&#39;import Update form &#39;@remobile/react-native-update&#39;varSTATUS_GET_VERSION = 0, // 获得版本号状态STATUS_HAS_VEW_VERSION = 1, // 有新版本状态STATUS_HAS_NOT_VEW_VERSION = 2, // 没有新版本号状态STATUS_DOWNLOAD_APK_PROGESS = 3, // 下载apk状态STATUS_DOWNLOAD_JS_PROGESS = 4, // 下载js状态STATUS_UNZIP_JS_PROGESS = 5, // 解压js状态STATUS_GET_VERSION_ERROR = 6, // 获得版本异常状态STATUS_DOWNKOAD_APK_ERROR = 7, // 下载apk异常状态STATUS_DOWNKOAD_JS_ERROR = 8, // 下载js异常状态STATUS_UNZIP_JS_ERROR = 9, // 解压js异常状态STATUS_FAILED_INSTALL_ERROR = 10,  //失败安装异常状态STATUS_UPDATE_END = 11; //更新结束状态varERROR_NULL = 0,ERROR_DOWNKOAD_APK = 1, // 异常下载apkERROR_DOWNKOAD_JS = 2, // 异常下载jsERROR_FAILED_INSTALL = 3, // 失败安装ERROR_UNZIP_JS = 4; // 解压jsvar PROGRESS_WIDTH = sr.tw*0.7;var {Button, ProgressBar} = COMPONENTS;</code></pre><h5 id="进度-view"><a href="#进度-view" class="headerlink" title="进度 view"></a>进度 view</h5><pre><code>var ProgressInfo = React.createClass({    render() {        const { progress } = this.props;        if (progress &lt; 1000) {            return (                &lt;View&gt;                    &lt;Text&gt;{this.props.title} [{progress}%]&lt;/Text&gt;                    &lt;ProgressBar                        fillStyle={{}}                        backgroundStyle={{backgroundColor: '#cccccc', borderRadius: 2}}                        style={{marginTop: 10, width:PROGRESS_WIDTH}}                        progress={progress/100.0}                        /&gt;                    &lt;View style={styles.progressText}&gt;                        &lt;Text&gt;0&lt;/Text&gt;                        &lt;Text&gt;100&lt;/Text&gt;                    &lt;/View&gt;                &lt;/View&gt;            );        } else {            let size = progress/1000/1024/1024;            return (                &lt;View style={{flex: 1, alignItems: 'center'}}&gt;                    &lt;Text&gt;{this.props.title} [{size.toFixed(2)} M]&lt;/Text&gt;                &lt;/View&gt;            );        }    }});</code></pre><h5 id="页面显示-view"><a href="#页面显示-view" class="headerlink" title="页面显示 view"></a>页面显示 view</h5><h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6><pre><code>module.exports = React.createClass({    getInitialState() {        const {options} = this.props;        return {            options,            status: !options ?            STATUS_GET_VERSION : options.newVersion ? STATUS_HAS_VEW_VERSION : STATUS_HAS_NOT_VEW_VERSION,            progress: 0,        };    },    componentWillMount() {        if (!this.state.options) {            Update.checkVersion({                versionUrl: app.route.ROUTE_VERSION_INFO_URL,                iosAppId: CONSTANTS.IOS_APPID,            }).then((options)=&gt;{                this.setState({options, status: !options ?                STATUS_GET_VERSION_ERROR : options.newVersion ?                STATUS_HAS_VEW_VERSION : STATUS_HAS_NOT_VEW_VERSION});            })        }    },    onError(errCode) {        if (errCode == ERROR_DOWNKOAD_APK) {            this.setState({status: STATUS_DOWNKOAD_APK_ERROR});        } else if (errCode == ERROR_DOWNKOAD_JS) {            this.setState({status: STATUS_DOWNKOAD_JS_ERROR});        } else if (errCode == ERROR_FAILED_INSTALL) {            this.setState({status: STATUS_FAILED_INSTALL_ERROR});        } else if (errCode == ERROR_UNZIP_JS) {            this.setState({status: STATUS_UNZIP_JS_ERROR});        }    },    doUpdate() {        const {jsVersionCode, trackViewUrl} = this.state.options;        if (jsVersionCode !== undefined) {            Update.updateJS({                jsVersionCode,                jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,                onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},                onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},                onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        } else {            Update.updateApp({                trackViewUrl,                androidApkUrl:app.route.ROUTE_APK_URL,                androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,                onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        }    },</code></pre><h6 id="页面的-render"><a href="#页面的-render" class="headerlink" title="页面的 render"></a>页面的 render</h6><pre><code>    render() {        var components = {};        const {          currentVersion,          newVersion,          description        } = this.state.options||{currentVersion:Update.getVersion()};        components[STATUS_GET_VERSION] = (            &lt;Text style={styles.textInfo}&gt;正在获取版本号&lt;/Text&gt;        );        components[STATUS_HAS_NOT_VEW_VERSION] = (            &lt;Text style={styles.textInfo}&gt;当前版本已经是最新版本&lt;/Text&gt;        );        components[STATUS_GET_VERSION_ERROR] = (            &lt;Text style={styles.textInfo}&gt;获取版本信息失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_DOWNKOAD_APK_ERROR] = (            &lt;Text style={styles.textInfo}&gt;下载apk文件失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_DOWNKOAD_JS_ERROR] = (            &lt;Text style={styles.textInfo}&gt;下载js bundle失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_UNZIP_JS_ERROR] = (            &lt;Text style={styles.textInfo}&gt;解压js bundle失败，请稍后再试&lt;/Text&gt;        );        components[STATUS_FAILED_INSTALL_ERROR] = (            &lt;Text style={styles.textInfo}&gt;你放弃了安装&lt;/Text&gt;        );        components[STATUS_HAS_VEW_VERSION] = (            &lt;View style={styles.textInfoContainer}&gt;                &lt;Text style={styles.textInfo}&gt;发现新版本{newVersion}&lt;/Text&gt;                &lt;View style={styles.descriptionContainer}&gt;                    {                        description &amp;&amp; description.map((item, i)=&gt;{                            return (                                &lt;Text style={styles.textInfo}                                  key={i}&gt;{(i+1)+&#39;. &#39;+item}                                &lt;/Text&gt;                            )                        })                    }                &lt;/View&gt;                &lt;Button onPress={this.doUpdate}                    style={styles.button_layer}                    textStyle={styles.button_text}&gt;立即更新              &lt;/Button&gt;            &lt;/View&gt;        );        components[STATUS_DOWNLOAD_APK_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载APK&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_DOWNLOAD_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UNZIP_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在解压Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UPDATE_END] = (            &lt;Text&gt;正在重启...&lt;/Text&gt;        );        return (            ……        );    },});</code></pre><h6 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h6><pre><code>var styles = StyleSheet.create({    ……});</code></pre><h4 id="UpdateInfoBox-js"><a href="#UpdateInfoBox-js" class="headerlink" title="UpdateInfoBox.js"></a>UpdateInfoBox.js</h4><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><pre><code class="js">&#39;use strict&#39;;var React = require(&#39;react&#39;);var ReactNative = require(&#39;react-native&#39;);var { StyleSheet, View, Text, Image, TouchableOpacity } = ReactNative;var Update = require(&#39;@remobile/react-native-update&#39;);var STATUS_HAS_VEW_VERSION = 0,  STATUS_DOWNLOAD_APK_PROGESS = 1,  STATUS_DOWNLOAD_JS_PROGESS = 2,  STATUS_UNZIP_JS_PROGESS = 3,  STATUS_DOWNKOAD_APK_ERROR = 4,  STATUS_DOWNKOAD_JS_ERROR = 5,  STATUS_UNZIP_JS_ERROR = 6,  STATUS_FAILED_INSTALL_ERROR = 7,  STATUS_UPDATE_END = 8;var ERROR_NULL = 0,  ERROR_DOWNKOAD_APK = 1,  ERROR_DOWNKOAD_JS = 2,  ERROR_FAILED_INSTALL = 3,  ERROR_UNZIP_JS = 4;var PROGRESS_WIDTH = sr.tw * 0.7;var { Button, ProgressBar } = COMPONENTS;</code></pre><h5 id="进度-view-1"><a href="#进度-view-1" class="headerlink" title="进度 view"></a>进度 view</h5><pre><code>var ProgressInfo = React.createClass({    render() {        const { progress } = this.props;        if (progress &lt; 1000) {            return (                &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                    &lt;Text&gt;{this.props.title} [{progress}%]&lt;/Text&gt;                    &lt;ProgressBar                        fillStyle={{}}                        backgroundStyle={{backgroundColor: '#cccccc', borderRadius: 2}}                        style={{marginTop: 10, width:PROGRESS_WIDTH}}                        progress={progress/100.0}                        /&gt;                    &lt;View style={styles.progressText}&gt;                        &lt;Text&gt;0&lt;/Text&gt;                        &lt;Text&gt;100&lt;/Text&gt;                    &lt;/View&gt;                &lt;/View&gt;            );        } else {            let size = progress/1000/1024/1024;            return (                &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                    &lt;Text&gt;{this.props.title} [ {size.toFixed(2)} M ]&lt;/Text&gt;                &lt;/View&gt;            );        }    }});</code></pre><h5 id="页面-view-函数"><a href="#页面-view-函数" class="headerlink" title="页面 view ######函数"></a>页面 view ######函数</h5><pre><code>module.exports = React.createClass({    getInitialState() {        return {            status:STATUS_HAS_VEW_VERSION,            progress: 0,        };    },    onError(errCode) {        if (errCode == ERROR_DOWNKOAD_APK) {            this.setState({status: STATUS_DOWNKOAD_APK_ERROR});        } else if (errCode == ERROR_DOWNKOAD_JS) {            this.setState({status: STATUS_DOWNKOAD_JS_ERROR});        } else if (errCode == ERROR_FAILED_INSTALL) {            this.setState({status: STATUS_FAILED_INSTALL_ERROR});        } else if (errCode == ERROR_UNZIP_JS) {            this.setState({status: STATUS_UNZIP_JS_ERROR});        }    },    doUpdate() {        const {jsVersionCode, trackViewUrl} = this.props.options;        if (jsVersionCode !== undefined) {            Update.updateJS({                jsVersionCode,                jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,                onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},                onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},                onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        } else {            Update.updateApp({                trackViewUrl,                androidApkUrl:app.route.ROUTE_APK_URL,                androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,                onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},                onError:(errCode)=&gt;{this.onError(errCode)},            });        }    },</code></pre><p>######render</p><pre><code>    render() {        const components = {};        const {newVersion, description} = this.props.options;        components[STATUS_HAS_VEW_VERSION] = (            &lt;View style={styles.functionContainer}&gt;                &lt;Text style={styles.title}&gt;{`发现新版本(${newVersion})`}&lt;/Text&gt;                &lt;Text style={styles.redLine}&gt;                &lt;/Text&gt;                &lt;Text style={styles.content}&gt;                    {&quot;更新内容：&quot;}                &lt;/Text&gt;                {                    description.map((item, i)=&gt;{                        return (                            &lt;Text style={styles.contentItem} key={i}&gt;{&#39;- &#39;+item}&lt;/Text&gt;                        )                    })                }                &lt;View style={styles.buttonViewStyle}&gt;                    &lt;TouchableOpacity                        onPress={app.closeModal}                        style={styles.buttonStyleContainCannel}&gt;                        &lt;Text style={styles.buttonStyleCannel}&gt;以后再说&lt;/Text&gt;                    &lt;/TouchableOpacity&gt;                    &lt;TouchableOpacity                        onPress={this.doUpdate}                        style={styles.buttonStyleContain}&gt;                        &lt;Text style={styles.buttonStyle} &gt;立即更新&lt;/Text&gt;                    &lt;/TouchableOpacity&gt;                &lt;/View&gt;            &lt;/View&gt;        );        components[STATUS_DOWNKOAD_APK_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;下载apk文件失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_DOWNKOAD_JS_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;下载js bundle失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_UNZIP_JS_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;解压js bundle失败，请在设置里重新更新&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_FAILED_INSTALL_ERROR] = (            &lt;View style={[styles.functionContainer, {alignItems: &#39;center&#39;, paddingVertical: 30}]}&gt;                &lt;Text style={styles.textInfo}&gt;你放弃了安装&lt;/Text&gt;                &lt;TouchableOpacity                    onPress={app.closeModal}                    style={styles.buttonStyleContainCannel}&gt;                    &lt;Text style={styles.buttonStyleCannel}&gt;我知道了&lt;/Text&gt;                &lt;/TouchableOpacity&gt;            &lt;/View&gt;        );        components[STATUS_DOWNLOAD_APK_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载APK&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_DOWNLOAD_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在下载Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UNZIP_JS_PROGESS] = (            &lt;ProgressInfo                title=&quot;正在解压Bundle文件&quot;                progress={this.state.progress} /&gt;        );        components[STATUS_UPDATE_END] = (            &lt;Text&gt;即将重启...&lt;/Text&gt;        );        return (            &lt;View style={styles.container}&gt;                {components[this.state.status]}            &lt;/View&gt;        );    },});</code></pre><h6 id="样式-1"><a href="#样式-1" class="headerlink" title="样式"></a>样式</h6><pre><code>var styles = StyleSheet.create({   ……});</code></pre><h2 id="Update-的方法"><a href="#Update-的方法" class="headerlink" title="Update 的方法"></a>Update 的方法</h2><ul><li><code>Update.getVersion</code> - 获得当前版本<ul><li>返回值是 x.x.x</li></ul></li><li><code>Update.checkVersion</code> - 检查服务器版本</li><li><code>Update.updateApp</code> - 更新 apk 或 ios appstore</li><li><code>Update.updateJS</code> - 更新 js 捆绑文件</li></ul><h2 id="检查版本并且显示更新对话框"><a href="#检查版本并且显示更新对话框" class="headerlink" title="检查版本并且显示更新对话框"></a>检查版本并且显示更新对话框</h2><pre><code class="js">const Update = require(&#39;@remobile/react-native-update&#39;);const UpdateInfoBox = require(&#39;../modules/update/UpdateInfoBox&#39;);Update.checkVersion({  versionUrl: app.route.ROUTE_VERSION_INFO_URL,  iosAppId: CONSTANTS.IOS_APPID}).then(options =&gt; {  if (options &amp;&amp; options.newVersion) {    app.showModal(&lt;UpdateInfoBox options={options} /&gt;, {      backgroundColor: &#39;rgba(0, 0, 0, 0.6)&#39;    });  }});</code></pre><h2 id="检查版本和显示更新页面"><a href="#检查版本和显示更新页面" class="headerlink" title="检查版本和显示更新页面"></a>检查版本和显示更新页面</h2><pre><code class="js">const Update = require(&#39;@remobile/react-native-update&#39;);const UpdatePage = require(&#39;../modules/update/UpdatePage&#39;);Update.checkVersion({  versionUrl: app.route.ROUTE_VERSION_INFO_URL,  iosAppId: CONSTANTS.IOS_APPID}).then(options =&gt; {  app.navigator.push({    title: &#39;在线更新&#39;,    component: UpdatePage,    passProps: { options }  });});</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code>* versionUrl：服务器上的版本的url:    * format: { &quot;versionCode&quot;:1, &quot;versionName&quot;:&quot;1.0&quot;, &quot;jsVersionCode&quot;:2, &quot;description（描述）&quot;:&quot;hello&quot;}   这个结构体将传递给needUpdateApp和updateUpdateJS，如果你设置它们， 所以你可以自定义格式，但是versionCode和jsVersionCode必须保持一致</code></pre><pre><code>    * iosAppId:the appid on app Store## Update App Or JS```jsdoUpdate() {    const {jsVersionCode, trackViewUrl} = this.props.options;    if (jsVersionCode !== undefined) {        Update.updateJS({            jsVersionCode,            jsbundleUrl: app.isandroid?app.route.ROUTE_JS_ANDROID_URL:app.route.ROUTE_JS_IOS_URL,            onDownloadJSProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_JS_PROGESS,progress})},            onUnzipJSProgress:(progress)=&gt;{this.setState({status: STATUS_UNZIP_JS_PROGESS,progress})},            onUnzipJSEnd:()=&gt;{this.setState({status: STATUS_UPDATE_END})},            onError:(errCode)=&gt;{this.onError(errCode)},        });    } else {        Update.updateApp({            trackViewUrl,            androidApkUrl:app.route.ROUTE_APK_URL,            androidApkDownloadDestPath:&#39;/sdcard/yxjqd.apk&#39;,            onDownloadAPKProgress:(progress)=&gt;{this.setState({status: STATUS_DOWNLOAD_APK_PROGESS,progress})},            onError:(errCode)=&gt;{this.onError(errCode)},        });    }},</code></pre><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><pre><code>* jsbundleUrl:js捆绑网址    * 当只有js代码更改或图像资源更改，我希望您发布jsbundle，称为次要版本    * 包括www / index.android.bundle或www / index.ios.bundle    * 包括android上的图像目录，ios上的资源目录    * 在android上，image dir包含一些动态图像（这个版本添加的新图像）    * 发布小版本你应该修改jsVersionCode* androidApkUrl:apk的网址    * 只有native代码改变了，你需要在Android上发布apk或者在ios上发布ipa，叫做Marjor版本    * 发布Marjor版本，您应该增加versionCode并将jsVersionCode设置为0* androidApkDownloadDestPath：apk文件下载路径，例如/ sdcard / download，确保它存在* onDownloadAPKStart:function    * 当apk开始下载时回调* onDownloadAPKProgress:function    * 当apk正在下载时回调    * 将通过{total：xx，loaded：xx} 1参数* onDownloadAPKEnd:function    * 当apk下载结束时回调* onDownloadJSStart:function* onDownloadJSProgress:function    * 当apk正在下载时回调，    * 将通过{total：xx，loaded：xx} 1参数* onDownloadJSEnd:function* onUnzipJSStart:function* onUnzipJSProgress:function    * 解压时候回调,    * 将通过{total：xx，loaded：xx} 1参数* onUnzipJSEnd:function* onError:function    * 将通过errorCode    * var ERROR_NULL = 0,          ERROR_DOWNKOAD_APK = 1,          ERROR_DOWNKOAD_JS = 2,          ERROR_GET_VERSION = 3,          ERROR_UNZIP_JS = 4;</code></pre><h2 id="生成捆绑"><a href="#生成捆绑" class="headerlink" title="生成捆绑"></a>生成捆绑</h2><pre><code class="bash">#!/bin/bashdistpath=../../localServer/public/downloadfunction genIOSBundle() {    react-native bundle \        --platform ios \        --reset-cache \        --verbose \        --entry-file index.ios.js \        --bundle-output ./tools/www/index.ios.bundle \        --assets-dest ./tools/www/ \        --dev false}function genAndroidBundle() {    react-native bundle \        --platform android \        --reset-cache \        --verbose \        --entry-file index.android.js \        --bundle-output ./tools/www/index.android.bundle \        --assets-dest ./tools/www/ \        --dev false}function zipWWW() {    node -e &quot;!function(){function i(e,r){var o=n.readdirSync(e);o.forEach(function(o){var s=e+&#39;/&#39;+o;n.statSync(s).isDirectory()?i(s,r+&#39;/&#39;+o):c.folder(r).file(o,n.readFileSync(s))})}function e(e,r,o){r=r||&#39;&#39;,o=o||e+&#39;.zip&#39;,i(e,r);var s=c.generate({base64:!1,compression:&#39;DEFLATE&#39;});n.writeFile(o,s,&#39;binary&#39;,function(){console.log(&#39;success&#39;)})}var r=require(&#39;jszip&#39;),n=require(&#39;fs&#39;),c=new r,o=process.argv.splice(1);e.apply(null,o)}();&quot;  www _www www.zip}function genMd5List() {    cd ./tools    # git co head ${distpath}/${1}_md5.json    node -e &quot;var o=process.argv;require(&#39;./getMd5List&#39;)(o[1],o[2])&quot; ${1} ${distpath}}function zipFile() {    zipWWW    mv ./www.zip ${distpath}/js${1}.zip    rm -fr www    mv ./${1}_md5.json ${distpath}/${1}_md5.json    echo &quot;${distpath}&quot;}function buildAndroid() {    rm -fr www    mkdir www    cd ..    genAndroidBundle    genMd5List android    zipFile android}function buildIos() {    rm -fr www    mkdir www    cd ..    genIOSBundle    genMd5List ios    zipFile ios}function main() {    if [ &quot;$1&quot; = &quot;android&quot; ];then        buildAndroid    elif [ &quot;$1&quot; = &quot;ios&quot; ];then        buildIos    elif [ &quot;$1&quot; = &quot;all&quot; ];then        buildAndroid        buildIos    else        echo &quot;Usage: ./genbundle ios|android|all&quot;    fi}main $@</code></pre><ul><li>确保安装 jszip 在 npm 在全局(global)，我们使用它的 zip</li></ul><h3 id="服务器端-version-json"><a href="#服务器端-version-json" class="headerlink" title="服务器端 version.json"></a>服务器端 version.json</h3><pre><code class="json">{  &quot;iosPassed&quot;: true,  &quot;iosJsVersionCode&quot;: 0,  &quot;iosDescription&quot;: [&quot;修正bug&quot;, &quot;添加新功能&quot;],  &quot;androidPassed&quot;: {    &quot;baidu&quot;: false,    &quot;default&quot;: true  },  &quot;versionName&quot;: &quot;1.0&quot;,  &quot;versionCode&quot;: 1048576,  &quot;androidJsVersionCode&quot;: 0,  &quot;androidDescription&quot;: [&quot;修改bug&quot;, &quot;添加新功能&quot;]}</code></pre><h3 id="看详细使用"><a href="#看详细使用" class="headerlink" title="看详细使用"></a>看详细使用</h3><ul><li><a href="https://github.com/remobile/react-native-template" target="_blank" rel="noopener">https://github.com/remobile/react-native-template</a></li></ul><h4 id="工具在"><a href="#工具在" class="headerlink" title="工具在"></a>工具在</h4><p><a href="https://github.com/remobile/react-native-template/blob/master/project/tools" target="_blank" rel="noopener">useful tools</a></p><p>####例子在 react-native-template<br><a href="https://github.com/remobile/react-native-template/blob/master/project/App/modules/update" target="_blank" rel="noopener">Update</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一本漫画闯天涯</title>
    <link href="undefined2017/06/25/%E4%B8%80%E6%9C%AC%E6%BC%AB%E7%94%BB%E9%97%AF%E5%A4%A9%E6%B6%AF/"/>
    <url>2017/06/25/%E4%B8%80%E6%9C%AC%E6%BC%AB%E7%94%BB%E9%97%AF%E5%A4%A9%E6%B6%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>星仔本是酒吧一个小服务员，一次偶然的机会见到了黑社会火拼，黑老大给了他一张名片为以后的剧情铺垫。</p></blockquote><p>黑老大抓了一个对头的人严刑拷打，希望可以供出幕后主谋，威逼利诱下供出了自己的老大洪义，黑老大放他走。他走的时候遇见杀手，被杀。</p><p>黑老大约洪义谈判，洪义迟到。骂了一顿黑老大，黑老大手下不开心想干掉他，洪义从车里抓出一个人-黑老大的儿子，大摇大摆并且嘲笑了黑老大然后给黑老大儿子手臂开了一枪。黑老大非常生气。</p><p>星仔莫名其妙被洪义的人打了一顿，回到酒吧也被辞退了，回头一想去找黑老大，黑老大安排了一个工作给他。</p><p>星仔去到酒吧看到一个妹子在唱歌，很开心。进房后自我介绍后被叫买宵夜，很不开心，然后被阿俊（黑老大义子）叫出去聊天，两人交谈了一下。见到那个妹子被三个流氓欺负，星仔去救，失败，啊俊出场。三人结识。</p><p>星仔和洪义一起聚桑拿（坐隔壁），洪义让星仔拼命浇水，整个桑拿房无比闷热，星仔放了几个屁，洪义让其继续加水。星仔拿着浇水的盆咋想洪义的手下的头，星仔队友开枪打死洪义。</p><p>再次回到酒吧，星仔表演唱歌被笑，啊俊上……</p><p>三人到处玩耍，得知妹子的妹子叫安妮，安妮给她们两个人都送了一支笔，笔上分别有他们的字。埋下伏笔</p><p>黑老大派星仔和阿俊还有阿标（黑老大手下）去泰国跟全叔谈判要加量，全叔直接被拜猜的人干掉，三人被抓，阿俊和阿标被打得半死不活，星仔挺身而出救了他们自己做了人质，星仔和拜猜聊天，都很开心，（但如果阿俊他们不回来交易就会被杀），交易结束。</p><p>星仔回到香港抱怨没人来接，回到家里泡澡疑似有人闯进来，被盖住头立马跪下求饶，被阿俊和阿标嘲笑，然后星仔去阿标家里吃饭。</p><p>黑老大召集大家开了一个会议是关于继承人的事情，大家推举阿标坐他的位置，黑老大不爽，派人杀阿标。</p><p>阿标办了一个酒会庆祝他有儿子，结束后星仔扶阿标走，被阿标询问儿子应该叫什么，星仔取了一个名字给他“周润龙”，阿标不知道“润”怎么写，星仔用笔在阿标手上写了润字，笔遗漏在阿标车顶，阿标拒绝了星仔送回家，被黑老大杀手杀死。</p><p>另一个杀手准备杀星仔，被星仔逃跑，大家都怀疑是星仔杀阿标的，黑老大通缉星仔。</p><p>星仔打电话给阿俊，阿俊被跟踪。星仔跟阿俊谈判的时候杀手开了一枪，没有打死，星仔做诱饵，阿俊跑上山把杀手干掉。</p><p>阿俊跟人打斗的时候死了，星仔难过，跟安妮交代之后退隐。</p><p>黑老大跟儿子说：“现在你的绊脚石都杀了”，还讲了刘邦的故事，然后黑老大就被枪打死了，儿子说：我最大的绊脚石就是你</p><blockquote><p>全剧终。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春娇救志明3</title>
    <link href="undefined2017/06/22/%E6%98%A5%E5%A8%87%E6%95%91%E5%BF%97%E6%98%8E3/"/>
    <url>2017/06/22/%E6%98%A5%E5%A8%87%E6%95%91%E5%BF%97%E6%98%8E3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>春娇童年有一个关于“吃刚刚”的故事，这是她的心里阴影。</p></blockquote><p>志明喜欢买各种东西，常把男人必须有一个 xx 挂在嘴边。</p><p>志明去遛狗，一个误会让春娇首次怀疑志明，误会解除。</p><p>志明的干妈想跟他借种（纯借精），志明考虑很久拒绝，春娇开心，两人准备去台湾。</p><p>春娇的爸爸是很不责任喜欢逃避的人，跟志明混在一起，春娇害怕志明跟她爸一样。</p><p>志明见她爸，春娇问她爸女票：为什么是他，答：最危险时想起的人就是对的</p><p>春娇与志明去台湾，春娇故意没带套想要小孩，完事后疑似地震，志明抛弃春娇，春娇难过…跑路</p><p>春娇强行让自己体会危险，跑浴缸，拿朔料袋盖住头，无果。</p><p>两人经过极度挣扎，在春娇生日时，春娇唱歌，志明难过…</p><p>志明与春娇她爸和飞鹰演戏被拆穿，春娇说算了。</p><p>志明疯狂唱歌，表白：是你让我长大，是你拯救我，要不是你我还长不大变不了一个男人…以前我以为一个男人需要很多别的事证明，其实不用，只需要跟一个我喜欢的在乎的女人好好过日子就行。半跪求婚 ing</p><blockquote><p>带上戒指，完。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms 建立可以绑定属性的方法</title>
    <link href="undefined2017/06/19/XamarinForms%E5%BB%BA%E7%AB%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>2017/06/19/XamarinForms%E5%BB%BA%E7%AB%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文讲述如何实现控件的属性如何可以被 Binding</p><h1 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h1><pre><code>[RenderWith(typeof(_ActivityIndicatorRenderer))]    public class ActivityIndicator : View, IElementConfiguration&lt;ActivityIndicator&gt;    {        //这就是值类型绑定的实现        public static readonly BindableProperty IsRunningProperty = BindableProperty.Create        (&quot;IsRunning&quot;, typeof(bool), typeof(ActivityIndicator), default(bool));        public static readonly BindableProperty ColorProperty = BindableProperty.Create        (&quot;Color&quot;, typeof(Color), typeof(ActivityIndicator), Color.Default);        readonly Lazy&lt;PlatformConfigurationRegistry&lt;ActivityIndicator&gt;&gt; _platformConfigurationRegistry;        public ActivityIndicator()        {            _platformConfigurationRegistry = new Lazy&lt;PlatformConfigurationRegistry&lt;ActivityIndicator&gt;&gt;(() =&gt; new PlatformConfigurationRegistry&lt;ActivityIndicator&gt;(this));        }        public Color Color        {            get { return (Color)GetValue(ColorProperty); }            set { SetValue(ColorProperty, value); }        }        //与之对对应的属性        public bool IsRunning        {            get { return (bool)GetValue(IsRunningProperty); }            set { SetValue(IsRunningProperty, value); }        }        public IPlatformElementConfiguration&lt;T, ActivityIndicator&gt; On&lt;T&gt;() where T : IConfigPlatform        {            return _platformConfigurationRegistry.Value.On&lt;T&gt;();        }    }</code></pre><blockquote><p>Ps：这个官方例子是有问题的。</p></blockquote><h2 id="下面讲一下如何绑定事件，其实-Xamarin-Forms-绑定事件用的是-Command，方法也不难。"><a href="#下面讲一下如何绑定事件，其实-Xamarin-Forms-绑定事件用的是-Command，方法也不难。" class="headerlink" title="下面讲一下如何绑定事件，其实 Xamarin Forms 绑定事件用的是 Command，方法也不难。"></a>下面讲一下如何绑定事件，其实 Xamarin Forms 绑定事件用的是 Command，方法也不难。</h2><pre><code>public class MyEntry:Entry{    public ICommand MyCommand    {        get =&gt; (ICommand )GetValue(MyCommandProperty);        set =&gt; SetValue(MyCommandProperty, value);    }    /// &lt;summary&gt;    /// MyCommandProperty的Mvvm实现    /// &lt;/summary&gt;    public static readonly BindableProperty MyCommandProperty = Create    (        nameof(回调方法),        typeof(ICommand),        typeof(MyEntry)    ); //注意这里变量名的命名规则是MyCommand + Property，前者随便，后者固定语法    private void 回调方法()    {        MyCommand?.Execute(null);    }}//这样这个MyEntry的MyCommand就可以被Mvvm绑定了。</code></pre><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><pre><code>&lt;MyEntry MyCommand={ Binding ThisCommand &gt;&lt;/MyEntry&gt;</code></pre><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><pre><code>public class Model:某个mvvm框架的BasePage{    public Command ThisCommand    {        get        {            retrun new Command(()=&gt;            {                //做点什么            });        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻译Rolling your own Mvvm for Xamarin.Forms</title>
    <link href="undefined2017/06/09/%E7%BF%BB%E8%AF%91Rolling-your-own-Mvvm-for-Xamarin.Forms/"/>
    <url>2017/06/09/%E7%BF%BB%E8%AF%91Rolling-your-own-Mvvm-for-Xamarin.Forms/</url>
    
    <content type="html"><![CDATA[<p>#原文地址：<a href="http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/" target="_blank" rel="noopener">http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/</a></p><p>#实现自己的 Mvvm for Xamarin.Forms<br>更新：我已经采取了这个位置的最好的部分，并放入一个框架，这是一个超简单的 Mvvm 框架的 Xamarin.Forms，它放在了 github 和 nuget。<br>在这个博客中，我给出了一个如何在 Xamarin.Forms 中实现自己的 Mvvm 的例子。 这个 Mvvm 是基于约定的，在这种情况下，我使用了 Page / PageModel 命名，而不是 Model / ViewModel 命名，但是如果你喜欢，你可以将其改为 View / ViewModel。 这个博客写的内容基于 github 上可用的示例应用程序。</p><p>##本例中的约定。</p><ul><li>页面必须有一个相应的 PageModel，命名重要，所以 QuotePageModel 必须有一个 QuotePage</li><li>一个页面可以有一个没有参数的 Init 方法</li><li>页面可以有一个 PageModel 属性，它是视图模型</li><li>页面上的 BindingContext 将自动设置为 Model</li><li>一个模型可以有一个接收一个对象的 Init 方法</li><li>一个模型可以具有一个 ReverseInit 方法，它也可以使用一个对象，当一个模型被放在一个对象上时被调用</li></ul><p>###让我们看一个页面</p><pre><code>public class QuotePage : ContentPage{    //按下时自动弹出    public QuotePageModel PageModel { get; set; }    public QuotePage ()    {    }    //出现时自动执行    public void Init()    {        Title = &quot;Quote&quot;;    }}</code></pre><p>###和相应的 PageModel</p><pre><code>public class QuotePageModel : BasePageModel{    IDatabaseService _databaseService;    public Quote Quote { get; set; }    //数据库服务自动注入。    public QuotePageModel (IDatabaseService databaseService)    {        _databaseService = databaseService;    }    //当Model出现的时候执行    public void Init(object data)    {        Quote = data as Quote;        if (Quote == null)            Quote = new Quote ();    }    public Command Done    {        get {            return new Command (() =&gt; {                //This pops the current Page                PopPageModel();            });        }    }}</code></pre><p>##Navigating Models<br>您可以使用 PushPageModel 方法和 PopPageModel 方法从视图模型中推送和弹出页面。</p><p>例如。<code>PushPageModel&lt;QuotePageModel&gt;（quote）;</code></p><p>但在您可以做到这一点之前，您需要实现和注册一个 IRootNavigation 服务。 在我的情况下，我使用了一个 ContainerPage 并将其注册为 NavigationHandler</p><p>//注册根导航</p><pre><code>var containerPage = new RootContainerPage（）;TinyIoC.TinyIoCContainer.Current.Register &lt;IRootNavigation&gt;（containerPage）;</code></pre><pre><code>public class RootContainerPage : MasterDetailPage, IRootNavigation{    ContentPage _menuPage;    NavigationPage _contactNavPage, _quotesNavPage;    public RootContainerPage ()    {        _contactNavPage = new NavigationPage (BasePageModel.ResolvePageModel&lt;ContactsRootPageModel&gt; (null));        _quotesNavPage = new NavigationPage (BasePageModel.ResolvePageModel&lt;QuotesRootPageModel&gt; (null));        Detail = _contactNavPage;        _menuPage = new ContentPage ();        _menuPage.Title = &quot;Menu&quot;;        var listView = new ListView();        listView.ItemsSource = new string[] { &quot;Contacts&quot;, &quot;Quotes&quot; };        listView.ItemSelected += (sender, args) =&gt;        {            if ((string)args.SelectedItem == &quot;Contacts&quot;)                Detail = _contactNavPage;            if ((string)args.SelectedItem == &quot;Quotes&quot;)                Detail = _quotesNavPage;            IsPresented = false;        };        _menuPage.Content = listView;        Master = new NavigationPage(_menuPage) { Title = &quot;Menu&quot; };    }    public void PushPage (Page page, BasePageModel model)    {        ((NavigationPage)Detail).PushAsync (page);    }    public void PopPage ()    {        ((NavigationPage)Detail).PopAsync ();    }}</code></pre><p>##Implementing Property Changed<br>你会注意到我不需要实现属性更改事件，而是使用一个名为<a href="https://github.com/Fody/PropertyChanged" target="_blank" rel="noopener">Fody / PropertyChanged</a>的开源项目实现。 您可以从 nuget 安装。</p><p>##控制反转/ TinyIOC<br>ViewPage 构造函数的依赖将自动注入。 使用 TinyIOC 注册依赖项。</p><p>//注册数据库服务<br><code>TinyIoC.TinyIoCContainer.Current.Register &lt;IDatabaseService，DatabaseService&gt;();</code></p><p>##神奇的地方在哪里？<br>如果你想知道神奇的实现在哪里发生，那么看看<a href="https://github.com/rid00z/XamarinFormsQuoteApp/blob/master/XamarinFormsQuoteApp/PageModels/BasePageModel.cs" target="_blank" rel="noopener">示例应用程序中的 BasePageModel.cs。</a></p><p>##平台依赖关系<br>此应用程序利用 SQLite 的平台依赖关系。</p><p>##单元测试<br>如果我们遵循惯例，那么模型是松耦合的，容易测试。</p><p>您可以将模拟的依赖关系传递给模型并进行测试。 在这里看到一个例子：</p><pre><code>[TestFixture]public class ContactPageModelTests{    [Test]    public static void CreateNewContact()    {        var container = A.Fake&lt;IRootNavigation&gt; ();        TinyIoC.TinyIoCContainer.Current.Register&lt;IRootNavigation&gt; (container);        var db = new DatabaseService (new SQLiteFactory());        var vm = new ContactPageModel (db);        vm.Init (null);        //保存到数据库        vm.Contact.Name = &quot;Peter&quot;;        vm.Contact.Phone = &quot;9087&quot;;        vm.Done.Execute (null);        Assert.IsTrue (vm.Contact.ContactId &gt; 0);        //从数据库取出        var savedContact                = db.Conn.Table&lt;Contact&gt; ().Where ((c) =&gt; c.ContactId == vm.Contact.ContactId).FirstOrDefault ();        Assert.AreEqual (&quot;Peter&quot;, savedContact.Name);        Assert.AreEqual (&quot;9087&quot;, savedContact.Phone);        A.CallTo (() =&gt; container.PopPage ()).MustHaveHappened ();    }}</code></pre><p>请去看看 github 上的代码。</p><p><a href="https://github.com/rid00z/XamarinFormsQuoteApp" target="_blank" rel="noopener">https://github.com/rid00z/XamarinFormsQuoteApp</a></p><p>Thanks</p><p>Michael</p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Glimpse the Future of Xamarin Forms 3.0 翻译</title>
    <link href="undefined2017/06/09/Glimpse-the-Future-of-XamarinForms-3.0-%E7%BF%BB%E8%AF%91/"/>
    <url>2017/06/09/Glimpse-the-Future-of-XamarinForms-3.0-%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>#原文地址：<a href="https://blog.xamarin.com/glimpse-future-xamarin-forms-3-0/" target="_blank" rel="noopener">https://blog.xamarin.com/glimpse-future-xamarin-forms-3-0/</a></p><h1 id="Xamarin-Forms-3-0"><a href="#Xamarin-Forms-3-0" class="headerlink" title="Xamarin Forms 3.0"></a>Xamarin Forms 3.0</h1><p>在 Microsoft Build 2017 中，我们分享了对 Xamarin.Forms 3.0 的愿景：在更多的平台上可以使用 Xamarin.Forms，并且以前更快。 今天，我想介绍一些令人兴奋的新功能，我们将添加到 Xamarin.Forms，我们知道你会爱上这个功能的！</p><h2 id="Xamarin-Forms-嵌入"><a href="#Xamarin-Forms-嵌入" class="headerlink" title="Xamarin.Forms 嵌入"></a>Xamarin.Forms 嵌入</h2><p>您一直能够从 Xamarin.Forms 调用本机 API，但是现在我们允许您使用大多数本机应用程序的 Xamarin.Forms。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-16ea9eebb29ddb67.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="embedding-uwp-desktop.gif"></p><p>无论您是将 xamarin.Forms 全部进入，还是只想将其用于您最常使用的本机应用程序，我们将启用所有路径; 我们称之为 Xamarin.Forms 嵌入。 在 XAML 或 C＃中使用任何 ContentPage，并将其直接嵌入到 Xamarin.iOS，Xamarin.Android 或 UWP 应用程序中。</p><p>所有现有的 Xamarin.Forms UI 现在已经在 Xamarin.Forms 应用程序之外扩展了使用。</p><p>这是它的外观。 在非 Xamarin.Forms 应用程序中，使用该平台的预期参数初始化 Forms 并使用方便的方法就可以创建 ContentPage 的本机对象。 就这样，你的手指就掌握了原生的控制！</p><pre><code>// AndroidForms.Init(this, null);var androidFragment = new MyFormsPage().CreateFragment(this);// iOSForms.Init()var iosViewController = new MyFormsPage().CreateViewController();// UWPForms.Init(e);var uwpElement = new MyFormsPage().CreateFrameworkElement();</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/5692364-52aa87d296279e34.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="2017-05-15_13-57-14.gif"></p><p>Xamarin.Forms 的功能，如 DependencyService，MessagingCenter 和数据绑定系统，在这种情况下都可以使用。</p><p>##兼容更多平台</p><p>Xamarin.Forms 正在走向更多的平台！ 准备在 MacOS 使用 WPF，Linux 以及更多的 Windows 应用程序上运行。 今天我们已经开始使用 macOS，但是我们并没有停在那里，我们可以让您定位每个桌面平台！ 我们的团队正在为 GTK＃和 WPF 开发。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-c1b23c21387016cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>##性能提升和增强<br>我们将 Xamarin.Forms 放在显微镜下，以确定使您的应用加载速度更快，运行更快的关键目标，具体为：</p><ul><li>控制渲染器：我们继续我们适当称之为快速渲染器的工作。 这些重构的渲染器避免创建多余的中间对象和实现更好的性能。</li><li>布局压缩：启用时，我们会在编译时优化布局，以提高渲染速度并最大限度地减少内存使用。</li><li>绑定系统：我们正在引入一次绑定模式。</li><li>灵活性：流行的 Web 布局系统来到 Xamarin.Forms。 我们正在引入一个 FlexLayout 系统来构建自适应布局并实现一个 Visual State Manager。</li><li>Styling：我们正在抛光经常需要的 CSS 样式实现。 你可以像今天一样继续为您的应用程序设计样式，如果您是 CSS 的粉丝，那就太好了。</li></ul><p>##介绍 XAML 标准<br>正如 Microsoft Build 2017 所宣布的，我们正在与 XAML Standard 的 Windows 部门进行合作，这是 XAML 作为资产共享的一种方式。 Xamarin.Forms 将完全支持 XAML 标准，并带您到需要启动的每个平台。</p><p>支持 XAML Standard 的框架将能够共享基于 XAML 的常见 UI 定义。 我们的目标是在今年晚些时候推出第一个版本 XAML Standard 1.0。</p><h2 id="尝试今天加入交流"><a href="#尝试今天加入交流" class="headerlink" title="尝试今天加入交流"></a>尝试今天加入交流</h2><p>今天可以在这里开始我们为 Xamarin.Forms 3.0 Cooking 的所有好东西。</p><p>##下载 Xamarin.Forms 3.0 预览<br>我们已经将 Xamarin.Forms 的预览内容发布到新的 Feed，并共享了我们的演示代码。 得到它：</p><ul><li>向 NuGet Manager 添加新的源代码：https：//<a href="http://www.myget.org/F/xamarinforms-dev/api/v3/index.json" target="_blank" rel="noopener">www.myget.org/F/xamarinforms-dev/api/v3/index.json</a></li><li>检查预发行</li><li>选择并安装功能名称为“Embedding”的软件包。3.0.0.100-embeddingpreview</li><li>在 GitHub 上下载 Weather 演示应用程序代码。<a href="https://github.com/davidortinau/build2017-new-in-xamarin-forms" target="_blank" rel="noopener">https://github.com/davidortinau/build2017-new-in-xamarin-forms</a></li><li>准备好后，请浏览完整的 Xamarin.Forms 路线图，并加入 GitHub 上的 XAML Standard 对话。</li></ul><p>###准备好后，请浏览完整的 Xamarin.Forms 路线图，并加入 GitHub 上的 XAML Standard 交流。</p><ul><li><a href="https://aka.ms/xfroadmap" target="_blank" rel="noopener">Xamarin.Forms Roadmap</a>，并向我们提供有关这些公告的反馈。</li><li>在<a href="https://aka.ms/xamlstandard" target="_blank" rel="noopener">aka.ms/xamlstandard</a>.中加入 XAML 标准对话。</li><li>在<a href="https://blog.xamarin.com/preview-bringing-macos-to-xamarin-forms/" target="_blank" rel="noopener">blog.xamarin.com/preview-bringing-macos-to-xamarin-forms/</a>.上预览 XAMarin.Forms for macOS。</li></ul><h4 id="在-channel9-msdn-com-events-Build-2017-B8099-上观看我们完整的-Microsoft-Build-2017-Xamarin-Forms-会话。"><a href="#在-channel9-msdn-com-events-Build-2017-B8099-上观看我们完整的-Microsoft-Build-2017-Xamarin-Forms-会话。" class="headerlink" title="在 channel9.msdn.com/events/Build/2017/B8099 上观看我们完整的 Microsoft Build 2017 Xamarin.Forms 会话。"></a>在 channel9.msdn.com/events/Build/2017/B8099 上观看我们完整的 Microsoft Build 2017 Xamarin.Forms 会话。</h4><p><a href="https://sec.ch9.ms/ch9/e613/96a58de3-75e5-4d9e-9b15-e216a03fe613/B8099_high.mp4" target="_blank" rel="noopener">观看连接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms MvvM框架之FreshMvvM翻译一</title>
    <link href="undefined2017/06/09/XamarinForms-MvvM%E6%A1%86%E6%9E%B6%E4%B9%8BFreshMvvM%E7%BF%BB%E8%AF%91%E4%B8%80/"/>
    <url>2017/06/09/XamarinForms-MvvM%E6%A1%86%E6%9E%B6%E4%B9%8BFreshMvvM%E7%BF%BB%E8%AF%91%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="原文地址：https-github-com-rid00z-FreshMvvm"><a href="#原文地址：https-github-com-rid00z-FreshMvvm" class="headerlink" title="原文地址：https://github.com/rid00z/FreshMvvm"></a>原文地址：<a href="https://github.com/rid00z/FreshMvvm" target="_blank" rel="noopener">https://github.com/rid00z/FreshMvvm</a></h1><h1 id="FreshMvvm-for-Xamarin-Forms"><a href="#FreshMvvm-for-Xamarin-Forms" class="headerlink" title="FreshMvvm for Xamarin.Forms"></a>FreshMvvm for Xamarin.Forms</h1><p>FreshMvvm 是专门为 Xamarin.Forms 设计的轻量 Mvvm 框架。 它是简单和灵活的。</p><h1 id="与其他的选择相比怎么样？"><a href="#与其他的选择相比怎么样？" class="headerlink" title="与其他的选择相比怎么样？"></a>与其他的选择相比怎么样？</h1><ul><li>轻量，超简单</li><li>它专为 Xamarin.Forms 设计</li><li>设计易于学习和开发（当你还没有准备好 RxUI 时它是很好的）</li><li>使用比配置更好的设定。</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>PageModel 到 PageModel 导航</li><li>BindingContext 的自动构造</li><li>页面事件的自动构造（例如页面出现）</li><li>PageModel 上的基本方法（允许传值）（init，reverseinit）</li><li>内置 IOC 容器（依赖注入）</li><li>PageModel 构造函数注入</li><li>Basic 中提供的基本方法，如弹消息框</li><li>内置导航类型为 SimpleNavigation，Tabbed 和 MasterDetail</li></ul><h1 id="它的故事"><a href="#它的故事" class="headerlink" title="它的故事"></a>它的故事</h1><p>当 Xamarin.Forms 发布时，我（Michael Ridland）是 Xamarin 传统应用程序的一部分。 我想将项目移到 Xamarin.Forms 上，但是在该项目中我使用的是 MvvMCross。 当时 MvvmCross 不支持 Xamarin.Forms，所以我有几个选择</p><ul><li>（1）适应 MvvmCross</li><li>（2）找到一个替代的框架</li><li>（3）实现我自己的 MvvM。</li></ul><p>关于 MvvmCross 的最好的部分是它是双向数据绑定到原生的 iOS / Android 控件，但由于 Xamarin.Forms 已经拥有 Databinding 内置，这是没有用的，MvvMCross 太大了，我不需要这么大。<br>我也无法找到一个可以轻松移动的替代方案。所以我做了属于我自己简单并且灵活 MvvM 框架。</p><p><a href="http://www.michaelridland.com/xamarin/rolling-mvvm-xamarin-forms/" target="_blank" rel="noopener">它是从这个帖子开始的</a>——<a href="2017/06/09/翻译Rolling-your-own-Mvvm-for-Xamarin.Forms/">翻译在这</a>，为 Xamarin.Forms 实现自己的 Mvvm。 我尽量为自己的 MvvM 框架做得简单。</p><p>从来没有想过来写一个框架，但在几次发布 Mvvm 解决方案之后，我发现很多人都想要它，并且似乎对此感兴趣。 另外考虑到我从 Xamarin.Forms 开始就在我所有的项目中使用了这个框架，我知道它的工作原理，所以我创建了 FreshMvvm，于是它诞生了。</p><h1 id="共同遵守的设定"><a href="#共同遵守的设定" class="headerlink" title="共同遵守的设定"></a>共同遵守的设定</h1><ul><li>一个页面必须有一个相应的 PageModel，类的命名十分重要，所以 QuotePageModel 必须有一个 QuotePage 页面。QuotePage 上的 BindingContext 将被自动设置为 Model</li><li>一个 PageModel 可以拥有一个接收一个对象的 Init 方法</li><li>一个 PageModel 可以有一个 ReverseInit 方法，它也可以使用一个对象，当一个模型被一个对象引用时被调用</li><li>PageModel 可以将依赖关系自动注入到构造函数中</li></ul><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p>FreshMvvm 中的主要导航形式是 PageModel 到 PageModel，这实际上意味着我们的观点不了解导航。</p><ul><li>所以要在 PageModels 之间导航使用：</li></ul><pre><code>await CoreMethods.PushPageModel&lt;QuotePageModel&gt;(); // 推送导航堆栈await CoreMethods.PushPageModel&lt;QuotePageModel&gt;(null, true); // 推送模态</code></pre><ul><li>FreshMvvm 中的导航引擎是通过一个简单的界面完成的，其中包含了 Push 和 Pop 的方法。 基本上这些方法可以以任何他们喜欢的方式控制应用程序的导航。</li></ul><pre><code>public interface IFreshNavigationService{Task PushPage(Page page, FreshBasePageModel model, bool modal = false);Task PopPage(bool modal = false);}</code></pre><ul><li>在 PushPage 和 PopPage 中，您可以执行任何您喜欢的导航，这可以从简单的导航到高级嵌套导航。</li></ul><h2 id="该框架包含一些内置的导航容器，用于不同类型的导航。"><a href="#该框架包含一些内置的导航容器，用于不同类型的导航。" class="headerlink" title="该框架包含一些内置的导航容器，用于不同类型的导航。"></a>该框架包含一些内置的导航容器，用于不同类型的导航。</h2><ul><li><h3 id="基本导航-内置"><a href="#基本导航-内置" class="headerlink" title="基本导航 - 内置"></a>基本导航 - 内置</h3></li></ul><pre><code>var page = FreshPageModelResolver.ResolvePageModel&lt;MainMenuPageModel&gt; ();var basicNavContainer = new FreshNavigationContainer (page);MainPage = basicNavContainer;</code></pre><ul><li><h3 id="主要细节-内置"><a href="#主要细节-内置" class="headerlink" title="主要细节 - 内置"></a>主要细节 - 内置</h3></li></ul><pre><code>var masterDetailNav = new FreshMasterDetailNavigationContainer ();masterDetailNav.Init (&quot;Menu&quot;);masterDetailNav.AddPage&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);masterDetailNav.AddPage&lt;QuoteListPageModel&gt; (&quot;Pages&quot;, null);MainPage = masterDetailNav;</code></pre><ul><li><h3 id="标签导航-内置"><a href="#标签导航-内置" class="headerlink" title="标签导航 - 内置"></a>标签导航 - 内置</h3></li></ul><pre><code>var tabbedNavigation = new FreshTabbedNavigationContainer ();tabbedNavigation.AddTab&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);tabbedNavigation.AddTab&lt;QuoteListPageModel&gt; (&quot;Pages&quot;, null);MainPage = tabbedNavigation;</code></pre><ul><li><h3 id="实施自定义导航"><a href="#实施自定义导航" class="headerlink" title="实施自定义导航"></a>实施自定义导航</h3></li></ul><p>可以通过实现 IFreshNavigationService.来设置任何类型的导航。在示例应用程序中有一个示例，名为 CustomImplementedNav.cs。</p><h2 id="示例应用程序"><a href="#示例应用程序" class="headerlink" title="示例应用程序"></a>示例应用程序</h2><ul><li>基本导航例子</li><li>标签式导航例子</li><li>MasterDetail 导航例子</li><li>使用 MasterDetail Popover 示例的 Tabbed 导航（这在 Sample App 中被称为 CustomImplementedNav）</li></ul><h2 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h2><p>所以你不需要使用你自己的 IOC 容器，FreshMvvm 自带了一个内置的 IOC 容器，它使用的是 TinyIOC，但使用不同的命名来避免冲突。要在容器中注册服务注册：</p><pre><code>FreshIOC.Container.Register&lt;IDatabaseService, DatabaseService&gt;();</code></pre><p>注入时使用：</p><pre><code>FreshIOC.Container.Resolve&lt;IDatabaseService&gt;();</code></pre><p>这也是驱动构建器注入的方式。</p><p>我们现在流畅支持 API 来设置对象在 IOC 容器内的生命周期。</p><pre><code>// 默认情况下，我们将具体类型注册为多例，并将接口注册为单例FreshIOC.Container.Register&lt;MyConcreteType&gt;(); // 多例FreshIOC.Container.Register&lt;IMyInterface, MyConcreteType&gt;(); // 单例// Fluent API允许我们改变这种行为FreshIOC.Container.Register&lt;MyConcreteType&gt;().AsSingleton(); // 单例FreshIOC.Container.Register&lt;IMyInterface, MyConcreteType&gt;().AsMultiInstance(); // 多例</code></pre><p>如下所示，IFreshIOC 接口方法返回 IRegisterOptions 接口。</p><pre><code>public interface IFreshIOC{    object Resolve(Type resolveType);    IRegisterOptions Register&lt;RegisterType&gt;(RegisterType instance) where RegisterType : class;    IRegisterOptions Register&lt;RegisterType&gt;(RegisterType instance, string name) where RegisterType : class;    ResolveType Resolve&lt;ResolveType&gt;() where ResolveType : class;    ResolveType Resolve&lt;ResolveType&gt;(string name) where ResolveType : class;    IRegisterOptions Register&lt;RegisterType, RegisterImplementation&gt; ()  where RegisterType : class  where RegisterImplementation : class, RegisterType;}</code></pre><p>从 register 方法返回的接口是 IRegisterOptions。</p><pre><code>public interface IRegisterOptions{    IRegisterOptions AsSingleton();    IRegisterOptions AsMultiInstance();    IRegisterOptions WithWeakReference();    IRegisterOptions WithStrongReference();    IRegisterOptions UsingConstructor&lt;RegisterType&gt;(Expression&lt;Func&lt;RegisterType&gt;&gt; constructor);}</code></pre><h2 id="PageModel-构造函数注入"><a href="#PageModel-构造函数注入" class="headerlink" title="PageModel - 构造函数注入"></a>PageModel - 构造函数注入</h2><p>当 PageModels 被推送到 IOC 容器中的 services 可以被推入构造函数。</p><pre><code>FreshIOC.Container.Register&lt;IDatabaseService, DatabaseService&gt;();</code></pre><h2 id="PageModel-重要方法"><a href="#PageModel-重要方法" class="headerlink" title="PageModel 重要方法"></a>PageModel 重要方法</h2><pre><code>/// &lt;summary&gt;/// 以前的页面模型，这是自动推送填充/// &lt;/summary&gt;public FreshBasePageModel PreviousPageModel { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 对当前页面的引用，即自动推送填充/// &lt;/summary&gt;public Page CurrentPage { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 核心方法是应用程序的基本内置方法，包括推送，弹出和弹消息框/// &lt;/summary&gt;public IPageModelCoreMethods CoreMethods { get; set; }</code></pre><pre><code>/// &lt;summary&gt;/// 当一个页面调用Pop&#39;d这个方法时，它也允许返回数据。/// &lt;/summary&gt;/// &lt;param name=&quot;returndData&quot;&gt;从...返回的数据 &lt;/param&gt;public virtual void ReverseInit(object returndData) { }</code></pre><pre><code>/// &lt;summary&gt;/// 在加载PageModel时调用此方法，initData是之前从pagemodel发送来的数据/// &lt;/summary&gt;/// &lt;param name=&quot;initData&quot;&gt;从推送器发送到此PageModel的数据&lt;/param&gt;public virtual void Init(object initData) { }</code></pre><pre><code>/// &lt;summary&gt;/// View消失时调用此方法。/// &lt;/summary&gt;protected virtual void ViewIsDisappearing (object sender, EventArgs e){}</code></pre><pre><code>/// &lt;summary&gt;/// View出现时调用此方法/// &lt;/summary&gt;protected virtual void ViewIsAppearing (object sender, EventArgs e){}</code></pre><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>每个 PageModel 都有一个名为“CoreMethods”的属性，当一个 PageModel 被推送时，它被自动填充，它是大多数应用程序需要的基本功能，如弹消息框，推送，弹出等。</p><pre><code>public interface IPageModelCoreMethods{    Task DisplayAlert (string title, string message, string cancel);    Task&lt;string&gt; DisplayActionSheet (string title, string cancel, string destruction, params string[] buttons);    Task&lt;bool&gt; DisplayAlert (string title, string message, string accept, string cancel);    Task PushPageModel&lt;T&gt;(object data, bool modal = false) where T : FreshBasePageModel;    Task PopPageModel(bool modal = false);    Task PopPageModel(object data, bool modal = false);    Task PushPageModel&lt;T&gt;() where T : FreshBasePageModel;}</code></pre><h2 id="Page-的重要方法"><a href="#Page-的重要方法" class="headerlink" title="Page 的重要方法"></a>Page 的重要方法</h2><p>PageModel Init PropertyChanged</p><h3 id="示例-PageModel"><a href="#示例-PageModel" class="headerlink" title="示例 PageModel"></a>示例 PageModel</h3><pre><code>[ImplementPropertyChanged] // 使用Fody for Property更改通知public class QuoteListPageModel : FreshBasePageModel{    IDatabaseService _databaseService;    //这些通过构造函数注入IOC    public QuoteListPageModel (IDatabaseService databaseService)    {        _databaseService = databaseService;    }    public ObservableCollection&lt;Quote&gt; Quotes { get; set; }    public override void Init (object initData)    {        Quotes = new ObservableCollection&lt;Quote&gt; (_databaseService.GetQuotes ());    }    //框架支持标准View出现和消失事件    protected override void ViewIsAppearing (object sender, System.EventArgs e)    {        CoreMethods.DisplayAlert (&quot;Page is appearing&quot;, &quot;&quot;, &quot;Ok&quot;);        base.ViewIsAppearing (sender, e);    }    protected override void ViewIsDisappearing (object sender, System.EventArgs e)    {        base.ViewIsDisappearing (sender, e);    }    //跳转到另一个页面后，如果返回此页面调用    public override void ReverseInit (object value)    {        var newContact = value as Quote;        if (!Quotes.Contains (newContact))        {            Quotes.Add (newContact);        }    }    public Command AddQuote    {        get        {            return new Command (async () =&gt;            {                //Push A Page Model                await CoreMethods.PushPageModel&lt;QuotePageModel&gt; ();            });        }    }    Quote _selectedQuote;    public Quote SelectedQuote    {        get        {            return _selectedQuote;        }        set        {            _selectedQuote = value;            if (value != null)                QuoteSelected.Execute (value);        }    }    public Command&lt;Quote&gt; QuoteSelected    {        get        {            return new Command&lt;Quote&gt; (async (quote) =&gt;            {                await CoreMethods.PushPageModel&lt;QuotePageModel&gt; (quote);            });        }    }}</code></pre><h2 id="多个导航服务"><a href="#多个导航服务" class="headerlink" title="多个导航服务"></a>多个导航服务</h2><p>在 FreshMvvm 中可以进行任何类型的导航，通过实现自定义导航服务来完成自定义或高级场景。即使有这种能力，发现在 FreshMvvm 中做高级导航方案有点困难。在我回顾了 FreshMvvm 的所有支持问题之后，我发现人们的基本问题是他们希望能够多次使用我们内置的导航容器，其中两个主要例子是</p><ul><li>（1）具有导航堆栈的主要细节：在一个 master 和另一个 master 的细节</li><li>（2）使用新的推动导航容器模型的能力。</li></ul><p>为了支持这两种情况，我得出结论，FreshMvvm 需要具有命名 NavigationServices 的能力，以便我们可以支持多个 NavigationService。</p><h2 id="使用多个导航容器"><a href="#使用多个导航容器" class="headerlink" title="使用多个导航容器"></a>使用多个导航容器</h2><p>在下面我们运行一个单一的主细节的两个导航堆栈。</p><pre><code>var masterDetailsMultiple = new MasterDetailPage (); //generic master detail page//我们使用ContactList设置第一个导航容器var contactListPage = FreshPageModelResolver.ResolvePageModel&lt;ContactListPageModel&gt; ();contactListPage.Title = &quot;Contact List&quot;;//我们设置名为MasterPageArea的第一个导航容器var masterPageArea = new FreshNavigationContainer (contactListPage, &quot;MasterPageArea&quot;);masterPageArea.Title = &quot;Menu&quot;;masterDetailsMultiple.Master = masterPageArea; //将第一个导航容器设置为Master//我们使用QuoteList设置第二个导航容器var quoteListPage = FreshPageModelResolver.ResolvePageModel&lt;QuoteListPageModel&gt; ();quoteListPage.Title = &quot;Quote List&quot;;//我们设置名为DetailPageArea的第二个导航容器var detailPageArea = new FreshNavigationContainer (quoteListPage, &quot;DetailPageArea&quot;);masterDetailsMultiple.Detail = detailPageArea; //将第二个导航容器设置为“Detail”MainPage = masterDetailsMultiple;</code></pre><h2 id="在新的导航堆栈使用-PushModally"><a href="#在新的导航堆栈使用-PushModally" class="headerlink" title="在新的导航堆栈使用 PushModally"></a>在新的导航堆栈使用 PushModally</h2><pre><code>//push a basic page Modallyvar page = FreshPageModelResolver.ResolvePageModel&lt;MainMenuPageModel&gt; ();var basicNavContainer = new FreshNavigationContainer (page, &quot;secondNavPage&quot;);await CoreMethods.PushNewNavigationServiceModal(basicNavContainer, new FreshBasePageModel[] { page.GetModel() });//推送标签页模型var tabbedNavigation = new FreshTabbedNavigationContainer (&quot;secondNavPage&quot;);tabbedNavigation.AddTab&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, &quot;contacts.png&quot;, null);tabbedNavigation.AddTab&lt;QuoteListPageModel&gt; (&quot;Quotes&quot;, &quot;document.png&quot;, null);await CoreMethods.PushNewNavigationServiceModal(tabbedNavigation);//推送主细节页面var masterDetailNav = new FreshMasterDetailNavigationContainer (&quot;secondNavPage&quot;);masterDetailNav.Init (&quot;Menu&quot;, &quot;Menu.png&quot;);masterDetailNav.AddPage&lt;ContactListPageModel&gt; (&quot;Contacts&quot;, null);masterDetailNav.AddPage&lt;QuoteListPageModel&gt; (&quot;Quotes&quot;, null);await CoreMethods.PushNewNavigationServiceModal(masterDetailNav);</code></pre><h2 id="在-Xamarin-Forms-MainPage-上切换-NavigationStacks"><a href="#在-Xamarin-Forms-MainPage-上切换-NavigationStacks" class="headerlink" title="在 Xamarin.Forms MainPage 上切换 NavigationStacks"></a>在 Xamarin.Forms MainPage 上切换 NavigationStacks</h2><p>Xamarin.Forms 中有些情况可能需要运行多个导航堆栈。 一个很好的例子是当你有一个用于认证的导航堆栈和一个应用程序主区域的堆栈。</p><p>首先我们可以为导航容器设置一些名称。</p><pre><code>public class NavigationContainerNames{    public const string AuthenticationContainer = &quot;AuthenticationContainer&quot;;    public const string MainContainer = &quot;MainContainer&quot;;}</code></pre><p>然后我们可以创建我们的两个导航容器并分配到主页面。</p><pre><code>var loginPage = FreshMvvm.FreshPageModelResolver.ResolvePageModel&lt;LoginViewModel&gt;();var loginContainer = new FreshNavigationContainer(loginPage, NavigationContainerNames.AuthenticationContainer);var myPitchListViewContainer = new MainTabbedPage(NavigationContainerNames.MainContainer);MainPage = loginContainer;</code></pre><p>一旦我们设置好了，我们现在可以切换我们的导航容器。</p><pre><code>CoreMethods.SwitchOutRootNavigation(NavigationContainerNames.MainContainer);</code></pre><h2 id="自定义-IOC-容器"><a href="#自定义-IOC-容器" class="headerlink" title="自定义 IOC 容器"></a>自定义 IOC 容器</h2><p>FreshMvvm 1.0 的第二个主要要求是允许自定义 IOC 容器。 在您的应用程序已经具有要使用的容器的情况下。</p><p>使用自定义 IOC 容器非常简单，因为您只需要实现单个接口。</p><pre><code>public interface IFreshIOC{    object Resolve(Type resolveType);    void Register&lt;RegisterType&gt;(RegisterType instance) where RegisterType : class;    void Register&lt;RegisterType&gt;(RegisterType instance, string name) where RegisterType : class;    ResolveType Resolve&lt;ResolveType&gt;() where ResolveType : class;    ResolveType Resolve&lt;ResolveType&gt;(string name) where ResolveType : class;    void Register&lt;RegisterType, RegisterImplementation&gt; () where RegisterType : class where RegisterImplementation : class, RegisterType;</code></pre><p>然后在系统中设置 IOC 容器。</p><p><code>FreshIOC.OverrideContainer(myContainer);</code></p><h2 id="相关视频-快速入门指南"><a href="#相关视频-快速入门指南" class="headerlink" title="相关视频/快速入门指南"></a>相关视频/快速入门指南</h2><ul><li>FreshMvvm n = 0 - Mvvm 在 Xamarin.Forms 和为什么需要 FreshMvvm</li><li>FreshMvvm n = 1：你的第一个 FreshMvvm 应用程序</li><li>FreshMvvm n = 2 - IOC 和构造器注入</li><li>FreshMvvm n = 3：在 FreshMvvm 中导航</li><li>在 FreshMvvm 中为 Xamarin.Forms 实现自定义导航</li><li>TDD 在 Xamarin Studio - Live Coding FreshMvvm</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宇宙第一IDE，Visual studio-Nuget使用教程</title>
    <link href="undefined2017/06/09/Nuget%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>2017/06/09/Nuget%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一些废话："><a href="#一些废话：" class="headerlink" title="一些废话："></a>一些废话：</h1><p><a href="https://www.visualstudio.com/zh-hans/downloads/" target="_blank" rel="noopener">VS2017 的下载地址</a><br>现在的 Visual studio（简称 vs）跟我在大学期间老师常用的 vs2010 已经不太一样了。<br>想起我刚学的时候在网上搜索 Nuget 怎么使用都是一堆的命令行写法铺面而来，让我很是烦恼，例如这一种。<br><img src="http://upload-images.jianshu.io/upload_images/5692364-6af62c65d399db82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>这里要讲的是另外一种，更加简单。<br>先打开 VS，图标是这样的。<br><img src="http://upload-images.jianshu.io/upload_images/5692364-db537594be002937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>然后点击文件</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-37a3147992bb4f5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>然后<br><img src="http://upload-images.jianshu.io/upload_images/5692364-94ad12cac48a8725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>这里然后创建一个解决方案（微软粑粑给我们预设的很多模板，我们按需求挑一个来用就可以了）这里选择</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-ea9542c0eb23df2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>所有的 vs 都可以创建控制台应用。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-e32fc6a40ad51e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>有可能你的 vs 没有解决方案资源管理器，那么可以在</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-7dcb2851b3aa0535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>这里搜索</p><p>然后<br><img src="http://upload-images.jianshu.io/upload_images/5692364-c0b175cdb70747c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>然后会出现</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-570b90cdecc9f158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机杂锦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms Api请求开源框架Refit翻译</title>
    <link href="undefined2017/06/08/XamarinForms-Api%E8%AF%B7%E6%B1%82%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6Refit%E7%BF%BB%E8%AF%91/"/>
    <url>2017/06/08/XamarinForms-Api%E8%AF%B7%E6%B1%82%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6Refit%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="原文地址：https-github-com-paulcbetts-refit"><a href="#原文地址：https-github-com-paulcbetts-refit" class="headerlink" title="原文地址：https://github.com/paulcbetts/refit"></a>原文地址：<a href="https://github.com/paulcbetts/refit" target="_blank" rel="noopener">https://github.com/paulcbetts/refit</a></h2><p>用于.NET Core，Xamarin 和.NET 的自动类型安全的 REST 库，Refit 是一个受 Square Square Retrofit 库影响的库，但它比 REST API 更容易：</p><pre><code>public interface IGitHubApi{    [Get(&quot;/users/{user}&quot;)]    Task&lt;User&gt; GetUser(string user);}</code></pre><p>RestService 类生成一个使用 HttpClient 进行调用的 IGitHubApi 实现：</p><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;);var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);</code></pre><h1 id="兼容的平台"><a href="#兼容的平台" class="headerlink" title="兼容的平台"></a>兼容的平台</h1><h4 id="Refit-目前支持以下平台和任何-NET-Standard-1-3Taget"><a href="#Refit-目前支持以下平台和任何-NET-Standard-1-3Taget" class="headerlink" title="Refit 目前支持以下平台和任何.NET Standard 1.3Taget"></a>Refit 目前支持以下平台和任何.NET Standard 1.3Taget</h4><ul><li>Xamarin.Android</li><li>Xamarin.Mac</li><li>Xamarin.iOS 64-bit (Unified API)</li><li>Desktop .NET 4.5</li><li>Windows Store 8.1+</li><li>Windows Phone 8.1 Universal Apps</li><li>.NET Core</li></ul><h1 id="以下平台不支持"><a href="#以下平台不支持" class="headerlink" title="以下平台不支持"></a>以下平台不支持</h1><ul><li>Xamarin.iOS 32-bit</li></ul><h1 id="关于-NET-Core"><a href="#关于-NET-Core" class="headerlink" title="关于.NET Core"></a>关于.NET Core</h1><p>对于.NET Core 支持，您必须使用 csproj 类型的项目托管您的 Refit 接口。 这是因为 xproj 无法执行不包含在项目文件中的编译时代码生成。 如果您使用 xproj 作为网站，类库或应用程序，您仍然可以通过创建一个 netstandard csproj 然后使用从 xproj 到 csproj 的项目到项目的引用来使用 Refit。 一旦出现“VS 15”和最终的.NET Core 工具，此解决方法就不需要了。</p><h1 id="API-属性"><a href="#API-属性" class="headerlink" title="API 属性"></a>API 属性</h1><ul><li><p>每个方法都必须有一个 HTTP 属性，提供请求方法和相对 URL。 有五个内置注释：Get，Post，Put，Delete 和 Head。 资源的相对 URL 在注释中指定。<br><code>[Get(&quot;/users/list&quot;)]</code></p></li><li><p>你可以在 URL 中指定查询参数：<br><code>[Get(&quot;/users/list?sort=desc&quot;)]</code></p></li><li><p>可以使用方法上的替换块和参数动态更新请求 URL。 替换块是由{}包围的字母数字字符串。如果您的参数名称与 URL 路径中的名称不匹配，请使用 AliasAs 属性。</p></li></ul><pre><code>[Get(&quot;/group/{id}/users&quot;)]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs(&quot;id&quot;)] int groupId)</code></pre><ul><li>未指定为 URL 替换的参数将自动用作查询参数。 这与 Retrofit 不同，其中必须明确指定所有参数。参数名称和 URL 参数之间的比较不区分大小写，因此如果您在路径/ group/{groupid} /show 中命名参数”groupId”，它将正常工作。</li></ul><pre><code>[Get(&quot;/group/{id}/users&quot;)]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs(&quot;id&quot;)] int groupId, [AliasAs(&quot;sort&quot;)] string sortOrder);GroupList(4, &quot;desc&quot;);&gt;&gt;&gt; &quot;/group/4/users?sort=desc&quot;</code></pre><ul><li>PS：这里就是说如果你在 GroupList 的签名里面使用<code>[AliasAs(&quot;sort&quot;)] 变量类型 变量名</code>的方式，即使原本的路径里面没有“sort”的属性，也会自动加上去。</li></ul><p>#Body 内容</p><h2 id="通过使用-Body-属性，方法中的一个参数可以作为-Body"><a href="#通过使用-Body-属性，方法中的一个参数可以作为-Body" class="headerlink" title="通过使用 Body 属性，方法中的一个参数可以作为 Body"></a>通过使用 Body 属性，方法中的一个参数可以作为 Body</h2><pre><code>[Post(&quot;/users/new&quot;)]Task CreateUser([Body] User user);</code></pre><h2 id="根据参数的类型，提供-Body-数据有四种可能："><a href="#根据参数的类型，提供-Body-数据有四种可能：" class="headerlink" title="根据参数的类型，提供 Body 数据有四种可能："></a>根据参数的类型，提供 Body 数据有四种可能：</h2><ul><li>如果类型为 Stream，则内容将通过 StreamContent 流式传输。</li><li>如果类型是字符串，则该字符串将直接用作内容</li><li>如果参数具有[Body（BodySerializationMethod.UrlEncoded）]属性，内容将被 URL 编码（见下面的 Form Posts 部分）</li><li>对于所有其他类型，对象将被序列化为 JSON。</li></ul><h1 id="JSON-内容"><a href="#JSON-内容" class="headerlink" title="JSON 内容"></a>JSON 内容</h1><ul><li>JSON 请求和响应使用 Json.NET 进行序列化/反序列化。 默认情况下，Refit 将使用可以通过设置 Newtonsoft.Json.JsonConvert.DefaultSettings 定义序列化器的设置：</li></ul><pre><code>JsonConvert.DefaultSettings = () =&gt; new JsonSerializerSettings() {        ContractResolver = new CamelCasePropertyNamesContractResolver(),        Converters = {new StringEnumConverter()} };//## Serialized as: {&quot;day&quot;:&quot;Saturday&quot;}await PostSomeStuff(new { Day = DayOfWeek.Saturday });</code></pre><ul><li>因为这些是全局设置，它们会影响整个应用程序。 将请求的设置隔离到特定的 AP 也许是有益的。 当创建一个 Refit 生成的实时界面时，您可以选择传递一个 RefitSettings，这将允许您指定你想要的 serializer 设置。 这允许您为不同的 API 具有不同的序列化器设置。</li></ul><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;,new RefitSettings{        JsonSerializerSettings = new JsonSerializerSettings {            ContractResolver = new SnakeCasePropertyNamesContractResolver()} } );var otherApi = RestService.For&lt;IOtherApi&gt;(&quot;https://api.example.com&quot;,new RefitSettings{        JsonSerializerSettings = new JsonSerializerSettings {         ContractResolver = new CamelCasePropertyNamesContractResolver()} } );</code></pre><ul><li>属性序列化/反序列化可以使用 Json.NET 的 JsonProperty 属性进行定制：</li></ul><pre><code>public class Foo{    // 像[AliasAs（“b”）]的使用将以form posts发布（见下文）    [JsonProperty(PropertyName=&quot;b&quot;)]    public string Bar { get; set; }}</code></pre><h1 id="Form-posts"><a href="#Form-posts" class="headerlink" title="Form posts"></a>Form posts</h1><ul><li>对于采用表单帖子（即序列化为应用程序/ x-www-form-urlencoded）的 API，使用 BodySerializationMethod.UrlEncoded 初始化 Body 属性。参数可以是一个 IDictionary</li></ul><pre><code>public interface IMeasurementProtocolApi{    [Post(&quot;/collect&quot;)]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Dictionary&lt;string, object&gt; data);}var data = new Dictionary&lt;string, object&gt; {    {&quot;v&quot;, 1},    {&quot;tid&quot;, &quot;UA-1234-5&quot;},    {&quot;cid&quot;, new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;)},    {&quot;t&quot;, &quot;event&quot;},};// 序列化为: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(data);</code></pre><ul><li>或者您可以传递任何对象，所有公共可读属性将作为请求中的表单字段序列化。 该方法允许您使用[AliasAs（“whatever”）]来别名属性名称，如果 API 具有隐藏字段名称，则可以帮助您：</li></ul><pre><code>public interface IMeasurementProtocolApi{    [Post(&quot;/collect&quot;)]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Measurement measurement);}public class Measurement{    // 属性可以是只读的，不需要[AliasAs]    public int v { get { return 1; }    [AliasAs(&quot;tid&quot;)]    public string WebPropertyId { get; set; }    [AliasAs(&quot;cid&quot;)]    public Guid ClientId { get;set; }    [AliasAs(&quot;t&quot;)]    public string Type { get; set; }    public object IgnoreMe { private get; set; }}var measurement = new Measurement {    WebPropertyId = &quot;UA-1234-5&quot;,    ClientId = new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;),    Type = &quot;event&quot;};//序列化为: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(measurement);</code></pre><h1 id="设置请求标头"><a href="#设置请求标头" class="headerlink" title="设置请求标头"></a>设置请求标头</h1><ul><li><h2 id="静态标题"><a href="#静态标题" class="headerlink" title="静态标题"></a>静态标题</h2>您可以为应用 Headers 属性的方法设置一个或多个静态请求标头：</li></ul><pre><code>[Headers(&quot;User-Agent: Awesome Octocat App&quot;)][Get(&quot;/users/{user}&quot;)]Task&lt;User&gt; GetUser(string user);</code></pre><p>也可以通过将 Headers 属性应用于接口，将静态标头添加到 API 中的每个请求中：</p><pre><code>[Headers(&quot;User-Agent: Awesome Octocat App&quot;)]public interface IGitHubApi{    [Get(&quot;/users/{user}&quot;)]    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    Task CreateUser([Body] User user);}</code></pre><ul><li><h2 id="动态标题"><a href="#动态标题" class="headerlink" title="动态标题"></a>动态标题</h2>如果头文件的内容需要在运行时设置，则可以通过将 Header 属性应用到参数来为请求添加具有动态值的头文件：</li></ul><pre><code>[Get(&quot;/users/{user}&quot;)]Task&lt;User&gt; GetUser(string user, [Header(&quot;Authorization&quot;)] string authorization);// 将标题“Authorization：token OAUTH-TOKEN”添加到请求中var user = await GetUser(&quot;octocat&quot;, &quot;token OAUTH-TOKEN&quot;);</code></pre><ul><li><h2 id="授权（动态标题缩减）"><a href="#授权（动态标题缩减）" class="headerlink" title="授权（动态标题缩减）"></a>授权（动态标题缩减）</h2>使用标头的最常见原因是授权。 今天，大多数 API 使用一些口味的 oAuth，访问令牌到期并刷新取得更长寿命的令牌。封装这些令牌用法的一种方法是，可以插入一个自定义的 HttpClientHandler。举个例子：</li></ul><pre><code>class AuthenticatedHttpClientHandler : HttpClientHandler{    private readonly Func&lt;Task&lt;string&gt;&gt; getToken;    public AuthenticatedHttpClientHandler(Func&lt;Task&lt;string&gt;&gt; getToken)    {        if (getToken == null) throw new ArgumentNullException(&quot;getToken&quot;);        this.getToken = getToken;    }    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)    {        // See if the request has an authorize header        var auth = request.Headers.Authorization;        if (auth != null)        {            var token = await getToken().ConfigureAwait(false);            request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);        }        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);    }}</code></pre><p>虽然 HttpClient 包含几乎相同的方法签名，但使用方式不同。 HttpClient.SendAsync 不被调用。 必须修改 HttpClientHandler。这个类是这样使用的（例如使用 ADAL 库来管理 Xamarin.Auth 或任何其他库的自动令牌刷新：</p><pre><code>class LoginViewModel{    AuthenticationContext context = new AuthenticationContext(...);    private async Task&lt;string&gt; GetToken()    {        // 如果需要，AquireTokenAsync调用将提示用户界面        // 否则默认使用刷新令牌返回一个有效的访问令牌        var token = await context.AcquireTokenAsync(&quot;http://my.service.uri/app&quot;, &quot;clientId&quot;, new Uri(&quot;callback://complete&quot;));        return token;    }    public async void LoginAndCallApi()    {        var api = RestService.For&lt;IMyRestService&gt;(new HttpClient(new AuthenticatedHttpClientHandler(GetToken)) { BaseAddress = new Uri(&quot;https://the.end.point/&quot;) });        var location = await api.GetLocationOfRebelBase();    }}interface IMyRestService{    [Get(&quot;/getPublicInfo&quot;)]    Task&lt;Foobar&gt; SomePublicMethod();    [Get(&quot;/secretStuff&quot;)]    [Headers(&quot;Authorization: Bearer&quot;)]    Task&lt;Location&gt; GetLocationOfRebelBase();}</code></pre><p>在上面的例子中，任何时候调用需要身份验证的方法，AuthenticatedHttpClientHandler 将尝试获取一个新的访问令牌。 由应用程序提供一个，检查现有访问令牌的到期时间，并在需要时获取新的访问令牌。</p><ul><li><h1 id="重新定义标题"><a href="#重新定义标题" class="headerlink" title="重新定义标题"></a>重新定义标题</h1>不同于 Retrofit，其中标题不会相互覆盖，并且都添加到请求中，而不管定义同一个标题的次数如何，Refit 对 ASP.NET MVC 采用与动作过滤器相似的方法采用类似的方法 - 重新定义标题将替换 它按以下顺序排列：</li><li>接口上的标题属性（最低优先级）</li><li>标题属性在方法</li><li>方法参数的标题属性（最高优先级）</li></ul><pre><code>[Headers(&quot;X-Emoji: :rocket:&quot;)]public interface IGitHubApi{    [Get(&quot;/users/list&quot;)]    Task&lt;List&gt; GetUsers();    [Get(&quot;/users/{user}&quot;)]    [Headers(&quot;X-Emoji: :smile_cat:&quot;)]    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    [Headers(&quot;X-Emoji: :metal:&quot;)]    Task CreateUser([Body] User user, [Header(&quot;X-Emoji&quot;)] string emoji);}// X-Emoji: :rocket:var users = await GetUsers();// X-Emoji: :smile_cat:var user = await GetUser(&quot;octocat&quot;);// X-Emoji: :trollface:await CreateUser(user, &quot;:trollface:&quot;);</code></pre><ul><li><h1 id="删除标题"><a href="#删除标题" class="headerlink" title="删除标题"></a>删除标题</h1>在界面或方法上定义的标题可以通过重新定义没有值的静态标题（即不使用：<value>）或为动态标题传递 null 来删除。 空字符串将被包括为空标题。</value></li></ul><pre><code>[Headers(&quot;X-Emoji: :rocket:&quot;)]public interface IGitHubApi{    [Get(&quot;/users/list&quot;)]    [Headers(&quot;X-Emoji&quot;)] // 删除X-Emoji标题    Task&lt;List&gt; GetUsers();    [Get(&quot;/users/{user}&quot;)]    [Headers(&quot;X-Emoji:&quot;)] // 将X-Emoji标题重新定义为空    Task&lt;User&gt; GetUser(string user);    [Post(&quot;/users/new&quot;)]    Task CreateUser([Body] User user, [Header(&quot;X-Emoji&quot;)] string emoji);}// 没有X-Emoji标题var users = await GetUsers();// X-Emoji:var user = await GetUser(&quot;octocat&quot;);// 没有X-Emoji标题await CreateUser(user, null);// X-Emoji:await CreateUser(user, &quot;&quot;);</code></pre><ul><li><h1 id="断点上传"><a href="#断点上传" class="headerlink" title="断点上传"></a>断点上传</h1>使用 Multipart 属性装饰的方法将使用多部分内容类型提交。 此时，multipart 方法支持以下参数类型：</li><li>字符串（参数名称将用作名称和字符串值作为值）</li><li>字节数组</li><li>流</li><li>FileInfo<br>参数名称将用作多部分数据中字段的名称。 这可以被 AliasAs 属性覆盖。要指定字节数组（byte []），Stream 和 FileInfo 参数的文件名和内容类型，需要使用包装类。 ByteArrayPart，StreamPart 和 FileInfoPart。</li></ul><pre><code>public interface ISomeApi{    [Multipart]    [Post(&quot;/users/{id}/photo&quot;)]    Task UploadPhoto(int id, [AliasAs(&quot;myPhoto&quot;)] StreamPart stream);}</code></pre><p>要将 Stream 传递给此方法，请构建如下所示的 StreamPart 对象：<br><code>someApiInstance.UploadPhoto(id, new StreamPart(myPhotoStream, &quot;photo.jpg&quot;, &quot;image/jpeg&quot;));</code><br>注意：此部分以前描述的 AttachmentName 属性已被弃用，不推荐使用它。</p><h1 id="检索回应"><a href="#检索回应" class="headerlink" title="检索回应"></a>检索回应</h1><p>请注意，在 Refit 中，与 Retrofit 不同，没有同步网络请求的选项 - 所有请求都必须通过任务或通过 IObservable 进行异步。 不像 Retrofit，只能通过回调参数创建异步，因为我们生活在 async/await 未来。</p><pre><code>[Post(&quot;/users/new&quot;)]Task CreateUser([Body] User user);// 如果网络呼叫失败，则会发生这种情况await CreateUser(someUser);</code></pre><p>如果 type 参数是’HttpResponseMessage’或’string’，则原始响应消息或作为字符串的内容将分别返回。</p><pre><code>// Returns the content as a string (i.e. the JSON data)[Get(&quot;/users/{user}&quot;)]Task&lt;string&gt; GetUser(string user);//返回原始响应，作为可用于Reactive Extensions的IObservable[Get(&quot;/users/{user}&quot;)]IObservable&lt;HttpResponseMessage&gt; GetUser(string user);</code></pre><h1 id="使用通用接口"><a href="#使用通用接口" class="headerlink" title="使用通用接口"></a>使用通用接口</h1><p>当使用像 ASP.NET Web API 这样的东西，它是一个相当普遍的模式，拥有一整套 CRUD REST 服务。 Refit 现在允许您使用通用类型定义单个 API 接口：</p><pre><code>public interface IReallyExcitingCrudApi&lt;T, in TKey&gt; where T : class{    [Post(&quot;&quot;)]    Task&lt;T&gt; Create([Body] T paylod);    [Get(&quot;&quot;)]    Task&lt;List&lt;T&gt;&gt; ReadAll();    [Get(&quot;/{key}&quot;)]    Task&lt;T&gt; ReadOne(TKey key);    [Put(&quot;/{key}&quot;)]    Task Update(TKey key, [Body]T payload);    [Delete(&quot;/{key}&quot;)]    Task Delete(TKey key);}</code></pre><ul><li><h2 id="可以这样使用："><a href="#可以这样使用：" class="headerlink" title="可以这样使用："></a>可以这样使用：</h2></li></ul><pre><code>// 这里的“/ users”部分是很重要的，如果您希望它可以使用多种类型（除非每种类型都有不同的域）var api = RestService.For&lt;IReallyExcitingCrudApi&lt;User, string&gt;&gt;(&quot;http://api.example.com/users&quot;);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rg.Popup-Xamarin Forms使用教程</title>
    <link href="undefined2017/06/06/Rg.Popup-XamarinForms%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>2017/06/06/Rg.Popup-XamarinForms%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这是一个增强 popup 的插件，这里只讲用法，不讲原理。<br>第一步：装 Nuget 包，在 Pcl 项目中搜索”Rg.Plugins.Popup”作者是：Kirill Lyubimov，其他项目不需要装。(<a href="http://www.jianshu.com/p/a71d10660b3a" target="_blank" rel="noopener">装 Nuget 教程</a>）<br>第二步：创建 popup 页面（就是弹出显示的那个页面）<br>第三步：使用 PopupNavigation 类的几个导航方法。</p><p>好，知道了基本步骤之后就开始教程。<br>第一步应该都知道怎么操作，不多讲了。</p><p>重点讲第二步：<br>第二步内容比较多，我们一个一个来操作。 </p><ul><li>新建一个项目叫 Demo（跨平台项目） </li><li>创建一个 Popup 的 Page 新建项：——类型选：Forms Blank Content Page Xaml ，取名为 DemoPopupPage 吧。 </li><li>在 DemoPopupPage.Xaml 页面里面必须这样写</li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;pages:PopupPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;             xmlns:pages=&quot;clr-namespace:Rg.Plugins.Popup.Pages;assembly=Rg.Plugins.Popup&quot;             xmlns:animations=&quot;clr-namespace:Rg.Plugins.Popup.Animations;assembly=Rg.Plugins.Popup&quot;             x:Class=&quot;Demo.DemoPopupPage&quot;&gt; &lt;!--代码块1--&gt;&lt;/pages:PopupPage&gt;</code></pre><p>下面是“代码块 1”：</p><pre><code>  &lt;pages:PopupPage.Animation&gt;    &lt;animations:ScaleAnimation      PositionIn=&quot;Top&quot;      PositionOut=&quot;Center&quot;      ScaleIn=&quot;1&quot;      ScaleOut=&quot;0.7&quot;      DurationIn=&quot;700&quot;      EasingIn=&quot;BounceOut&quot;/&gt;  &lt;/pages:PopupPage.Animation&gt;&lt;!--布局--&gt;</code></pre><h2 id="对上面的代码稍作解释："><a href="#对上面的代码稍作解释：" class="headerlink" title="对上面的代码稍作解释："></a>对上面的代码稍作解释：</h2><p>animations:ScaleAnimation 表示使用缩放动画<br>对于 PositionIn/PositionOut 属性</p><pre><code>表示Popup从页面的哪个方位进入/弹出。它有：Center,Left,Right,Top,Bottom四个可以选，它的类型是MoveAnimationOptions，它是一个枚举。</code></pre><p>关于 PositionIn/PositionOut</p><pre><code>表示Popup出现/消失动画的持续时间</code></pre><p>关于 ScaleIn/ScaleOut</p><pre><code>表示出现/消失动画执行完毕后渲染Popup的时间</code></pre><p>关于 EasingIn</p><pre><code>表示动画的特性。一共有* Linear;   线性变换。* SinOut;   平滑减速，就是慢慢变慢* SinIn;    平稳加速，缓缓变快* SinInOut; 加速进出，Popup出现和消失都会加速* CubicIn;  慢慢开始加速，加速度不定的加速。* CubicOut; 开始快速减速。，加速度不定的减速。* CubicInOut加速减速。 一般选择。* BounceOut;弹跳3次，静止在目的地* BounceIn; 弹跳2次，然后静止在目的地* SpringIn;不知道怎么解释，自己测试吧* SpringOut;跟BounceIn有些类似，但是更有柔软性</code></pre><p>Ps：这些属性在不同的动画类型展示出来的效果是不一样的。这些属性更像形容词，套到这里的缩放动画就是：线性变化的缩放动画</p><p>Ok，其他动画也大同小异。然后到<!--布局-->这里<br>这里没有什么太大的问题。<br>要注意 2 个点，第一层布局必须是 StackLayout,Grid 这类布局，然后第二层布局一定是 Frame（为了不把背景全部盖住），再下一级的布局跟正常的布局是一样的没有区别。<br>示例代码：</p><pre><code>    &lt;StackLayout VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot;&gt;        &lt;Frame BackgroundColor=&quot;Silver&quot;&gt;            &lt;StackLayout Spacing=&quot;20&quot;&gt;                &lt;ListView x:Name=&quot;ListView&quot;&gt;                    &lt;ListView.ItemTemplate&gt;                        &lt;DataTemplate&gt;                            &lt;ViewCell&gt;                                &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;                                    &lt;Label Text=&quot;{Binding Briefing}&quot;&gt;&lt;/Label&gt;                                    &lt;Label Text=&quot;{Binding Color}&quot;&gt;&lt;/Label&gt;                                    &lt;Label Text=&quot;{Binding Composition}&quot;&gt;&lt;/Label&gt;                                &lt;/StackLayout&gt;                            &lt;/ViewCell&gt;                        &lt;/DataTemplate&gt;                    &lt;/ListView.ItemTemplate&gt;                &lt;/ListView&gt;                &lt;Label Text=&quot;??&quot;&gt;&lt;/Label&gt;            &lt;/StackLayout&gt;        &lt;/Frame&gt;    &lt;/StackLayout&gt;</code></pre><p>Ps:StackLayout 的 VerticalOptions=”Center” HorizontalOptions=”Center”表示这个 Popup 会在屏幕中间，修改可以出现在其他的地方。</p><p>自定义动画：</p><blockquote><p>有空再更</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamarin Forms-如何横置组件</title>
    <link href="undefined2017/06/05/XamarinForms-%E5%A6%82%E4%BD%95%E6%A8%AA%E7%BD%AE%E7%BB%84%E4%BB%B6/"/>
    <url>2017/06/05/XamarinForms-%E5%A6%82%E4%BD%95%E6%A8%AA%E7%BD%AE%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>原理其实很简单，就是通过 <code>ListView</code> 的 <code>Rotation</code> 属性旋转即可。 ##如果你想做图片轮播话建议用 <code>scroview</code>，如果 <code>page</code> 里面有一个竖向的 <code>listview</code> 也有一个横向的，会导致两者冲突，用 <code>scroview</code> 才对。代码换成 <code>scroview</code> 即可完美解决</p><h1 id="例子如下："><a href="#例子如下：" class="headerlink" title="例子如下："></a>例子如下：</h1><h2 id="MainPage-Xaml"><a href="#MainPage-Xaml" class="headerlink" title="MainPage.Xaml"></a>MainPage.Xaml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;             xmlns:local=&quot;clr-namespace:TapListView&quot;             x:Class=&quot;TapListView.MainPage&quot;&gt;    &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;        &lt;Button x:Name=&quot;Button1&quot; Text=&quot;左滑&quot; HorizontalOptions=&quot;FillAndExpand&quot; Opacity=&quot;0.5&quot;&gt;&lt;/Button&gt;        &lt;StackLayout HorizontalOptions=&quot;FillAndExpand&quot;&gt;            &lt;ListView x:Name=&quot;ListView&quot; Rotation=&quot;90&quot; HasUnevenRows=&quot;True&quot;&gt;                &lt;ListView.ItemTemplate&gt;                    &lt;DataTemplate&gt;                        &lt;ViewCell&gt;                            &lt;Image Source=&quot;{Binding .}&quot; Rotation=&quot;270&quot;                                   VerticalOptions=&quot;FillAndExpand&quot;                                   HorizontalOptions=&quot;FillAndExpand&quot;&gt;                            &lt;/Image&gt;                        &lt;/ViewCell&gt;                    &lt;/DataTemplate&gt;                &lt;/ListView.ItemTemplate&gt;            &lt;/ListView&gt;        &lt;/StackLayout&gt;        &lt;Button x:Name=&quot;Button2&quot; Text=&quot;右滑&quot; Opacity=&quot;0.5&quot;                HorizontalOptions=&quot;FillAndExpand&quot;&gt;&lt;/Button&gt;    &lt;/StackLayout&gt;&lt;/ContentPage&gt;</code></pre><h2 id="MainPage-cs（这代码跟横置-ListView-没有关系）"><a href="#MainPage-cs（这代码跟横置-ListView-没有关系）" class="headerlink" title="MainPage.cs（这代码跟横置 ListView 没有关系）"></a>MainPage.cs（这代码跟横置 ListView 没有关系）</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using Xamarin.Forms;namespace TapListView{    public partial class MainPage : ContentPage    {        public List&lt;ImageSource&gt; ImageSources { get; set; } = new List&lt;ImageSource&gt;();        public MainPage()        {            InitializeComponent();            SetSource();            ListView.ItemsSource = ImageSources;        }        private void SetSource()        {            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/4317b8660f13b0826380d5ef0c4bc963_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/7621a57ace831fa0c8616fff6497edf3_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/f5ff39f3f5304a45e8b8b4952fdca368_magazine_web_m.jpg&quot;)));            ImageSources.Add(ImageSource.FromUri(new Uri(&quot;http://img.youguoquan.com/uploads/magazine/content/1595ab2bad62fe267b55c1f450445136_magazine_web_m.jpg&quot;)));        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xamrin 官方博客的文章Getting-started-with-async/await中文翻译</title>
    <link href="undefined2017/05/31/Xamrin%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0Getting-started-with-async-or-await%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <url>2017/05/31/Xamrin%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0Getting-started-with-async-or-await%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>原文在此：<a href="https://blog.xamarin.com/getting-started-with-async-await/" target="_blank" rel="noopener">https://blog.xamarin.com/getting-started-with-async-await/</a><br>英语非常烂，翻得不好请指出。<br>Async／await 翻译<br>   异步编程对于流行的移动开发是很好的手段。对于长时间运行的任务使用异步方法（比如说下载数据的时候）可以保持你的界面有响应。在不使用异步方法的时候或者不正确使用异步或等待的时候，会使你的应用程序 ui 停止响应，然后用户会无法输入，直到这个任务执行完成。这样会导致用户体验很差，然后导致 app 在应用商城的评论很差，所以不使用异步编程并不是一个好的方案。<br>   今天我们会看到使用异步和怎么利用它在 ListView 中预防出现不可控的行为和意外。<br>什么叫做 async／await？<br>   在 net4.5 下分别引入了 async 和 await 关键字，使得你调用异步方法更方便并且让你的代码好读。这个 async／await 的语法糖的原理是使用了 TPL（Task Parallel Library 任务并行库）。如果你想开始一个新的任务并且在 ui 线程的代码运行之前优先完成，你的代码看起来可能是这样的：</p><pre><code>// 开始一个新的任务 (创建一个新的线程)Task.Factory.StartNew (() =&gt; {    // 在后台线程上做点什么, 允许UI保持响应    DoSomething();// 当后台工作完成, 继续运行这个代码块}).ContinueWith (task =&gt; {    DoSomethingOnTheUIThread();// 以下的代码强制ContinueWith的代码在调用线程运行，一般是Main／UI线程}, TaskScheduler.FromCurrentSynchronizationContext ());</code></pre><p>这样不够完美，使用 async／await，上面的会变成：</p><pre><code>await DoSomething();DoSomethingOnTheUIThread();</code></pre><p>上述的代码被后台编译成和第一个例子相同的 TPL 代码，所以说，这仅仅只是语法糖但又如此甜蜜。</p><p>使用 async/await 的陷阱：<br>   在阅读关于使用 async／await 之后，你可以看见一句话“总是异步”但真正的意思是什么呢？简单地说，它的意思是任何一个异步方法的调用（即一个方法的签名有 async 关键字）在调用异步方法的时候都应该使用 await 关键字。当调用调用一个异步方法不使用 await 关键字的结果是抛出“运行时吞没”的异常，导致问题的原因变得很难追踪。使用 await 关键字的要求是：调用的异步方法的签名 async 关键字。举个例子：</p><pre><code>async Task CallingMethod(){    var x = await MyMethodAsync();}</code></pre><p>这就有一个问题，如果你想使用 await 关键字调用一个异步方法的时候，可你又不能使用 async 修饰这个调用的方法，例如说调用的方法签名不能使用 async 关键字的方法，或者系统调用的构造方法。比如说 GetView 在安卓系统的 ArrayApdapter、或者 GetCell 在 ios 系统的 ITableViewDataSource。例如说：</p><pre><code>public override View GetView(int position, View convertView, ViewGroup parent){    /*    在方法签名有不兼容的返回类型，使用无法使用async关键字，    因此无法使用await关键字    */}</code></pre><p>正如你知道的，一个异步方法只能有 void、Task 或者 Task<t>这三种返回，并且返回 void 的情况仅在使得异步处理事件的时候才使用。在上述 GetView 方法的情况下，你需要返回一个安卓的 View，因为 OS 调用它所以明显不能使用 await 关键字，所以不能改成返回 Task<view>，因此不能处理为返回一个 Task<t>。所以你不能在上述的方法中用 async 关键字修饰，所以你也就不能在调用上述的方法的时候使用 await 关键字。为了绕开这个，做一个可能可以实现的尝试，就像过去做的一样。从 GetView 调用一个中间（或者在无法如何不能改变签名的平台上）方法然后异步调用这个中间的方法。</t></view></t></p><pre><code>public override View GetView(int position, View convertView, ViewGroup parent){    IntermediateMethod();    //更多代码}async Task IntermediateMethod(){     await MyMethodAsync();}</code></pre><p>这个问题是：“IntermediateMethod 现在是一个异步方法所以应该被等待就像 MyMethodAsync 方法一样需要被等待。”所以你没有实现什么东西，同样的 IntermediateMethod 现在也是异步应该被等待的。此外，GetView 方法将继续运行所有代码之后才调用“IntermediateMethod()”，这可能不是很让人满意。如果后面的代码调用“IntermediateMethod()”取决于“IntermediateMethod()”的结果，那么它不是让人满意的。在这种情况下，你可能会试着异步调用它的”Wait()”方法（或者 Result 属性）。比如说：</p><pre><code>public override View GetView(int position, View convertView, ViewGroup parent){    IntermediateMethod().Wait();    // 更多代码}</code></pre><p>异步方法调用“Wait()”导致调用线程停止，直到异步方法完成才会恢复。如果这是 Ui 线程，那么你的 UI 将在异步 Task 运行的时候挂起。这不是很好，尤其是在 ArrayAdapter 在为 ListView 的行提供数据的时候，用户将无法与 ListView 进行交互，直到所有的行的数据都已经完成下载，并且滚动是完全没有反应或者有卡顿的，这不是一个好的用户体验。还有一个可以调用异步任务的 Result 属性。如果你的异步任务是返回 Task<t>，则使用以下这种写法。这将导致调用的线程等待异步任务的结果。</t></p><pre><code>public override View GetView(int position, View convertView, ViewGroup parent){    view.Text = IntermediateMethod().Result;    // 更多代码}async Task&lt;string&gt; IntermediateMethod(){     return await MyMethodAsync();     // 在这个例子中MyMethodAsync也返回Task&lt;string&gt;。}</code></pre><p>事实上按上面代码那样做可能导致你的 UI 完全挂起并且那个不启动的 ListView 永远都不会填充它。可能还是一卡一卡的。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-8b47e31b9e4fd081.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="image.png"></p><p>一般来说，你应该避免使用“Wait()”和”Result”，特别是在 UI 线程上。在这个博客的末尾有一些 Ios 和安卓的项目，你可以分别看 ViewControllerJerky 和 MainActivityJerky 的这的实现，这些文件夹没有设置为在示例项目中进行编译。</p><p>使用异步的方式：<br>那么在这种情况下异步如何实现呢？解决上面的问题的方法是回到以前实现 async/await 的 TPL。你要直接使用 TPL，但只有一次启动异步方法调用链（并且马上创建一个新线程）。TPL 在某处将直接使用，同样的你需要使用 TPL 启动一个新的线程。不能仅仅使用 async/await 关键字启动一个新的线程，所以对于一些方法的调用链不得不使用 TPL 启动新的线程（或另外一种方法），启动新线程的异步方法将会是一种框架方法，像許多（这种“多”不是绝大多的那种“多”）情況下的“.NET HttpClient”<br>異步方法。如果不使用异步框架方法，那么你的调用链中的某些方法不可不启动一个新的线程并且返回 Task 或者 Task<t>。<br>   让我们开始一个例子使用 GetView 在安卓平台的项目（尽管相同思想可以适用在任何平台例如 Xamarin.iOS, Xamarin.Forms），比如说我有一个 istView，我想填充从网络动态下载的文本（一般会先下载整个字符串列表，然后用已经下载的内容填充列表，但是为了演示，我逐行下载这些文本。再说了，可能有些地方也会要这么做呢）。<br>   我当然不想让 UI 线程等待多次下载。反而，我希望 ListView 能够开始就让用户可以滚动使用，并且随着文本的下载，文本将在每个 ListView 的 Item 中显示。我还想保证，如果一个 Item 滚出 View，那么当它被重用的时候，它会取消加载正在下载的文本，并且开始为该行添加新的文本。我们会用 TPL 和取消 Token 来实现这件事，代码的注释应该能说明正在做什么。</t></p><pre><code>public override View GetView(int position, View convertView, ViewGroup parent){   /* 我们需要一个CancellationTokenSource，如果在文本已经被加载的情况下       View在屏幕上重新展示的时候，可以取消这个异步调用。没有这个的话,      如果一个View正在加载一些文本，但View在屏幕上移动并且返回，则新加载的      数据可能比旧加载的数据所需的时间少，然后旧的数据就会覆盖新的数据，这样      就会显示错误的数据。所以在加载新文本之前，我们要在View重新出现时取消任何异步      任务。    */    CancellationTokenSource cts;    View view = convertView; // 如果有View可用，则重复利用现有的View    // 否则创建一个新的View    if (view == null) {        view = context.LayoutInflater.Inflate(Android.Resource.Layout.SimpleListItem1, null);    } else {        //如果View存在, 调用cts.Cancel()取消此View在等待的异步加载文本任务        var wrapper = view.Tag.JavaCast&lt;Wrapper&lt;CancellationTokenSource&gt;&gt;();        cts = wrapper.Data;        // 如果请求尚未取消，则取消异步任务。        if (!cts.IsCancellationRequested)        {           cts.Cancel();        }    }    TextView textView = view.FindViewById&lt;TextView&gt;(Android.Resource.Id.Text1);    textView.Text = &quot;placeholder&quot;;    // 为此View的“异步调用”创建新的CancellationTokenSource    cts = new CancellationTokenSource();    // 将其添加到包含在Java.Lang.Object中的View的Tag属性中    view.Tag = new Wrapper&lt;CancellationTokenSource&gt; { Data = cts };    // 获得取消的Token并且传入异步方法。    var ct = cts.Token;    Task.Run(async () =&gt; {        try        {            textView.Text = await GetTextAsync(position, ct);        } catch (System.OperationCanceledException ex) {            Console.WriteLine($&quot;Text load cancelled: {ex.Message}&quot;);        } catch (Exception ex) {            Console.WriteLine(ex.Message);        }    }, ct);    return view;}</code></pre><p>简单来说，上述方法检查这是否是一个重用的 Item，如果是，但是还不完整，我们将取消现有的异步文本下载任务。然后将占位符文本加载到 Item 中，启动异步任务来下载改行的正确文本，并且立刻返回具有占位符文本的 View，进而填充 ListView。这样会保持 Ui 的响应，并且在 Item 中显示某些内容，而启动的任务会从 Web 获得正确的文本。<br>   随着文本的下载，你会看到占位符逐一更改成下载的文本（由于下载的次数不同，不一定是按顺序排列的。）。因为我做了这样简单、快速的请求所以我给异步任务添加了一个随机延迟来模拟这个行为，以下是 GetTextAsync 方法的实现：</p><pre><code>async Task&lt;string&gt; GetTextAsync(int position, CancellationToken ct){    // 检查任务是否被取消，如果被取消则抛出“取消”的异常。    // 很好的检查几个点，包括在返回字符串之前    ct.ThrowIfCancellationRequested();    // 模拟一个任务需要的时间变量    await Task.Delay(rand.Next(100,500));    ct.ThrowIfCancellationRequested();    if (client == null)    {        client = new HttpClient();    }    string response = await client.GetStringAsync(&quot;http://example.com&quot;);    string stringToDisplayInList = response.Substring(41, 14) + &quot; &quot; + position.ToString();    ct.ThrowIfCancellationRequested();    return stringToDisplayInList;}</code></pre><p>请注意，我可以使用 async 关键字来修饰传入 Task.Run()的 Lambda，从而让我等待着我的异步方法的调用，从而实现“总是异步”，在 ListView 上没有多余的卡顿！。</p><p><img src="http://upload-images.jianshu.io/upload_images/5692364-9995549dea3e9de4.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="image.png"></p><p>在行动中看它：<br>如果你想看到上面的 Xamarin.iOS、Xamarin.Android、Xamarin.Forms 的实现，请查看我的<a href="https://github.com/jgold6/AsyncAllTheWaySamples" target="_blank" rel="noopener">Github repo</a>。Ios 版本和上面的例子非常相似，唯一的区别在于如何将 CancellationTokenSource 附加到 Item，因为其没有 Tag 属性。然而，Xamarin.Forms 并没有直接等同于我所知道的 GetView 或 GetCell，所以我通过 App 的构造函数启动异步任务来模拟相同的行为来获取每一行的文本。<br>   异步编程是快乐的！</p><p>译者附送：<br>AsyncAllTheWayXamForms 实现，AsyncAllTheWayXamForms.cs</p><pre><code>using System;using Xamarin.Forms;using System.Collections.ObjectModel;using System.Threading.Tasks;using System.Net.Http;using System.Collections.Generic;using UIKit;namespace AsyncAllTheWayXamForms{    public class App : Application    {        var items = new ObservableCollection&lt;string&gt;();        HttpClient client { get; set;}        Random rand { get; set;}        var indexes = new List&lt;int&gt;();        public App()        {            rand = new Random(DateTime.Now.Millisecond);            // 在项目列表占位符文本和数字1-50填充索引。            for (int i = 0; i &lt; 50; i++)            {                items.Add(&quot;Placeholder&quot;);                indexes.Add(i);            }            // 随机赋值索引（这样列表会以随机的排序加载）            for (int i = 0; i &lt; 49; i++)            {                int swapindex = rand.Next(0, 49);                int hold = indexes[i];                indexes[i] = indexes[swapindex];                indexes[swapindex] = hold;            }            // 这个app的根页面            var content = new ContentPage            {                Title = &quot;AsyncAllTheWayXamForms&quot;,                Content = new ListView                {                    VerticalOptions = LayoutOptions.FillAndExpand,                    HorizontalOptions = LayoutOptions.FillAndExpand,                    ItemsSource = items                }            };            MainPage = new NavigationPage(content);            Task.Run(async () =&gt;            {                if (client == null)                {                    client = new HttpClient();                }                for (int i = 0; i &lt; 50; i++)                {                    string text = await GetItemAsync(i);                    items.RemoveAt(indexes[i]);                    items.Insert(indexes[i], text);                }            });        }        public async Task&lt;string&gt; GetItemAsync(int i)        {            string response =                          await client.GetStringAsync(&quot;http://example.com&quot;);            string stringToDisplayInList = response.Substring(41, 14) +                           &quot; &quot; + indexes[i].ToString();            return stringToDisplayInList;        }        protected override void OnStart()        {            // 当app启动的时候调用（ps：在这里跟异步毫无关系,系统自带方法）        }        protected override void OnSleep()        {            // 当app挂起的时候调用（ps：在这里跟异步毫无关系,系统自带方法）        }        protected override void OnResume()        {            // 当app从挂起恢复的时候调用（ps：在这里跟异步毫无关系,系统自带方法）        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>XamarinForms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇葩说-第四季金句</title>
    <link href="undefined2017/05/04/%E5%A5%87%E8%91%A9%E8%AF%B4-01/"/>
    <url>2017/05/04/%E5%A5%87%E8%91%A9%E8%AF%B4-01/</url>
    
    <content type="html"><![CDATA[<p>抬头看着太阳说，你该下山了。 – 欧阳超</p><p>世上是没有事有意义的，意义都是人赋予的，而坚持本身就是无比闪亮的意义 – 陈铭</p><p>你不觉得，现实本身是由梦想来支撑的吗？– 张泉灵</p><p>好朋友就像另一个自己，我们要听好朋友的声音是听一个我们无法跟自己内心 直接对话可是我们想要听到另外一个自己的声音，你作为一个好朋友，不提供这个声音让那个人听见，却误以为他只要照他自己的意思走下去就够了，那他在世界上孤身一人家好了，要好朋友干什么？所以好朋友像人生的一个滤勺，它把我们的杂质都滤掉了，让我们更纯净。 – 蔡康永</p><p>什么叫梦想，一种叫我实现了梦想，一种是梦想因我而实现。– 宋佳</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>